/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/mocha-loader/index.js!./test/index-test.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./test/index-test.js":
/*!************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./test/index-test.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/mocha-loader/index.js!./test/index-test.js":
/*!********************************************************!*\
  !*** ./node_modules/mocha-loader!./test/index-test.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/mocha-loader/web.js */ "./node_modules/mocha-loader/web.js");
if(typeof window !== 'undefined' && window.initMochaPhantomJS) { window.initMochaPhantomJS(); }
mocha.setup({"ui":"bdd"});
__webpack_require__(/*! !./node_modules/babel-loader/lib!./test/index-test.js */ "./node_modules/babel-loader/lib/index.js!./test/index-test.js")
__webpack_require__(/*! !./node_modules/mocha-loader/start.js */ "./node_modules/mocha-loader/start.js");
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../mocha-loader/node_modules/css-loader/lib/css-base.js */ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "@charset \"utf-8\";\n\nbody {\n  margin:0;\n}\n\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n\n#mocha ul,\n#mocha li {\n  margin: 0;\n  padding: 0;\n}\n\n#mocha ul {\n  list-style: none;\n}\n\n#mocha h1,\n#mocha h2 {\n  margin: 0;\n}\n\n#mocha h1 {\n  margin-top: 15px;\n  font-size: 1em;\n  font-weight: 200;\n}\n\n#mocha h1 a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha h1 a:hover {\n  text-decoration: underline;\n}\n\n#mocha .suite .suite h1 {\n  margin-top: 0;\n  font-size: .8em;\n}\n\n#mocha .hidden {\n  display: none;\n}\n\n#mocha h2 {\n  font-size: 12px;\n  font-weight: normal;\n  cursor: pointer;\n}\n\n#mocha .suite {\n  margin-left: 15px;\n}\n\n#mocha .test {\n  margin-left: 15px;\n  overflow: hidden;\n}\n\n#mocha .test.pending:hover h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n\n#mocha .test.pass.medium .duration {\n  background: #c09853;\n}\n\n#mocha .test.pass.slow .duration {\n  background: #b94a48;\n}\n\n#mocha .test.pass::before {\n  content: '\\2713';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #00d6b2;\n}\n\n#mocha .test.pass .duration {\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n  color: #fff;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -ms-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n\n#mocha .test.pass.fast .duration {\n  display: none;\n}\n\n#mocha .test.pending {\n  color: #0b97c4;\n}\n\n#mocha .test.pending::before {\n  content: '\\25E6';\n  color: #0b97c4;\n}\n\n#mocha .test.fail {\n  color: #c00;\n}\n\n#mocha .test.fail pre {\n  color: black;\n}\n\n#mocha .test.fail::before {\n  content: '\\2716';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #c00;\n}\n\n#mocha .test pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n\n#mocha .test .html-error {\n  overflow: auto;\n  color: black;\n  line-height: 1.5;\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  max-height: 300px;\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test .html-error pre.error {\n  border: none;\n  -webkit-border-radius: 0;\n  -moz-border-radius: 0;\n  border-radius: 0;\n  -webkit-box-shadow: 0;\n  -moz-box-shadow: 0;\n  box-shadow: 0;\n  padding: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n}\n\n/**\n * (1): approximate for browsers not supporting calc\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n *      ^^ seriously\n */\n#mocha .test pre {\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test h2 {\n  position: relative;\n}\n\n#mocha .test a.replay {\n  position: absolute;\n  top: 3px;\n  right: 0;\n  text-decoration: none;\n  vertical-align: middle;\n  display: block;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  background: #eee;\n  font-size: 15px;\n  -webkit-border-radius: 15px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  -webkit-transition:opacity 200ms;\n  -moz-transition:opacity 200ms;\n  -o-transition:opacity 200ms;\n  transition: opacity 200ms;\n  opacity: 0.3;\n  color: #888;\n}\n\n#mocha .test:hover a.replay {\n  opacity: 1;\n}\n\n#mocha-report.pass .test.fail {\n  display: none;\n}\n\n#mocha-report.fail .test.pass {\n  display: none;\n}\n\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n\n#mocha-stats {\n  position: fixed;\n  top: 15px;\n  right: 10px;\n  font-size: 12px;\n  margin: 0;\n  color: #888;\n  z-index: 1;\n}\n\n#mocha-stats .progress {\n  float: right;\n  padding-top: 0;\n\n  /**\n   * Set safe initial values, so mochas .progress does not inherit these\n   * properties from Bootstrap .progress (which causes .progress height to\n   * equal line height set in Bootstrap).\n   */\n  height: auto;\n  -webkit-box-shadow: none;\n  -moz-box-shadow: none;\n  box-shadow: none;\n  background-color: initial;\n}\n\n#mocha-stats em {\n  color: black;\n}\n\n#mocha-stats a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n\n#mocha-stats li {\n  display: inline-block;\n  margin: 0 5px;\n  list-style: none;\n  padding-top: 11px;\n}\n\n#mocha-stats canvas {\n  width: 40px;\n  height: 40px;\n}\n\n#mocha code .comment { color: #ddd; }\n#mocha code .init { color: #2f6fad; }\n#mocha code .string { color: #5890ad; }\n#mocha code .keyword { color: #8a6343; }\n#mocha code .number { color: #2f6fad; }\n\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0px;\n  }\n\n  #mocha #stats {\n    position: absolute;\n  }\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader!./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../mocha-loader/node_modules/css-loader!./mocha.css */ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(/*! ../mocha-loader/node_modules/style-loader/lib/addStyles.js */ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/mocha-loader/start.js":
/*!********************************************!*\
  !*** ./node_modules/mocha-loader/start.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {
	delete __webpack_require__.c[module.i];
	if(typeof window !== "undefined" && window.mochaPhantomJS)
		mochaPhantomJS.run();
	else
		mocha.run();
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha-loader/web.js":
/*!******************************************!*\
  !*** ./node_modules/mocha-loader/web.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (! document.getElementById("mocha")) { document.write("<div id=\"mocha\"></div>"); }

__webpack_require__(/*! style-loader!css-loader!mocha/mocha.css */ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
__webpack_require__(/*! script-loader!mocha/mocha.js */ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js");


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js":
/*!***************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/mocha/mocha.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/* eslint no-unused-vars: off */\n/* eslint-env commonjs */\n\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')({level: false});\n\nvar Mocha = require('./lib/mocha');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({ reporter: 'html' });\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function (e, fn) {\n  if (e === 'uncaughtException') {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function () {};\n    }\n    var i = uncaughtExceptionHandlers.indexOf(fn);\n    if (i !== -1) {\n      uncaughtExceptionHandlers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function (e, fn) {\n  if (e === 'uncaughtException') {\n    global.onerror = function (err, url, line) {\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = [];\nvar immediateTimeout;\n\nfunction timeslice () {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function (callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function (err) {\n  uncaughtExceptionHandlers.forEach(function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function (ui) {\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function (opts) {\n  if (typeof opts === 'string') {\n    opts = { ui: opts };\n  }\n  for (var opt in opts) {\n    if (opts.hasOwnProperty(opt)) {\n      this[opt](opts[opt]);\n    }\n  }\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function (fn) {\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) {\n    mocha.grep(query.grep);\n  }\n  if (query.fgrep) {\n    mocha.fgrep(query.fgrep);\n  }\n  if (query.invert) {\n    mocha.invert();\n  }\n\n  return Mocha.prototype.run.call(mocha, function (err) {\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n// this allows test/acceptance/required-tokens.js to pass; thus,\n// you can now do `const describe = require('mocha').describe` in a\n// browser context (assuming browserification).  should fix #880\nmodule.exports = global;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./lib/mocha\":13,\"_process\":56,\"browser-stdout\":39}],2:[function(require,module,exports){\n'use strict';\n\n// just stub out growl\n\nmodule.exports = require('../utils').noop;\n\n},{\"../utils\":36}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress () {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function (size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function (text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function (size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function (family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function (n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function (ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (err) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],4:[function(require,module,exports){\n(function (global){\n'use strict';\n\nexports.isatty = function isatty () {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize () {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],5:[function(require,module,exports){\n'use strict';\n/**\n * @module Context\n */\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context () {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context} context\n */\nContext.prototype.runnable = function (runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set or get test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this.runnable().enableTimeouts();\n  }\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set or get test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().slow();\n  }\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @throws Pending\n */\nContext.prototype.skip = function () {\n  this.runnable().skip();\n};\n\n/**\n * Set or get a number of allowed retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n/**\n * @module Hook\n *\n */\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`. Derived from\n * `Runnable`.\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\nfunction Hook (title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @memberof Mocha.Hook\n * @public\n * @param {Error} err\n * @return {Error}\n * @api public\n */\nHook.prototype.error = function (err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],7:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function (title, fn) {\n      return common.test.only(mocha, context.it(title, fn));\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function (title) {\n      return context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function (n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],8:[function(require,module,exports){\n'use strict';\n\nvar Suite = require('../suite');\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function (suites, context, mocha) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite (suite) {\n      return function run () {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only (opts) {\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip (opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create (opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw new Error('Suite \"' + suite.fullTitle() + '\" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.');\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        test.parent._onlyTests = test.parent._onlyTests.concat(test);\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function (n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{\"../suite\":34}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * Exports-style (as Node.js module) interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit (obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":34,\"../test\":35}],10:[function(require,module,exports){\n'use strict';\n\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":7,\"./exports\":9,\"./qunit\":11,\"./tdd\":12}],11:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Exclusive Suite.\n     */\n\n    context.suite.only = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function (title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],12:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],13:[function(require,module,exports){\n(function (process,global,__dirname){\n'use strict';\n\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n/**\n * @namespace Mocha\n * @module Mocha\n */\n/**\n * Module dependencies.\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\n/**\n * @public\n * @class utils\n * @memberof Mocha\n */\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\n/**\n *\n * @memberof Mocha\n * @public\n */\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\n/**\n *\n * @memberof Mocha\n */\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @api private\n * @param {string} name\n * @return {string}\n */\nfunction image (name) {\n  return path.join(__dirname, '../images', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @public\n * @class Mocha\n * @param {Object} options\n * @api public\n */\nfunction Mocha (options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.fgrep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @public\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @public\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function (file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @public\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function (reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        if (err.message.indexOf('Cannot find module') !== -1) {\n          // Try to load reporters from a path (absolute or relative)\n          try {\n            _reporter = require(path.resolve(process.cwd(), reporter));\n          } catch (_err) {\n            err.message.indexOf('Cannot find module') !== -1 ? console.warn('\"' + reporter + '\" reporter not found')\n              : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n          }\n        } else {\n          console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n        }\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn('The Teamcity reporter was moved to a package named ' +\n        'mocha-teamcity-reporter ' +\n        '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n * @public\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function (name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n\n  this.suite.on('pre-require', function (context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.xit = context.xit || context.test.skip;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function (fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function (file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function (runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function () {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Escape string and add it to grep as a regexp.\n *\n * @public\n * @api public\n * @param str\n * @returns {Mocha}\n */\nMocha.prototype.fgrep = function (str) {\n  return this.grep(new RegExp(escapeRe(str)));\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @public\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function (re) {\n  if (utils.isString(re)) {\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\n    var arg = re.match(/^\\/(.*)\\/(g|i|)$|.*/);\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\n  } else {\n    this.options.grep = re;\n  }\n  return this;\n};\n/**\n * Invert `.grep()` matches.\n *\n * @public\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function () {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @public\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function (ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.checkLeaks = function () {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.fullTrace = function () {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.growl = function () {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function (globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function (colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function (inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Do not show diffs at all.\n *\n * @param {Boolean} hideDiff\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} hideDiff\n * @return {Mocha}\n */\nMocha.prototype.hideDiff = function (hideDiff) {\n  this.options.hideDiff = hideDiff !== undefined && hideDiff;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function (timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.retries = function (n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function (slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function (enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.asyncOnly = function () {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n * @public\n */\nMocha.prototype.noHighlighting = function () {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.allowUncaught = function () {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay () {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Tests marked only fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidOnly = function () {\n  this.options.forbidOnly = true;\n  return this;\n};\n\n/**\n * Pending tests and tests marked skip fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidPending = function () {\n  this.options.forbidPending = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * Note that `loadFiles` relies on Node's `require` to execute\n * the test interface functions and will be subject to the\n * cache - if the files are already in the `require` cache,\n * they will effectively be skipped. Therefore, to run tests\n * multiple times or to run tests in files that are already\n * in the `require` cache, make sure to clear them from the\n * cache first in whichever manner best suits your needs.\n *\n * @api public\n * @public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function (fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  runner.forbidOnly = options.forbidOnly;\n  runner.forbidPending = options.forbidPending;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n  exports.reporters.Base.hideDiff = options.hideDiff;\n\n  function done (failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":5,\"./hook\":6,\"./interfaces\":10,\"./reporters\":20,\"./runnable\":32,\"./runner\":33,\"./suite\":34,\"./test\":35,\"./utils\":36,\"_process\":56,\"escape-string-regexp\":46,\"growl\":2,\"path\":40}],14:[function(require,module,exports){\n'use strict';\n/**\n * @module milliseconds\n */\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {string|number} val\n * @return {string|number}\n */\nmodule.exports = function (val) {\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  return format(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse (str) {\n  var match = (/^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n      // No default case\n  }\n}\n\n/**\n * Format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction format (ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending (message) {\n  this.message = message;\n}\n\n},{}],16:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module Base\n */\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '',\n  err: '',\n  dot: '',\n  comma: ',',\n  bang: '!'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = exports.color = function (type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n    ? process.stdout.getWindowSize(1)[0]\n    : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function () {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function () {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function () {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function () {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function () {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\nfunction showDiff (err) {\n  return err && err.showDiff !== false && sameType(err.actual, err.expected) && err.expected !== undefined;\n}\n\nfunction stringifyDiffObjs (err) {\n  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {\n    err.actual = utils.stringify(err.actual);\n    err.expected = utils.stringify(err.expected);\n  }\n}\n\n/**\n * Returns a diff between 2 strings with coloured ANSI output.\n *\n * The diff will be either inline or unified dependant on the value\n * of `Base.inlineDiff`.\n *\n * @param {string} actual\n * @param {string} expected\n * @return {string} Diff\n */\nvar generateDiff = exports.generateDiff = function (actual, expected) {\n  return exports.inlineDiffs\n    ? inlineDiff(actual, expected)\n    : unifiedDiff(actual, expected);\n};\n\n/**\n * Output the given `failures` as a list.\n *\n * @public\n * @memberof Mocha.reporters.Base\n * @variation 1\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function (failures) {\n  console.log();\n  failures.forEach(function (test, i) {\n    // format\n    var fmt = color('error title', '  %s) %s:\\n') +\n      color('error message', '     %s') +\n      color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message && typeof err.message.toString === 'function') {\n      message = err.message + '';\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = message ? stack.indexOf(message) : -1;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (!exports.hideDiff && showDiff(err)) {\n      stringifyDiffObjs(err);\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      msg += generateDiff(err.actual, err.expected);\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    // indented test title\n    var testTitle = '';\n    test.titlePath().forEach(function (str, index) {\n      if (index !== 0) {\n        testTitle += '\\n     ';\n      }\n      for (var i = 0; i < index; i++) {\n        testTitle += '  ';\n      }\n      testTitle += str;\n    });\n\n    console.log(fmt, (i + 1), testTitle, msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @memberof Mocha.reporters\n * @public\n * @class\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base (runner) {\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\n  var failures = this.failures = [];\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function () {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function (suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function () {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function (test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function (test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    if (showDiff(err)) {\n      stringifyDiffObjs(err);\n    }\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.once('end', function () {\n    stats.end = new Date();\n    stats.duration = stats.end - stats.start;\n  });\n\n  runner.on('pending', function () {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @memberof Mocha.reporters.Base\n * @public\n * @api public\n */\nBase.prototype.epilogue = function () {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ') +\n    color('green', ' %d passing') +\n    color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ') +\n      color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad (str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} Diff\n */\nfunction inlineDiff (actual, expected) {\n  var msg = errorDiff(actual, expected);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function (str, i) {\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n' +\n    color('diff removed', 'actual') +\n    ' ' +\n    color('diff added', 'expected') +\n    '\\n\\n' +\n    msg +\n    '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} The diff.\n */\nfunction unifiedDiff (actual, expected) {\n  var indent = '      ';\n  function cleanUp (line) {\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/@@/)) {\n      return '--';\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank (line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', actual, expected);\n  var lines = msg.split('\\n').splice(5);\n  return '\\n      ' +\n    colorLines('diff added', '+ expected') + ' ' +\n    colorLines('diff removed', '- actual') +\n    '\\n\\n' +\n    lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} the diff\n */\nfunction errorDiff (actual, expected) {\n  return diff.diffWordsWithSpace(actual, expected).map(function (str) {\n    if (str.added) {\n      return colorLines('diff added', str.value);\n    }\n    if (str.removed) {\n      return colorLines('diff removed', str.value);\n    }\n    return str.value;\n  }).join('');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines (name, str) {\n  return str.split('\\n').map(function (str) {\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType (a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":14,\"../utils\":36,\"_process\":56,\"diff\":45,\"supports-color\":40,\"tty\":4}],17:[function(require,module,exports){\n'use strict';\n/**\n * @module Doc\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends {Base}\n * @public\n * @param {Runner} runner\n * @api public\n */\nfunction Doc (runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function (test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function (test, err) {\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":36,\"./base\":16}],18:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Dot\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @public\n * @api public\n * @param {Runner} runner\n */\nfunction Dot (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var n = -1;\n\n  runner.on('start', function () {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.comma));\n  });\n\n  runner.on('pass', function (test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.bang));\n  });\n\n  runner.once('end', function () {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],19:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/* eslint-env browser */\n/**\n * @module HTML\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">' +\n  '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>' +\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\n  '</ul>';\n\nvar playIcon = '&#x2023;';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction HTML (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/pass/).test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/fail/).test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      updateStats();\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('pass', function (test) {\n    var url = self.testURL(test);\n    var markup = '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\n      '<a href=\"%s\" class=\"replay\">' + playIcon + '</a></h2></li>';\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('fail', function (test) {\n    var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' + playIcon + '</a></h2></li>',\n      test.title, self.testURL(test));\n    var stackString; // Note: Includes leading newline\n    var message = test.err.toString();\n\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n    // check for the result of the stringifying.\n    if (message === '[object Error]') {\n      message = test.err.message;\n    }\n\n    if (test.err.stack) {\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\n      if (indexOfMessage === -1) {\n        stackString = test.err.stack;\n      } else {\n        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\n      }\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n    }\n\n    stackString = stackString || '';\n\n    if (test.err.htmlMessage && stackString) {\n      el.appendChild(fragment('<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\n        test.err.htmlMessage, stackString));\n    } else if (test.err.htmlMessage) {\n      el.appendChild(fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage));\n    } else {\n      el.appendChild(fragment('<pre class=\"error\">%e%e</pre>', message, stackString));\n    }\n\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('pending', function (test) {\n    var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    appendToStack(el);\n    updateStats();\n  });\n\n  function appendToStack (el) {\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  }\n\n  function updateStats () {\n    // TODO: add to stats\n    var percent = stats.tests / runner.total * 100 | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n  }\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl (s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function (suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function (test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Adds code toggle functionality for the provided test's list element.\n *\n * @param {HTMLLIElement} el\n * @param {string} contents\n */\nHTML.prototype.addCodeToggle = function (el, contents) {\n  var h2 = el.getElementsByTagName('h2')[0];\n\n  on(h2, 'click', function () {\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n  });\n\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\n  el.appendChild(pre);\n  pre.style.display = 'none';\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error (msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment (html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function (_, type) {\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout (classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide () {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text (el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on (el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":3,\"../utils\":36,\"./base\":16,\"escape-string-regexp\":46}],20:[function(require,module,exports){\n'use strict';\n\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":16,\"./doc\":17,\"./dot\":18,\"./html\":19,\"./json\":22,\"./json-stream\":21,\"./landing\":23,\"./list\":24,\"./markdown\":25,\"./min\":26,\"./nyan\":27,\"./progress\":28,\"./spec\":29,\"./tap\":30,\"./xunit\":31}],21:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSONStream\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `JSONStream` test reporter.\n *\n * @public\n * @name JSONStream\n * @class JSONStream\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function () {\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function (test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function (test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.once('end', function () {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],22:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSON\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @public\n * @class JSON\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function (test) {\n    pending.push(test);\n  });\n\n  runner.once('end', function () {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  var err = test.err || {};\n  if (err instanceof Error) {\n    err = errorJSON(err);\n  }\n\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: cleanCycles(err)\n  };\n}\n\n/**\n * Replaces any circular references inside `obj` with '[object Object]'\n *\n * @api private\n * @param {Object} obj\n * @return {Object}\n */\nfunction cleanCycles (obj) {\n  var cache = [];\n  return JSON.parse(JSON.stringify(obj, function (key, value) {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.indexOf(value) !== -1) {\n        // Instead of going in a circle, we'll print [object Object]\n        return '' + value;\n      }\n      cache.push(value);\n    }\n\n    return value;\n  }));\n}\n\n/**\n * Transform an Error object into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON (err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function (key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],23:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Landing\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Landing (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '');\n  var crashed = -1;\n  var n = 0;\n\n  function runway () {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function () {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function (test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.once('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],24:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module List\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('test', function (test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = color('checkmark', '  -') +\n      color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function (test) {\n    var fmt = color('checkmark', '  ' + Base.symbols.ok) +\n      color('pass', ' %s: ') +\n      color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function (test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],25:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Markdown\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown (runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title (str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC (suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function (suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC (obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC (suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function (suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function () {\n    --level;\n  });\n\n  runner.on('pass', function (test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.once('end', function () {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],26:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Min\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Min (runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function () {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.once('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],27:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Nyan\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n * @public\n * @class Nyan\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n */\n\nfunction NyanCat (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var nyanCatWidth = this.nyanCatWidth = 11;\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = (width - nyanCatWidth);\n\n  runner.on('start', function () {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function () {\n    self.draw();\n  });\n\n  runner.on('pass', function () {\n    self.draw();\n  });\n\n  runner.on('fail', function () {\n    self.draw();\n  });\n\n  runner.once('end', function () {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function () {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function () {\n  var stats = this.stats;\n\n  function draw (type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function () {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function () {\n  var self = this;\n\n  this.trajectories.forEach(function (line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function () {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function () {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function (n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function (n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function () {\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function (str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write (string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],28:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Progress\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress (runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.50 | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  var reporterOptions = options.reporterOptions || {};\n\n  options.open = reporterOptions.open || '[';\n  options.complete = reporterOptions.complete || '';\n  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;\n  options.close = reporterOptions.close || ']';\n  options.verbose = reporterOptions.verbose || false;\n\n  // tests started\n  runner.on('start', function () {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function () {\n    complete++;\n\n    var percent = complete / total;\n    var n = width * percent | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.once('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],29:[function(require,module,exports){\n'use strict';\n/**\n * @module Spec\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Spec (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('suite', function (suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function () {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function (test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s');\n      console.log(fmt, test.title);\n    } else {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s') +\n        color(test.speed, ' (%dms)');\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function (test) {\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":36,\"./base\":16}],30:[function(require,module,exports){\n'use strict';\n/**\n * @module TAP\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction TAP (runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function () {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function () {\n    ++n;\n  });\n\n  runner.on('pending', function (test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function (test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function (test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.once('end', function () {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title (test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":16}],31:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module XUnit\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit (runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  // the name of the test suite, as it will appear in the resulting XML file\n  var suiteName;\n\n  // the default name of the test suite if none is provided\n  var DEFAULT_SUITE_NAME = 'Mocha Tests';\n\n  if (options && options.reporterOptions) {\n    if (options.reporterOptions.output) {\n      if (!fs.createWriteStream) {\n        throw new Error('file output not supported in browser');\n      }\n\n      mkdirp.sync(path.dirname(options.reporterOptions.output));\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n    }\n\n    // get the suite name from the reporter options (if provided)\n    suiteName = options.reporterOptions.suiteName;\n  }\n\n  // fall back to the default suite name\n  suiteName = suiteName || DEFAULT_SUITE_NAME;\n\n  runner.on('pending', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    tests.push(test);\n  });\n\n  runner.once('end', function () {\n    self.write(tag('testsuite', {\n      name: suiteName,\n      tests: stats.tests,\n      failures: stats.failures,\n      errors: stats.failures,\n      skipped: stats.tests - stats.failures - stats.passes,\n      timestamp: (new Date()).toUTCString(),\n      time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function (t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function (failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function () {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function (line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function (test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: (test.duration / 1000) || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, escape(err.message) + '\\n' + escape(err.stack))));\n  } else if (test.isPending()) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag (name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":36,\"./base\":16,\"_process\":56,\"fs\":40,\"mkdirp\":53,\"path\":40}],32:[function(require,module,exports){\n(function (global){\n'use strict';\n/**\n * @module Runnable\n */\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.  Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {String} title\n * @param {Function} fn\n */\nfunction Runnable (title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._retries = -1;\n  this._currentRetry = 0;\n  this.pending = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nutils.inherits(Runnable, EventEmitter);\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  // see #1652 for reasoning\n  if (ms === 0 || ms > Math.pow(2, 31)) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set or get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function (ms) {\n  if (!arguments.length || typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n */\nRunnable.prototype.skip = function () {\n  throw new Pending('sync skip');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @api private\n */\nRunnable.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Return `true` if this Runnable has failed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isFailed = function () {\n  return !this.isPending() && this.state === 'failed';\n};\n\n/**\n * Return `true` if this Runnable has passed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isPassed = function () {\n  return !this.isPending() && this.state === 'passed';\n};\n\n/**\n * Set or get number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Set or get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function (n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by concatenating the parent's title path with the title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.titlePath = function () {\n  return this.parent.titlePath().concat([this.title]);\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function () {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function () {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function () {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(self._timeoutError(ms));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Set or get a list of whitelisted globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function (globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function (fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple (err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    var msg = 'done() called multiple times';\n    if (err && err.message) {\n      err.message += \" (and Mocha's \" + msg + ')';\n      self.emit('error', err);\n    } else {\n      self.emit('error', new Error(msg));\n    }\n  }\n\n  // finished\n  function done (err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n\n    if (finished) {\n      return multiple(err);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = self._timeoutError(ms);\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip () {\n      done(new Pending('async skip call'));\n      // halt execution.  the Runnable will be marked pending\n      // by the previous call, and the uncaught handler will ignore\n      // the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      emitted = true;\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    emitted = true;\n    done(utils.getError(err));\n  }\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function (reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync (fn) {\n    var result = fn.call(ctx, function (err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: ' +\n            JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(new Error('Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'));\n      }\n\n      done();\n    });\n  }\n};\n\n/**\n * Instantiates a \"timeout\" error\n *\n * @param {number} ms - Timeout (in milliseconds)\n * @returns {Error} a \"timeout\" error\n * @private\n */\nRunnable.prototype._timeoutError = function (ms) {\n  var msg = 'Timeout of ' + ms + 'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.';\n  if (this.file) {\n    msg += ' (' + this.file + ')';\n  }\n  return new Error(msg);\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":14,\"./pending\":15,\"./utils\":36,\"debug\":43,\"events\":47}],33:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * @module Runner\n */\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @memberof Mocha\n * @public\n * @class\n * @api public\n * @param {Suite} [suite] Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner (suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function (test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function (hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Mocha.Runner\n * @api public\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function (test, err) {\n  if (test.isPending()) {\n    return;\n  }\n\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || (err && typeof err.message === 'string'))) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  try {\n    err.stack = (this.fullStackTrace || !err.stack)\n      ? err.stack\n      : stackFilter(err.stack);\n  } catch (ignored) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function (hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n  this.fail(hook, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next (i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function (err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function (err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          if (name === 'beforeEach' || name === 'afterEach') {\n            self.test.pending = true;\n          } else {\n            suite.tests.forEach(function (test) {\n              test.pending = true;\n            });\n            // a pending hook won't be executed twice.\n            hook.pending = true;\n          }\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next (suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function (fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n  if (this.forbidOnly && hasOnly(this.parents().reverse()[0] || this.suite)) {\n    fn(new Error('`.only` forbidden'));\n    return;\n  }\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  test.on('error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr (_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next (err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep  It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        test.isPending = alwaysFalse;\n        self.fail(test, new Error('Pending test forbidden'));\n        delete test.isPending;\n      } else {\n        self.emit('pending', test);\n      }\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function (err, errSuite) {\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          test.isPending = alwaysFalse;\n          self.fail(test, new Error('Pending test forbidden'));\n          delete test.isPending;\n        } else {\n          self.emit('pending', test);\n        }\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending && self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'));\n          } else if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\nfunction alwaysFalse () {\n  return false;\n}\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next (errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done (errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function () {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function (err) {\n  if (err) {\n    debug('uncaught exception %s', err === (function () {\n      return this;\n    }.call(err)) ? (err.message || err) : err);\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if already failed or pending\n  // See #3226\n  if (runnable.isFailed() || runnable.isPending()) {\n    return;\n  }\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  var alreadyPassed = runnable.isPassed();\n  // this will change the state to \"failed\" regardless of the current value\n  this.fail(runnable, err);\n  if (!alreadyPassed) {\n    // recover from test\n    if (runnable.type === 'test') {\n      this.emit('test end', runnable);\n      this.hookUp('afterEach', this.next);\n      return;\n    }\n\n    // recover from hooks\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences (suite) {\n  function cleanArrReferences (arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (Array.isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (Array.isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (Array.isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (Array.isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function () {};\n\n  function uncaught (err) {\n    self.uncaught(err);\n  }\n\n  function start () {\n    // If there is an `only` filter\n    if (hasOnly(rootSuite)) {\n      filterOnly(rootSuite);\n    }\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function () {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function () {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Mocha.Runner\n * @public\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter suites based on `isOnly` logic.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction filterOnly (suite) {\n  if (suite._onlyTests.length) {\n    // If the suite contains `only` tests, run those and ignore any nested suites.\n    suite.tests = suite._onlyTests;\n    suite.suites = [];\n  } else {\n    // Otherwise, do not run any of the tests in this suite.\n    suite.tests = [];\n    suite._onlySuites.forEach(function (onlySuite) {\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\n      if (hasOnly(onlySuite)) {\n        filterOnly(onlySuite);\n      }\n    });\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\n    suite.suites = suite.suites.filter(function (childSuite) {\n      return suite._onlySuites.indexOf(childSuite) !== -1 || filterOnly(childSuite);\n    });\n  }\n  // Keep the suite only if there is something to run\n  return suite.tests.length || suite.suites.length;\n}\n\n/**\n * Determines whether a suite has an `only` test or suite as a descendant.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction hasOnly (suite) {\n  return suite._onlyTests.length || suite._onlySuites.length || suite.suites.some(hasOnly);\n}\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks (ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals () {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = parts.reduce(function (a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":15,\"./runnable\":32,\"./utils\":36,\"_process\":56,\"debug\":43,\"events\":47}],34:[function(require,module,exports){\n'use strict';\n/**\n * @module Suite\n */\n\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function (parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite (title, parentContext) {\n  if (!utils.isString(title)) {\n    throw new Error('Suite `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  this.title = title;\n  function Context () {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this._onlyTests = [];\n  this._onlySuites = [];\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function () {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set or get timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set or get number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n  * Set or get timeout to `enabled`.\n  *\n  * @api private\n  * @param {boolean} enabled\n  * @return {Suite|boolean} self or enabled\n  */\nSuite.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set or get slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set or get whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Check if this suite or its parent suite is marked as pending.\n *\n * @api private\n */\nSuite.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Generic hook-creator.\n * @private\n * @param {string} title - Title of hook\n * @param {Function} fn - Hook callback\n * @returns {Hook} A new hook\n */\nSuite.prototype._createHook = function (title, fn) {\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  hook.file = this.file;\n  return hook;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function (suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function (test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by recursively concatenating the parent's\n * title path.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.titlePath = function () {\n  var result = [];\n  if (this.parent) {\n    result = result.concat(this.parent.titlePath());\n  }\n  if (!this.root) {\n    result.push(this.title);\n  }\n  return result;\n};\n\n/**\n * Return the total number of tests.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function () {\n  return this.suites.reduce(function (sum, suite) {\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function (fn) {\n  this.tests.forEach(fn);\n  this.suites.forEach(function (suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run () {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":6,\"./ms\":14,\"./utils\":36,\"debug\":43,\"events\":47}],35:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar utils = require('./utils');\nvar isString = utils.isString;\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @api private\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test (title, fn) {\n  if (!isString(title)) {\n    throw new Error('Test `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\nutils.inherits(Test, Runnable);\n\nTest.prototype.clone = function () {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],36:[function(require,module,exports){\n(function (process,Buffer){\n'use strict';\n\n/**\n * @module\n */\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('mocha:watch');\nvar fs = require('fs');\nvar glob = require('glob');\nvar path = require('path');\nvar join = path.join;\nvar he = require('he');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function (html) {\n  return he.encode(String(html), { useNamedReferences: false });\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function (obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function (files, fn) {\n  var options = { interval: 100 };\n  files.forEach(function (file) {\n    debug('file %s', file);\n    fs.watchFile(file, options, function (curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored (path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function (dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  fs.readdirSync(dir)\n    .filter(ignored)\n    .forEach(function (path) {\n      path = join(dir, path);\n      if (fs.lstatSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function (str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function (str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/^\\uFEFF/, '')\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\n    .replace(/^function(?:\\s*|\\s+[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\s*\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\s*\\}|((?:.|\\n)*))$/, '$1$2$3');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return str.trim();\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function (qs) {\n  return qs.replace('?', '').split('&').reduce(function (obj, pair) {\n    var i = pair.indexOf('=');\n    var key = pair.slice(0, i);\n    var val = pair.slice(++i);\n\n    // Due to how the URLSearchParams API treats spaces\n    obj[key] = decodeURIComponent(val.replace(/\\+/g, '%20'));\n\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight (js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>');\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function (name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} typeHint The type of the value\n * @returns {string}\n */\nfunction emptyRepresentation (value, typeHint) {\n  switch (typeHint) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string} Computed type\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * type(new String('foo') // 'object'\n */\nvar type = exports.type = function type (value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var typeHint = type(value);\n\n  if (!~['object', 'array', 'function'].indexOf(typeHint)) {\n    if (typeHint === 'buffer') {\n      var json = Buffer.prototype.toJSON.call(value);\n      // Based on the toJSON result\n      return jsonStringify(json.data && json.type ? json.data : json, 2)\n        .replace(/,(\\n|$)/g, '$1');\n    }\n\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\n    // into an array and back to obj.\n    if (typeHint === 'string' && typeof value === 'object') {\n      value = value.split('').reduce(function (acc, char, idx) {\n        acc[idx] = char;\n        return acc;\n      }, {});\n      typeHint = 'object';\n    } else {\n      return jsonStringify(value);\n    }\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, typeHint);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify (object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = Array.isArray(object) ? '[' : '{';\n  var end = Array.isArray(object) ? ']' : '}';\n  var length = typeof object.length === 'number' ? object.length : Object.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat (s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify (val) {\n    switch (type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'symbol':\n      case 'number':\n        val = val === 0 && (1 / val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val === '[Function]' || val === '[Circular]')\n          ? val\n          : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\n      continue; // not my business\n    }\n    --length;\n    str += '\\n ' + repeat(' ', space) +\n      (Array.isArray(object) ? '' : '\"' + i + '\": ') + // key\n      _stringify(object[i]) + // value\n      (length ? ',' : ''); // comma\n  }\n\n  return str +\n    // [], {}\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end);\n}\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @param {string} [typeHint] Type hint\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function canonicalize (value, stack, typeHint) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  typeHint = typeHint || type(value);\n  function withStack (value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (stack.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (typeHint) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = value.map(function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, typeHint);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function () {\n        Object.keys(value).sort().forEach(function (key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n    case 'symbol':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @memberof Mocha.utils\n * @public\n * @api public\n * @param {string} filepath Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles (filepath, extensions, recursive) {\n  var files = [];\n\n  if (!fs.existsSync(filepath)) {\n    if (fs.existsSync(filepath + '.js')) {\n      filepath += '.js';\n    } else {\n      files = glob.sync(filepath);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + filepath + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = fs.statSync(filepath);\n    if (stat.isFile()) {\n      return filepath;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  fs.readdirSync(filepath).forEach(function (file) {\n    file = path.join(filepath, file);\n    try {\n      var stat = fs.statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    var re = new RegExp('\\\\.(?:' + extensions.join('|') + ')$');\n    if (!stat.isFile() || !re.test(file) || path.basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function () {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function (err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function () {\n  // TODO: Replace with `process.browser`\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\n  var slash = path.sep;\n  var cwd;\n  if (is.node) {\n    cwd = process.cwd() + slash;\n  } else {\n    cwd = (typeof location === 'undefined'\n      ? window.location\n      : location).href.replace(/\\/[^/]*$/, '/');\n    slash = '/';\n  }\n\n  function isMochaInternal (line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash)) ||\n      (~line.indexOf('node_modules' + slash + 'mocha.js')) ||\n      (~line.indexOf('bower_components' + slash + 'mocha.js')) ||\n      (~line.indexOf(slash + 'mocha.js'));\n  }\n\n  function isNodeInternal (line) {\n    return (~line.indexOf('(timers.js:')) ||\n      (~line.indexOf('(events.js:')) ||\n      (~line.indexOf('(node.js:')) ||\n      (~line.indexOf('(module.js:')) ||\n      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||\n      false;\n  }\n\n  return function (stack) {\n    stack = stack.split('\\n');\n\n    stack = stack.reduce(function (list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      if (/\\(?.+:\\d+:\\d+\\)?$/.test(line)) {\n        line = line.replace('(' + cwd, '(');\n      }\n\n      list.push(line);\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n/**\n * Crude, but effective.\n * @api\n * @param {*} value\n * @returns {boolean} Whether or not `value` is a Promise\n */\nexports.isPromise = function isPromise (value) {\n  return typeof value === 'object' && typeof value.then === 'function';\n};\n\n/**\n * It's a noop.\n * @api\n */\nexports.noop = function () {};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":56,\"buffer\":41,\"debug\":43,\"fs\":40,\"glob\":40,\"he\":48,\"path\":40,\"util\":76}],37:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n},{}],38:[function(require,module,exports){\n\n},{}],39:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"stream\":71,\"util\":76}],40:[function(require,module,exports){\narguments[4][38][0].apply(exports,arguments)\n},{\"dup\":38}],41:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (isArrayBufferView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (isArrayBufferView(string) || isArrayBuffer(string)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\nfunction isArrayBuffer (obj) {\n  return obj instanceof ArrayBuffer ||\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\n      typeof obj.byteLength === 'number')\n}\n\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\nfunction isArrayBufferView (obj) {\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n},{\"base64-js\":37,\"ieee754\":49}],42:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../is-buffer/index.js\")})\n},{\"../../is-buffer/index.js\":51}],43:[function(require,module,exports){\n(function (process){\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n}).call(this,require('_process'))\n},{\"./debug\":44,\"_process\":56}],44:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":54}],45:[function(require,module,exports){\n/*!\n\n diff v3.5.0\n\nSoftware License Agreement (BSD License)\n\nCopyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of Kevin Decker nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\nIN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n@license\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(false)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsDiff\"] = factory();\n\telse\n\t\troot[\"JsDiff\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_merge = __webpack_require__(13) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_dmp = __webpack_require__(16) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_xml = __webpack_require__(17) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/* See LICENSE file for terms of use */\n\n\t/*\n\t * Text diff implementation.\n\t *\n\t * This library supports the following APIS:\n\t * JsDiff.diffChars: Character by character diff\n\t * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n\t * JsDiff.diffLines: Line based diff\n\t *\n\t * JsDiff.diffCss: Diff targeted at CSS content\n\t *\n\t * These methods are based on the implementation proposed in\n\t * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n\t * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n\t */\n\texports. /*istanbul ignore end*/Diff = _base2['default'];\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = _merge.merge;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports['default'] = /*istanbul ignore end*/Diff;\n\tfunction Diff() {}\n\n\tDiff.prototype = {\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {\n\t    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t    var callback = options.callback;\n\t    if (typeof options === 'function') {\n\t      callback = options;\n\t      options = {};\n\t    }\n\t    this.options = options;\n\n\t    var self = this;\n\n\t    function done(value) {\n\t      if (callback) {\n\t        setTimeout(function () {\n\t          callback(undefined, value);\n\t        }, 0);\n\t        return true;\n\t      } else {\n\t        return value;\n\t      }\n\t    }\n\n\t    // Allow subclasses to massage the input prior to running\n\t    oldString = this.castInput(oldString);\n\t    newString = this.castInput(newString);\n\n\t    oldString = this.removeEmpty(this.tokenize(oldString));\n\t    newString = this.removeEmpty(this.tokenize(newString));\n\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length;\n\t    var editLength = 1;\n\t    var maxEditLength = newLen + oldLen;\n\t    var bestPath = [{ newPos: -1, components: [] }];\n\n\t    // Seed editLength = 0, i.e. the content starts with the same values\n\t    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\t    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n\t      // Identity per the equality and tokenizer\n\t      return done([{ value: this.join(newString), count: newString.length }]);\n\t    }\n\n\t    // Main worker method. checks all permutations of a given edit length for acceptance.\n\t    function execEditLength() {\n\t      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n\t        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t        var addPath = bestPath[diagonalPath - 1],\n\t            removePath = bestPath[diagonalPath + 1],\n\t            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\t        if (addPath) {\n\t          // No one else is going to attempt to use this value, clear it\n\t          bestPath[diagonalPath - 1] = undefined;\n\t        }\n\n\t        var canAdd = addPath && addPath.newPos + 1 < newLen,\n\t            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\t        if (!canAdd && !canRemove) {\n\t          // If this path is a terminal then prune\n\t          bestPath[diagonalPath] = undefined;\n\t          continue;\n\t        }\n\n\t        // Select the diagonal that we want to branch from. We select the prior\n\t        // path whose position in the new string is the farthest from the origin\n\t        // and does not pass the bounds of the diff graph\n\t        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n\t          basePath = clonePath(removePath);\n\t          self.pushComponent(basePath.components, undefined, true);\n\t        } else {\n\t          basePath = addPath; // No need to clone, we've pulled it from the list\n\t          basePath.newPos++;\n\t          self.pushComponent(basePath.components, true, undefined);\n\t        }\n\n\t        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n\t        // If we have hit the end of both strings, then we are done\n\t        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n\t          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n\t        } else {\n\t          // Otherwise track this path as a potential candidate and continue.\n\t          bestPath[diagonalPath] = basePath;\n\t        }\n\t      }\n\n\t      editLength++;\n\t    }\n\n\t    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n\t    // sync and async mode which is never fun. Loops over execEditLength until a value\n\t    // is produced.\n\t    if (callback) {\n\t      (function exec() {\n\t        setTimeout(function () {\n\t          // This should not happen, but we want to be safe.\n\t          /* istanbul ignore next */\n\t          if (editLength > maxEditLength) {\n\t            return callback();\n\t          }\n\n\t          if (!execEditLength()) {\n\t            exec();\n\t          }\n\t        }, 0);\n\t      })();\n\t    } else {\n\t      while (editLength <= maxEditLength) {\n\t        var ret = execEditLength();\n\t        if (ret) {\n\t          return ret;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {\n\t    var last = components[components.length - 1];\n\t    if (last && last.added === added && last.removed === removed) {\n\t      // We need to clone here as the component clone operation is just\n\t      // as shallow array clone\n\t      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };\n\t    } else {\n\t      components.push({ count: 1, added: added, removed: removed });\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length,\n\t        newPos = basePath.newPos,\n\t        oldPos = newPos - diagonalPath,\n\t        commonCount = 0;\n\t    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n\t      newPos++;\n\t      oldPos++;\n\t      commonCount++;\n\t    }\n\n\t    if (commonCount) {\n\t      basePath.components.push({ count: commonCount });\n\t    }\n\n\t    basePath.newPos = newPos;\n\t    return oldPos;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {\n\t    if (this.options.comparator) {\n\t      return this.options.comparator(left, right);\n\t    } else {\n\t      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {\n\t    var ret = [];\n\t    for (var i = 0; i < array.length; i++) {\n\t      if (array[i]) {\n\t        ret.push(array[i]);\n\t      }\n\t    }\n\t    return ret;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {\n\t    return value;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {\n\t    return value.split('');\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {\n\t    return chars.join('');\n\t  }\n\t};\n\n\tfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n\t  var componentPos = 0,\n\t      componentLen = components.length,\n\t      newPos = 0,\n\t      oldPos = 0;\n\n\t  for (; componentPos < componentLen; componentPos++) {\n\t    var component = components[componentPos];\n\t    if (!component.removed) {\n\t      if (!component.added && useLongestToken) {\n\t        var value = newString.slice(newPos, newPos + component.count);\n\t        value = value.map(function (value, i) {\n\t          var oldValue = oldString[oldPos + i];\n\t          return oldValue.length > value.length ? oldValue : value;\n\t        });\n\n\t        component.value = diff.join(value);\n\t      } else {\n\t        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n\t      }\n\t      newPos += component.count;\n\n\t      // Common case\n\t      if (!component.added) {\n\t        oldPos += component.count;\n\t      }\n\t    } else {\n\t      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n\t      oldPos += component.count;\n\n\t      // Reverse add and remove so removes are output first to match common convention\n\t      // The diffing algorithm is tied to add then remove output and this is the simplest\n\t      // route to get the desired output with minimal overhead.\n\t      if (componentPos && components[componentPos - 1].added) {\n\t        var tmp = components[componentPos - 1];\n\t        components[componentPos - 1] = components[componentPos];\n\t        components[componentPos] = tmp;\n\t      }\n\t    }\n\t  }\n\n\t  // Special case handle for when one terminal is ignored (i.e. whitespace).\n\t  // For this case we merge the terminal into the prior string and drop the change.\n\t  // This is only available for string mode.\n\t  var lastComponent = components[componentLen - 1];\n\t  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n\t    components[componentLen - 2].value += lastComponent.value;\n\t    components.pop();\n\t  }\n\n\t  return components;\n\t}\n\n\tfunction clonePath(path) {\n\t  return { newPos: path.newPos, components: path.components.slice(0) };\n\t}\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.characterDiff = undefined;\n\texports. /*istanbul ignore end*/diffChars = diffChars;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tfunction diffChars(oldStr, newStr, options) {\n\t  return characterDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.wordDiff = undefined;\n\texports. /*istanbul ignore end*/diffWords = diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n\t//\n\t// Ranges and exceptions:\n\t// Latin-1 Supplement, 008000FF\n\t//  - U+00D7   Multiplication sign\n\t//  - U+00F7   Division sign\n\t// Latin Extended-A, 0100017F\n\t// Latin Extended-B, 0180024F\n\t// IPA Extensions, 025002AF\n\t// Spacing Modifier Letters, 02B002FF\n\t//  - U+02C7   &#711;  Caron\n\t//  - U+02D8   &#728;  Breve\n\t//  - U+02D9   &#729;  Dot Above\n\t//  - U+02DA   &#730;  Ring Above\n\t//  - U+02DB   &#731;  Ogonek\n\t//  - U+02DC   &#732;  Small Tilde\n\t//  - U+02DD   &#733;  Double Acute Accent\n\t// Latin Extended Additional, 1E001EFF\n\tvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n\n\tvar reWhitespace = /\\S/;\n\n\tvar wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\twordDiff.equals = function (left, right) {\n\t  if (this.options.ignoreCase) {\n\t    left = left.toLowerCase();\n\t    right = right.toLowerCase();\n\t  }\n\t  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n\t};\n\twordDiff.tokenize = function (value) {\n\t  var tokens = value.split(/(\\s+|\\b)/);\n\n\t  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\t  for (var i = 0; i < tokens.length - 1; i++) {\n\t    // If we have an empty string in the next field and we have only word chars before and after, merge\n\t    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n\t      tokens[i] += tokens[i + 2];\n\t      tokens.splice(i + 1, 2);\n\t      i--;\n\t    }\n\t  }\n\n\t  return tokens;\n\t};\n\n\tfunction diffWords(oldStr, newStr, options) {\n\t  options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\tfunction diffWordsWithSpace(oldStr, newStr, options) {\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/generateOptions = generateOptions;\n\tfunction generateOptions(options, defaults) {\n\t  if (typeof options === 'function') {\n\t    defaults.callback = options;\n\t  } else if (options) {\n\t    for (var name in options) {\n\t      /* istanbul ignore else */\n\t      if (options.hasOwnProperty(name)) {\n\t        defaults[name] = options[name];\n\t      }\n\t    }\n\t  }\n\t  return defaults;\n\t}\n\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.lineDiff = undefined;\n\texports. /*istanbul ignore end*/diffLines = diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tlineDiff.tokenize = function (value) {\n\t  var retLines = [],\n\t      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n\t  // Ignore the final empty token that occurs if the string ends with a new line\n\t  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n\t    linesAndNewlines.pop();\n\t  }\n\n\t  // Merge the content and line separators into single tokens\n\t  for (var i = 0; i < linesAndNewlines.length; i++) {\n\t    var line = linesAndNewlines[i];\n\n\t    if (i % 2 && !this.options.newlineIsToken) {\n\t      retLines[retLines.length - 1] += line;\n\t    } else {\n\t      if (this.options.ignoreWhitespace) {\n\t        line = line.trim();\n\t      }\n\t      retLines.push(line);\n\t    }\n\t  }\n\n\t  return retLines;\n\t};\n\n\tfunction diffLines(oldStr, newStr, callback) {\n\t  return lineDiff.diff(oldStr, newStr, callback);\n\t}\n\tfunction diffTrimmedLines(oldStr, newStr, callback) {\n\t  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n\t  return lineDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.sentenceDiff = undefined;\n\texports. /*istanbul ignore end*/diffSentences = diffSentences;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tsentenceDiff.tokenize = function (value) {\n\t  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n\t};\n\n\tfunction diffSentences(oldStr, newStr, callback) {\n\t  return sentenceDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.cssDiff = undefined;\n\texports. /*istanbul ignore end*/diffCss = diffCss;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tcssDiff.tokenize = function (value) {\n\t  return value.split(/([{}:;,]|\\s+)/);\n\t};\n\n\tfunction diffCss(oldStr, newStr, callback) {\n\t  return cssDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.jsonDiff = undefined;\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\texports. /*istanbul ignore end*/diffJson = diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;\n\n\tvar jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\t// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n\t// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\tjsonDiff.useLongestToken = true;\n\n\tjsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff /*istanbul ignore end*/.tokenize;\n\tjsonDiff.castInput = function (value) {\n\t  /*istanbul ignore start*/var _options = /*istanbul ignore end*/this.options,\n\t      undefinedReplacement = _options.undefinedReplacement,\n\t      _options$stringifyRep = _options.stringifyReplacer,\n\t      stringifyReplacer = _options$stringifyRep === undefined ? function (k, v) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v\n\t    );\n\t  } : _options$stringifyRep;\n\n\n\t  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n\t};\n\tjsonDiff.equals = function (left, right) {\n\t  return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n\t  );\n\t};\n\n\tfunction diffJson(oldObj, newObj, options) {\n\t  return jsonDiff.diff(oldObj, newObj, options);\n\t}\n\n\t// This function handles the presence of circular references by bailing out when encountering an\n\t// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\tfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n\t  stack = stack || [];\n\t  replacementStack = replacementStack || [];\n\n\t  if (replacer) {\n\t    obj = replacer(key, obj);\n\t  }\n\n\t  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  for (i = 0; i < stack.length; i += 1) {\n\t    if (stack[i] === obj) {\n\t      return replacementStack[i];\n\t    }\n\t  }\n\n\t  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n\t    stack.push(obj);\n\t    canonicalizedObj = new Array(obj.length);\n\t    replacementStack.push(canonicalizedObj);\n\t    for (i = 0; i < obj.length; i += 1) {\n\t      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t    return canonicalizedObj;\n\t  }\n\n\t  if (obj && obj.toJSON) {\n\t    obj = obj.toJSON();\n\t  }\n\n\t  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {\n\t    stack.push(obj);\n\t    canonicalizedObj = {};\n\t    replacementStack.push(canonicalizedObj);\n\t    var sortedKeys = [],\n\t        _key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t    for (_key in obj) {\n\t      /* istanbul ignore else */\n\t      if (obj.hasOwnProperty(_key)) {\n\t        sortedKeys.push(_key);\n\t      }\n\t    }\n\t    sortedKeys.sort();\n\t    for (i = 0; i < sortedKeys.length; i += 1) {\n\t      _key = sortedKeys[i];\n\t      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t  } else {\n\t    canonicalizedObj = obj;\n\t  }\n\t  return canonicalizedObj;\n\t}\n\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.arrayDiff = undefined;\n\texports. /*istanbul ignore end*/diffArrays = diffArrays;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tarrayDiff.tokenize = function (value) {\n\t  return value.slice();\n\t};\n\tarrayDiff.join = arrayDiff.removeEmpty = function (value) {\n\t  return value;\n\t};\n\n\tfunction diffArrays(oldArr, newArr, callback) {\n\t  return arrayDiff.diff(oldArr, newArr, callback);\n\t}\n\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/applyPatch = applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(_distanceIterator);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/function applyPatch(source, uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  if (Array.isArray(uniDiff)) {\n\t    if (uniDiff.length > 1) {\n\t      throw new Error('applyPatch only works with a single input.');\n\t    }\n\n\t    uniDiff = uniDiff[0];\n\t  }\n\n\t  // Apply the diff to the input\n\t  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      hunks = uniDiff.hunks,\n\t      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/line === patchContent\n\t    );\n\t  },\n\t      errorCount = 0,\n\t      fuzzFactor = options.fuzzFactor || 0,\n\t      minLine = 0,\n\t      offset = 0,\n\t      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  /**\n\t   * Checks if the hunk exactly fits on the provided location\n\t   */\n\t  function hunkFits(hunk, toPos) {\n\t    for (var j = 0; j < hunk.lines.length; j++) {\n\t      var line = hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line;\n\n\t      if (operation === ' ' || operation === '-') {\n\t        // Context sanity check\n\t        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n\t          errorCount++;\n\n\t          if (errorCount > fuzzFactor) {\n\t            return false;\n\t          }\n\t        }\n\t        toPos++;\n\t      }\n\t    }\n\n\t    return true;\n\t  }\n\n\t  // Search best fit offsets for each hunk based on the previous ones\n\t  for (var i = 0; i < hunks.length; i++) {\n\t    var hunk = hunks[i],\n\t        maxLine = lines.length - hunk.oldLines,\n\t        localOffset = 0,\n\t        toPos = offset + hunk.oldStart - 1;\n\n\t    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);\n\n\t    for (; localOffset !== undefined; localOffset = iterator()) {\n\t      if (hunkFits(hunk, toPos + localOffset)) {\n\t        hunk.offset = offset += localOffset;\n\t        break;\n\t      }\n\t    }\n\n\t    if (localOffset === undefined) {\n\t      return false;\n\t    }\n\n\t    // Set lower text limit to end of the current hunk, so next ones don't try\n\t    // to fit over already patched text\n\t    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n\t  }\n\n\t  // Apply patch hunks\n\t  var diffOffset = 0;\n\t  for (var _i = 0; _i < hunks.length; _i++) {\n\t    var _hunk = hunks[_i],\n\t        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\t    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n\t    if (_toPos < 0) {\n\t      // Creating a new file\n\t      _toPos = 0;\n\t    }\n\n\t    for (var j = 0; j < _hunk.lines.length; j++) {\n\t      var line = _hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line,\n\t          delimiter = _hunk.linedelimiters[j];\n\n\t      if (operation === ' ') {\n\t        _toPos++;\n\t      } else if (operation === '-') {\n\t        lines.splice(_toPos, 1);\n\t        delimiters.splice(_toPos, 1);\n\t        /* istanbul ignore else */\n\t      } else if (operation === '+') {\n\t        lines.splice(_toPos, 0, content);\n\t        delimiters.splice(_toPos, 0, delimiter);\n\t        _toPos++;\n\t      } else if (operation === '\\\\') {\n\t        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\t        if (previousOperation === '+') {\n\t          removeEOFNL = true;\n\t        } else if (previousOperation === '-') {\n\t          addEOFNL = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Handle EOFNL insertion/removal\n\t  if (removeEOFNL) {\n\t    while (!lines[lines.length - 1]) {\n\t      lines.pop();\n\t      delimiters.pop();\n\t    }\n\t  } else if (addEOFNL) {\n\t    lines.push('');\n\t    delimiters.push('\\n');\n\t  }\n\t  for (var _k = 0; _k < lines.length - 1; _k++) {\n\t    lines[_k] = lines[_k] + delimiters[_k];\n\t  }\n\t  return lines.join('');\n\t}\n\n\t// Wrapper that supports multiple file patches via callbacks.\n\tfunction applyPatches(uniDiff, options) {\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  var currentIndex = 0;\n\t  function processIndex() {\n\t    var index = uniDiff[currentIndex++];\n\t    if (!index) {\n\t      return options.complete();\n\t    }\n\n\t    options.loadFile(index, function (err, data) {\n\t      if (err) {\n\t        return options.complete(err);\n\t      }\n\n\t      var updatedContent = applyPatch(data, index, options);\n\t      options.patched(index, updatedContent, function (err) {\n\t        if (err) {\n\t          return options.complete(err);\n\t        }\n\n\t        processIndex();\n\t      });\n\t    });\n\t  }\n\t  processIndex();\n\t}\n\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/parsePatch = parsePatch;\n\tfunction parsePatch(uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      list = [],\n\t      i = 0;\n\n\t  function parseIndex() {\n\t    var index = {};\n\t    list.push(index);\n\n\t    // Parse diff metadata\n\t    while (i < diffstr.length) {\n\t      var line = diffstr[i];\n\n\t      // File header found, end parsing diff metadata\n\t      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n\t        break;\n\t      }\n\n\t      // Diff index\n\t      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\t      if (header) {\n\t        index.index = header[1];\n\t      }\n\n\t      i++;\n\t    }\n\n\t    // Parse file headers if they are defined. Unified diff requires them, but\n\t    // there's no technical issues to have an isolated hunk without file header\n\t    parseFileHeader(index);\n\t    parseFileHeader(index);\n\n\t    // Parse hunks\n\t    index.hunks = [];\n\n\t    while (i < diffstr.length) {\n\t      var _line = diffstr[i];\n\n\t      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n\t        break;\n\t      } else if (/^@@/.test(_line)) {\n\t        index.hunks.push(parseHunk());\n\t      } else if (_line && options.strict) {\n\t        // Ignore unexpected content unless in strict mode\n\t        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t  }\n\n\t  // Parses the --- and +++ headers, if none are found, no lines\n\t  // are consumed.\n\t  function parseFileHeader(index) {\n\t    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\t    if (fileHeader) {\n\t      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n\t      var data = fileHeader[2].split('\\t', 2);\n\t      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\t      if (/^\".*\"$/.test(fileName)) {\n\t        fileName = fileName.substr(1, fileName.length - 2);\n\t      }\n\t      index[keyPrefix + 'FileName'] = fileName;\n\t      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n\t      i++;\n\t    }\n\t  }\n\n\t  // Parses a hunk\n\t  // This assumes that we are at the start of a hunk.\n\t  function parseHunk() {\n\t    var chunkHeaderIndex = i,\n\t        chunkHeaderLine = diffstr[i++],\n\t        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n\t    var hunk = {\n\t      oldStart: +chunkHeader[1],\n\t      oldLines: +chunkHeader[2] || 1,\n\t      newStart: +chunkHeader[3],\n\t      newLines: +chunkHeader[4] || 1,\n\t      lines: [],\n\t      linedelimiters: []\n\t    };\n\n\t    var addCount = 0,\n\t        removeCount = 0;\n\t    for (; i < diffstr.length; i++) {\n\t      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n\t      // But they could be the header for the next file. Therefore prune such cases out.\n\t      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n\t        break;\n\t      }\n\t      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n\t      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n\t        hunk.lines.push(diffstr[i]);\n\t        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n\t        if (operation === '+') {\n\t          addCount++;\n\t        } else if (operation === '-') {\n\t          removeCount++;\n\t        } else if (operation === ' ') {\n\t          addCount++;\n\t          removeCount++;\n\t        }\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\n\t    // Handle the empty block count case\n\t    if (!addCount && hunk.newLines === 1) {\n\t      hunk.newLines = 0;\n\t    }\n\t    if (!removeCount && hunk.oldLines === 1) {\n\t      hunk.oldLines = 0;\n\t    }\n\n\t    // Perform optional sanity checking\n\t    if (options.strict) {\n\t      if (addCount !== hunk.newLines) {\n\t        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t      if (removeCount !== hunk.oldLines) {\n\t        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t    }\n\n\t    return hunk;\n\t  }\n\n\t  while (i < diffstr.length) {\n\t    parseIndex();\n\t  }\n\n\t  return list;\n\t}\n\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\n\texports[\"default\"] = /*istanbul ignore end*/function (start, minLine, maxLine) {\n\t  var wantForward = true,\n\t      backwardExhausted = false,\n\t      forwardExhausted = false,\n\t      localOffset = 1;\n\n\t  return function iterator() {\n\t    if (wantForward && !forwardExhausted) {\n\t      if (backwardExhausted) {\n\t        localOffset++;\n\t      } else {\n\t        wantForward = false;\n\t      }\n\n\t      // Check if trying to fit beyond text length, and if not, check it fits\n\t      // after offset location (or desired location on first iteration)\n\t      if (start + localOffset <= maxLine) {\n\t        return localOffset;\n\t      }\n\n\t      forwardExhausted = true;\n\t    }\n\n\t    if (!backwardExhausted) {\n\t      if (!forwardExhausted) {\n\t        wantForward = true;\n\t      }\n\n\t      // Check if trying to fit before text beginning, and if not, check it fits\n\t      // before offset location\n\t      if (minLine <= start - localOffset) {\n\t        return -localOffset++;\n\t      }\n\n\t      backwardExhausted = true;\n\t      return iterator();\n\t    }\n\n\t    // We tried to fit hunk before text beginning and beyond text length, then\n\t    // hunk can't fit on the text. Return undefined\n\t  };\n\t};\n\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/calcLineCount = calcLineCount;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(15) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function calcLineCount(hunk) {\n\t  /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),\n\t      oldLines = _calcOldNewLineCount.oldLines,\n\t      newLines = _calcOldNewLineCount.newLines;\n\n\t  if (oldLines !== undefined) {\n\t    hunk.oldLines = oldLines;\n\t  } else {\n\t    delete hunk.oldLines;\n\t  }\n\n\t  if (newLines !== undefined) {\n\t    hunk.newLines = newLines;\n\t  } else {\n\t    delete hunk.newLines;\n\t  }\n\t}\n\n\tfunction merge(mine, theirs, base) {\n\t  mine = loadPatch(mine, base);\n\t  theirs = loadPatch(theirs, base);\n\n\t  var ret = {};\n\n\t  // For index we just let it pass through as it doesn't have any necessary meaning.\n\t  // Leaving sanity checks on this to the API consumer that may know more about the\n\t  // meaning in their own context.\n\t  if (mine.index || theirs.index) {\n\t    ret.index = mine.index || theirs.index;\n\t  }\n\n\t  if (mine.newFileName || theirs.newFileName) {\n\t    if (!fileNameChanged(mine)) {\n\t      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n\t      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n\t      ret.newFileName = theirs.newFileName || mine.newFileName;\n\t      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n\t      ret.newHeader = theirs.newHeader || mine.newHeader;\n\t    } else if (!fileNameChanged(theirs)) {\n\t      // No header or no change in theirs, use ours\n\t      ret.oldFileName = mine.oldFileName;\n\t      ret.newFileName = mine.newFileName;\n\t      ret.oldHeader = mine.oldHeader;\n\t      ret.newHeader = mine.newHeader;\n\t    } else {\n\t      // Both changed... figure it out\n\t      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n\t      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n\t      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n\t      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n\t    }\n\t  }\n\n\t  ret.hunks = [];\n\n\t  var mineIndex = 0,\n\t      theirsIndex = 0,\n\t      mineOffset = 0,\n\t      theirsOffset = 0;\n\n\t  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n\t    var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },\n\t        theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };\n\n\t    if (hunkBefore(mineCurrent, theirsCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n\t      mineIndex++;\n\t      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n\t    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n\t      theirsIndex++;\n\t      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n\t    } else {\n\t      // Overlap, merge as best we can\n\t      var mergedHunk = {\n\t        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n\t        oldLines: 0,\n\t        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n\t        newLines: 0,\n\t        lines: []\n\t      };\n\t      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n\t      theirsIndex++;\n\t      mineIndex++;\n\n\t      ret.hunks.push(mergedHunk);\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\n\tfunction loadPatch(param, base) {\n\t  if (typeof param === 'string') {\n\t    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n\t      return (/*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(param)[0]\n\t      );\n\t    }\n\n\t    if (!base) {\n\t      throw new Error('Must provide a base reference or pass in a patch');\n\t    }\n\t    return (/*istanbul ignore start*/(0, _create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)\n\t    );\n\t  }\n\n\t  return param;\n\t}\n\n\tfunction fileNameChanged(patch) {\n\t  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n\t}\n\n\tfunction selectField(index, mine, theirs) {\n\t  if (mine === theirs) {\n\t    return mine;\n\t  } else {\n\t    index.conflict = true;\n\t    return { mine: mine, theirs: theirs };\n\t  }\n\t}\n\n\tfunction hunkBefore(test, check) {\n\t  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n\t}\n\n\tfunction cloneHunk(hunk, offset) {\n\t  return {\n\t    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n\t    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n\t    lines: hunk.lines\n\t  };\n\t}\n\n\tfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n\t  // This will generally result in a conflicted hunk, but there are cases where the context\n\t  // is the only overlap where we can successfully merge the content here.\n\t  var mine = { offset: mineOffset, lines: mineLines, index: 0 },\n\t      their = { offset: theirOffset, lines: theirLines, index: 0 };\n\n\t  // Handle any leading content\n\t  insertLeading(hunk, mine, their);\n\t  insertLeading(hunk, their, mine);\n\n\t  // Now in the overlap content. Scan through and select the best changes from each.\n\t  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n\t    var mineCurrent = mine.lines[mine.index],\n\t        theirCurrent = their.lines[their.index];\n\n\t    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n\t      // Both modified ...\n\t      mutualChange(hunk, mine, their);\n\t    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines;\n\n\t      /*istanbul ignore end*/ // Mine inserted\n\t      /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));\n\t    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines2;\n\n\t      /*istanbul ignore end*/ // Theirs inserted\n\t      /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));\n\t    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n\t      // Mine removed or edited\n\t      removal(hunk, mine, their);\n\t    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n\t      // Their removed or edited\n\t      removal(hunk, their, mine, true);\n\t    } else if (mineCurrent === theirCurrent) {\n\t      // Context identity\n\t      hunk.lines.push(mineCurrent);\n\t      mine.index++;\n\t      their.index++;\n\t    } else {\n\t      // Context mismatch\n\t      conflict(hunk, collectChange(mine), collectChange(their));\n\t    }\n\t  }\n\n\t  // Now push anything that may be remaining\n\t  insertTrailing(hunk, mine);\n\t  insertTrailing(hunk, their);\n\n\t  calcLineCount(hunk);\n\t}\n\n\tfunction mutualChange(hunk, mine, their) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectChange(their);\n\n\t  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n\t    // Special case for remove changes that are supersets of one another\n\t    if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines3;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t      return;\n\t    } else if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines4;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));\n\t      return;\n\t    }\n\t  } else if ( /*istanbul ignore start*/(0, _array.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {\n\t    /*istanbul ignore start*/var _hunk$lines5;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t    return;\n\t  }\n\n\t  conflict(hunk, myChanges, theirChanges);\n\t}\n\n\tfunction removal(hunk, mine, their, swap) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectContext(their, myChanges);\n\t  if (theirChanges.merged) {\n\t    /*istanbul ignore start*/var _hunk$lines6;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));\n\t  } else {\n\t    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n\t  }\n\t}\n\n\tfunction conflict(hunk, mine, their) {\n\t  hunk.conflict = true;\n\t  hunk.lines.push({\n\t    conflict: true,\n\t    mine: mine,\n\t    theirs: their\n\t  });\n\t}\n\n\tfunction insertLeading(hunk, insert, their) {\n\t  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t    insert.offset++;\n\t  }\n\t}\n\tfunction insertTrailing(hunk, insert) {\n\t  while (insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t  }\n\t}\n\n\tfunction collectChange(state) {\n\t  var ret = [],\n\t      operation = state.lines[state.index][0];\n\t  while (state.index < state.lines.length) {\n\t    var line = state.lines[state.index];\n\n\t    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\t    if (operation === '-' && line[0] === '+') {\n\t      operation = '+';\n\t    }\n\n\t    if (operation === line[0]) {\n\t      ret.push(line);\n\t      state.index++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\tfunction collectContext(state, matchChanges) {\n\t  var changes = [],\n\t      merged = [],\n\t      matchIndex = 0,\n\t      contextChanges = false,\n\t      conflicted = false;\n\t  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n\t    var change = state.lines[state.index],\n\t        match = matchChanges[matchIndex];\n\n\t    // Once we've hit our add, then we are done\n\t    if (match[0] === '+') {\n\t      break;\n\t    }\n\n\t    contextChanges = contextChanges || change[0] !== ' ';\n\n\t    merged.push(match);\n\t    matchIndex++;\n\n\t    // Consume any additions in the other block as a conflict to attempt\n\t    // to pull in the remaining context after this\n\t    if (change[0] === '+') {\n\t      conflicted = true;\n\n\t      while (change[0] === '+') {\n\t        changes.push(change);\n\t        change = state.lines[++state.index];\n\t      }\n\t    }\n\n\t    if (match.substr(1) === change.substr(1)) {\n\t      changes.push(change);\n\t      state.index++;\n\t    } else {\n\t      conflicted = true;\n\t    }\n\t  }\n\n\t  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n\t    conflicted = true;\n\t  }\n\n\t  if (conflicted) {\n\t    return changes;\n\t  }\n\n\t  while (matchIndex < matchChanges.length) {\n\t    merged.push(matchChanges[matchIndex++]);\n\t  }\n\n\t  return {\n\t    merged: merged,\n\t    changes: changes\n\t  };\n\t}\n\n\tfunction allRemoves(changes) {\n\t  return changes.reduce(function (prev, change) {\n\t    return prev && change[0] === '-';\n\t  }, true);\n\t}\n\tfunction skipRemoveSuperset(state, removeChanges, delta) {\n\t  for (var i = 0; i < delta; i++) {\n\t    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\t    if (state.lines[state.index + i] !== ' ' + changeContent) {\n\t      return false;\n\t    }\n\t  }\n\n\t  state.index += delta;\n\t  return true;\n\t}\n\n\tfunction calcOldNewLineCount(lines) {\n\t  var oldLines = 0;\n\t  var newLines = 0;\n\n\t  lines.forEach(function (line) {\n\t    if (typeof line !== 'string') {\n\t      var myCount = calcOldNewLineCount(line.mine);\n\t      var theirCount = calcOldNewLineCount(line.theirs);\n\n\t      if (oldLines !== undefined) {\n\t        if (myCount.oldLines === theirCount.oldLines) {\n\t          oldLines += myCount.oldLines;\n\t        } else {\n\t          oldLines = undefined;\n\t        }\n\t      }\n\n\t      if (newLines !== undefined) {\n\t        if (myCount.newLines === theirCount.newLines) {\n\t          newLines += myCount.newLines;\n\t        } else {\n\t          newLines = undefined;\n\t        }\n\t      }\n\t    } else {\n\t      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n\t        newLines++;\n\t      }\n\t      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n\t        oldLines++;\n\t      }\n\t    }\n\t  });\n\n\t  return { oldLines: oldLines, newLines: newLines };\n\t}\n\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/structuredPatch = structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t  if (typeof options.context === 'undefined') {\n\t    options.context = 4;\n\t  }\n\n\t  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);\n\t  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n\n\t  function contextLines(lines) {\n\t    return lines.map(function (entry) {\n\t      return ' ' + entry;\n\t    });\n\t  }\n\n\t  var hunks = [];\n\t  var oldRangeStart = 0,\n\t      newRangeStart = 0,\n\t      curRange = [],\n\t      oldLine = 1,\n\t      newLine = 1;\n\n\t  /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {\n\t    var current = diff[i],\n\t        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n\t    current.lines = lines;\n\n\t    if (current.added || current.removed) {\n\t      /*istanbul ignore start*/var _curRange;\n\n\t      /*istanbul ignore end*/ // If we have previous context, start with that\n\t      if (!oldRangeStart) {\n\t        var prev = diff[i - 1];\n\t        oldRangeStart = oldLine;\n\t        newRangeStart = newLine;\n\n\t        if (prev) {\n\t          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n\t          oldRangeStart -= curRange.length;\n\t          newRangeStart -= curRange.length;\n\t        }\n\t      }\n\n\t      // Output our changes\n\t      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {\n\t        return (current.added ? '+' : '-') + entry;\n\t      })));\n\n\t      // Track the updated file position\n\t      if (current.added) {\n\t        newLine += lines.length;\n\t      } else {\n\t        oldLine += lines.length;\n\t      }\n\t    } else {\n\t      // Identical context lines. Track line changes\n\t      if (oldRangeStart) {\n\t        // Close out any changes that have been output (or join overlapping)\n\t        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n\t          /*istanbul ignore start*/var _curRange2;\n\n\t          /*istanbul ignore end*/ // Overlapping\n\t          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));\n\t        } else {\n\t          /*istanbul ignore start*/var _curRange3;\n\n\t          /*istanbul ignore end*/ // end the range and output\n\t          var contextSize = Math.min(lines.length, options.context);\n\t          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));\n\n\t          var hunk = {\n\t            oldStart: oldRangeStart,\n\t            oldLines: oldLine - oldRangeStart + contextSize,\n\t            newStart: newRangeStart,\n\t            newLines: newLine - newRangeStart + contextSize,\n\t            lines: curRange\n\t          };\n\t          if (i >= diff.length - 2 && lines.length <= options.context) {\n\t            // EOF is inside this hunk\n\t            var oldEOFNewline = /\\n$/.test(oldStr);\n\t            var newEOFNewline = /\\n$/.test(newStr);\n\t            if (lines.length == 0 && !oldEOFNewline) {\n\t              // special case: old has no eol and no trailing context; no-nl can end up before adds\n\t              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n\t            } else if (!oldEOFNewline || !newEOFNewline) {\n\t              curRange.push('\\\\ No newline at end of file');\n\t            }\n\t          }\n\t          hunks.push(hunk);\n\n\t          oldRangeStart = 0;\n\t          newRangeStart = 0;\n\t          curRange = [];\n\t        }\n\t      }\n\t      oldLine += lines.length;\n\t      newLine += lines.length;\n\t    }\n\t  };\n\n\t  for (var i = 0; i < diff.length; i++) {\n\t    /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);\n\t  }\n\n\t  return {\n\t    oldFileName: oldFileName, newFileName: newFileName,\n\t    oldHeader: oldHeader, newHeader: newHeader,\n\t    hunks: hunks\n\t  };\n\t}\n\n\tfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n\n\t  var ret = [];\n\t  if (oldFileName == newFileName) {\n\t    ret.push('Index: ' + oldFileName);\n\t  }\n\t  ret.push('===================================================================');\n\t  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n\t  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n\t  for (var i = 0; i < diff.hunks.length; i++) {\n\t    var hunk = diff.hunks[i];\n\t    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n\t    ret.push.apply(ret, hunk.lines);\n\t  }\n\n\t  return ret.join('\\n') + '\\n';\n\t}\n\n\tfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n\t}\n\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/arrayEqual = arrayEqual;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;\n\tfunction arrayEqual(a, b) {\n\t  if (a.length !== b.length) {\n\t    return false;\n\t  }\n\n\t  return arrayStartsWith(a, b);\n\t}\n\n\tfunction arrayStartsWith(array, start) {\n\t  if (start.length > array.length) {\n\t    return false;\n\t  }\n\n\t  for (var i = 0; i < start.length; i++) {\n\t    if (start[i] !== array[i]) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;\n\t// See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\tfunction convertChangesToDMP(changes) {\n\t  var ret = [],\n\t      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t  for (var i = 0; i < changes.length; i++) {\n\t    change = changes[i];\n\t    if (change.added) {\n\t      operation = 1;\n\t    } else if (change.removed) {\n\t      operation = -1;\n\t    } else {\n\t      operation = 0;\n\t    }\n\n\t    ret.push([operation, change.value]);\n\t  }\n\t  return ret;\n\t}\n\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;\n\tfunction convertChangesToXML(changes) {\n\t  var ret = [];\n\t  for (var i = 0; i < changes.length; i++) {\n\t    var change = changes[i];\n\t    if (change.added) {\n\t      ret.push('<ins>');\n\t    } else if (change.removed) {\n\t      ret.push('<del>');\n\t    }\n\n\t    ret.push(escapeHTML(change.value));\n\n\t    if (change.added) {\n\t      ret.push('</ins>');\n\t    } else if (change.removed) {\n\t      ret.push('</del>');\n\t    }\n\t  }\n\t  return ret.join('');\n\t}\n\n\tfunction escapeHTML(s) {\n\t  var n = s;\n\t  n = n.replace(/&/g, '&amp;');\n\t  n = n.replace(/</g, '&lt;');\n\t  n = n.replace(/>/g, '&gt;');\n\t  n = n.replace(/\"/g, '&quot;');\n\n\t  return n;\n\t}\n\n\n\n/***/ })\n/******/ ])\n});\n;\n},{}],46:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n},{}],47:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],48:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/he v1.1.1 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// All astral symbols.\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\n\t// first column of the overrides table.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\n\t// code points listed in the first column of the overrides table on\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\n\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\n\n\tvar regexEscape = /[\"&'<>`]/g;\n\tvar escapeMap = {\n\t\t'\"': '&quot;',\n\t\t'&': '&amp;',\n\t\t'\\'': '&#x27;',\n\t\t'<': '&lt;',\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\n\t\t// following is not strictly necessary unless its part of a tag or an\n\t\t// unquoted attribute value. Were only escaping it to support those\n\t\t// situations, and for XML support.\n\t\t'>': '&gt;',\n\t\t// In Internet Explorer  8, the backtick character can be used\n\t\t// to break out of (un)quoted attribute values or HTML comments.\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\n\t\t// http://html5sec.org/#133.\n\t\t'`': '&#x60;'\n\t};\n\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\tvar regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar has = function(object, propertyName) {\n\t\treturn hasOwnProperty.call(object, propertyName);\n\t};\n\n\tvar contains = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar result = {};\n\t\tvar key;\n\t\tfor (key in defaults) {\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\n\t\t\t// option names are used anyway. Any others are ignored.\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\n\tvar codePointToSymbol = function(codePoint, strict) {\n\t\tvar output = '';\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\n\t\t\t// See issue #4:\n\t\t\t// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\n\t\t\t// REPLACEMENT CHARACTER.\n\t\t\tif (strict) {\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\n\t\t\t}\n\t\t\treturn '\\uFFFD';\n\t\t}\n\t\tif (has(decodeMapNumeric, codePoint)) {\n\t\t\tif (strict) {\n\t\t\t\tparseError('disallowed character reference');\n\t\t\t}\n\t\t\treturn decodeMapNumeric[codePoint];\n\t\t}\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\n\t\t\tparseError('disallowed character reference');\n\t\t}\n\t\tif (codePoint > 0xFFFF) {\n\t\t\tcodePoint -= 0x10000;\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(codePoint);\n\t\treturn output;\n\t};\n\n\tvar hexEscape = function(codePoint) {\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\n\t};\n\n\tvar decEscape = function(codePoint) {\n\t\treturn '&#' + codePoint + ';';\n\t};\n\n\tvar parseError = function(message) {\n\t\tthrow Error('Parse error: ' + message);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar encode = function(string, options) {\n\t\toptions = merge(options, encode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\n\t\t\tparseError('forbidden code point');\n\t\t}\n\t\tvar encodeEverything = options.encodeEverything;\n\t\tvar useNamedReferences = options.useNamedReferences;\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\n\n\t\tvar escapeBmpSymbol = function(symbol) {\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\n\t\t};\n\n\t\tif (encodeEverything) {\n\t\t\t// Encode ASCII symbols.\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\n\t\t\t\t// Use named references if requested & possible.\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\n\t\t\t\t}\n\t\t\t\treturn escapeBmpSymbol(symbol);\n\t\t\t});\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\n\t\t\t// is within the ASCII range.\n\t\t\tif (useNamedReferences) {\n\t\t\t\tstring = string\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\n\t\t\t}\n\t\t\t// Encode non-ASCII symbols.\n\t\t\tif (useNamedReferences) {\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\n\t\t} else if (useNamedReferences) {\n\t\t\t// Apply named character references.\n\t\t\t// Encode `<>\"'&` using named character references.\n\t\t\tif (!allowUnsafeSymbols) {\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\n\t\t\t// `<>\"'&`.\n\t\t\tstring = string\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t});\n\t\t} else if (!allowUnsafeSymbols) {\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that theyre not handled\n\t\t\t// using named character references.\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\n\t\t}\n\t\treturn string\n\t\t\t// Encode astral symbols.\n\t\t\t.replace(regexAstralSymbols, function($0) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tvar high = $0.charCodeAt(0);\n\t\t\t\tvar low = $0.charCodeAt(1);\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\t\t\t\treturn escapeCodePoint(codePoint);\n\t\t\t})\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\n\t\t\t// using a hexadecimal escape.\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tencode.options = {\n\t\t'allowUnsafeSymbols': false,\n\t\t'encodeEverything': false,\n\t\t'strict': false,\n\t\t'useNamedReferences': false,\n\t\t'decimal' : false\n\t};\n\n\tvar decode = function(html, options) {\n\t\toptions = merge(options, decode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidEntity.test(html)) {\n\t\t\tparseError('malformed character reference');\n\t\t}\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {\n\t\t\tvar codePoint;\n\t\t\tvar semicolon;\n\t\t\tvar decDigits;\n\t\t\tvar hexDigits;\n\t\t\tvar reference;\n\t\t\tvar next;\n\t\t\tif ($1) {\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\n\t\t\t\tdecDigits = $1;\n\t\t\t\tsemicolon = $2;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($3) {\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\n\t\t\t\thexDigits = $3;\n\t\t\t\tsemicolon = $4;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($5) {\n\t\t\t\t// Decode named character references with trailing `;`, e.g. `&copy;`.\n\t\t\t\treference = $5;\n\t\t\t\tif (has(decodeMap, reference)) {\n\t\t\t\t\treturn decodeMap[reference];\n\t\t\t\t} else {\n\t\t\t\t\t// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands\n\t\t\t\t\tif (strict) {\n\t\t\t\t\t\tparseError(\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If were still here, its a legacy reference for sure. No need for an\n\t\t\t// extra `if` check.\n\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`\n\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\n\t\t\t// followed by `=` in an attribute context.\n\t\t\treference = $6;\n\t\t\tnext = $7;\n\t\t\tif (next && options.isAttributeValue) {\n\t\t\t\tif (strict && next == '=') {\n\t\t\t\t\tparseError('`&` did not start a character reference');\n\t\t\t\t}\n\t\t\t\treturn $0;\n\t\t\t} else {\n\t\t\t\tif (strict) {\n\t\t\t\t\tparseError(\n\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\n\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\n\t\t\t}\n\t\t});\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tdecode.options = {\n\t\t'isAttributeValue': false,\n\t\t'strict': false\n\t};\n\n\tvar escape = function(string) {\n\t\treturn string.replace(regexEscape, function($0) {\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\n\t\t\treturn escapeMap[$0];\n\t\t});\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar he = {\n\t\t'version': '1.1.1',\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'escape': escape,\n\t\t'unescape': decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\tfalse\n\t) {\n\t\tdefine(function() {\n\t\t\treturn he;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = he;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in he) {\n\t\t\t\thas(he, key) && (freeExports[key] = he[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.he = he;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],49:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],50:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],51:[function(require,module,exports){\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n},{}],52:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],53:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"fs\":40,\"path\":40}],54:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],55:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n}).call(this,require('_process'))\n},{\"_process\":56}],56:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],57:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_duplex.js');\n\n},{\"./lib/_stream_duplex.js\":58}],58:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  processNextTick(cb, err);\n};\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n},{\"./_stream_readable\":60,\"./_stream_writable\":62,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55}],59:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":61,\"core-util-is\":42,\"inherits\":50}],60:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n// TODO(bmeurer): Change this back to const once hole checks are\n// properly optimized away early in Ignition+TurboFan.\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/BufferList\":63,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"events\":47,\"inherits\":50,\"isarray\":52,\"process-nextick-args\":55,\"safe-buffer\":70,\"string_decoder/\":72,\"util\":38}],61:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return stream.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n},{\"./_stream_duplex\":58,\"core-util-is\":42,\"inherits\":50}],62:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = _isUint8Array(chunk) && !state.objectMode;\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    processNextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    processNextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      processNextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55,\"safe-buffer\":70,\"util-deprecate\":73}],63:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n},{\"safe-buffer\":70}],64:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      processNextTick(emitErrorNT, this, err);\n    }\n    return;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      processNextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n},{\"process-nextick-args\":55}],65:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":47}],66:[function(require,module,exports){\nmodule.exports = require('./readable').PassThrough\n\n},{\"./readable\":67}],67:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":58,\"./lib/_stream_passthrough.js\":59,\"./lib/_stream_readable.js\":60,\"./lib/_stream_transform.js\":61,\"./lib/_stream_writable.js\":62}],68:[function(require,module,exports){\nmodule.exports = require('./readable').Transform\n\n},{\"./readable\":67}],69:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_writable.js');\n\n},{\"./lib/_stream_writable.js\":62}],70:[function(require,module,exports){\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":41}],71:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":47,\"inherits\":50,\"readable-stream/duplex.js\":57,\"readable-stream/passthrough.js\":66,\"readable-stream/readable.js\":67,\"readable-stream/transform.js\":68,\"readable-stream/writable.js\":69}],72:[function(require,module,exports){\n'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return -1;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// UTF-8 replacement characters ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd'.repeat(p);\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd'.repeat(p + 1);\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd'.repeat(p + 2);\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character for each buffered byte of a (partial)\n// character needs to be added to the output.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd'.repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":70}],73:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],74:[function(require,module,exports){\narguments[4][50][0].apply(exports,arguments)\n},{\"dup\":50}],75:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],76:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":75,\"_process\":56,\"inherits\":74}]},{},[1]);\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js":
/*!******************************************************************!*\
  !*** ./node_modules/script-loader!./node_modules/mocha/mocha.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/mocha/mocha.js */ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js"))

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9pbmRleC10ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmNzcz9kNmU1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3N0YXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvd2ViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuanM/M2Y2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVcsRUFBRTtBQUNyRCx3Q0FBd0MsV0FBVyxFQUFFOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNDQUFzQztBQUN0QyxHQUFHO0FBQ0g7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ05ELHlDQUF5Qyw0Q0FBNEM7O0FBRXJGO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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dC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvaW5kZXguanMhLi90ZXN0L2luZGV4LXRlc3QuanNcIik7XG4iLCJyZXF1aXJlKFwiISEvVXNlcnMvYnV0Y2hxdWVlbmluZHJhZ3MvdHVyaW5nL21vZDIvR2FtZVRpbWUvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci93ZWIuanNcIik7XG5pZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaW5pdE1vY2hhUGhhbnRvbUpTKSB7IHdpbmRvdy5pbml0TW9jaGFQaGFudG9tSlMoKTsgfVxubW9jaGEuc2V0dXAoe1widWlcIjpcImJkZFwifSk7XG5yZXF1aXJlKFwiISEvVXNlcnMvYnV0Y2hxdWVlbmluZHJhZ3MvdHVyaW5nL21vZDIvR2FtZVRpbWUvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhL1VzZXJzL2J1dGNocXVlZW5pbmRyYWdzL3R1cmluZy9tb2QyL0dhbWVUaW1lL3Rlc3QvaW5kZXgtdGVzdC5qc1wiKVxucmVxdWlyZShcIiEhL1VzZXJzL2J1dGNocXVlZW5pbmRyYWdzL3R1cmluZy9tb2QyL0dhbWVUaW1lL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvc3RhcnQuanNcIik7XG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KCk7XG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcblx0XHRtb2NoYS5zdWl0ZS5zdWl0ZXMubGVuZ3RoID0gMDtcblx0XHR2YXIgc3RhdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEtc3RhdHMnKTtcblx0XHR2YXIgcmVwb3J0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhLXJlcG9ydCcpO1xuXHRcdHN0YXRzICYmIHN0YXRzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHMpO1xuXHRcdHJlcG9ydCAmJiByZXBvcnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXBvcnQpO1xuXHR9KTtcbn0iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwidXRmLThcXFwiO1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOjA7XFxufVxcblxcbiNtb2NoYSB7XFxuICBmb250OiAyMHB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xcbiAgbWFyZ2luOiA2MHB4IDUwcHg7XFxufVxcblxcbiNtb2NoYSB1bCxcXG4jbW9jaGEgbGkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuI21vY2hhIHVsIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbiNtb2NoYSBoMSxcXG4jbW9jaGEgaDIge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4jbW9jaGEgaDEge1xcbiAgbWFyZ2luLXRvcDogMTVweDtcXG4gIGZvbnQtc2l6ZTogMWVtO1xcbiAgZm9udC13ZWlnaHQ6IDIwMDtcXG59XFxuXFxuI21vY2hhIGgxIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYSBoMSBhOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4jbW9jaGEgLnN1aXRlIC5zdWl0ZSBoMSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAgZm9udC1zaXplOiAuOGVtO1xcbn1cXG5cXG4jbW9jaGEgLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgaDIge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI21vY2hhIC5zdWl0ZSB7XFxuICBtYXJnaW4tbGVmdDogMTVweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6aG92ZXIgaDI6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcocGVuZGluZyknO1xcbiAgZm9udC1mYW1pbHk6IGFyaWFsLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5tZWRpdW0gLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNjMDk4NTM7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzLnNsb3cgLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNiOTRhNDg7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFwyNzEzJztcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGNvbG9yOiAjMDBkNmIyO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcyAuZHVyYXRpb24ge1xcbiAgZm9udC1zaXplOiA5cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgcGFkZGluZzogMnB4IDVweDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICAtbW96LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiA1cHg7XFxuICAtbXMtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW8tYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5mYXN0IC5kdXJhdGlvbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGVuZGluZyB7XFxuICBjb2xvcjogIzBiOTdjNDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXDI1RTYnO1xcbiAgY29sb3I6ICMwYjk3YzQ7XFxufVxcblxcbiNtb2NoYSAudGVzdC5mYWlsIHtcXG4gIGNvbG9yOiAjYzAwO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbCBwcmUge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbDo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICdcXFxcMjcxNic7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogI2MwMDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHByZS5lcnJvciB7XFxuICBjb2xvcjogI2MwMDtcXG4gIG1heC1oZWlnaHQ6IDMwMHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciB7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGNvbG9yOiBibGFjaztcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250OiAxMnB4LzEuNSBtb25hY28sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogNXB4O1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXgtd2lkdGg6IDg1JTsgLyooMSkqL1xcbiAgbWF4LXdpZHRoOiAtd2Via2l0LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiAtbW96LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA0MnB4KTsgLyooMikqL1xcbiAgbWF4LWhlaWdodDogMzAwcHg7XFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZGRkO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciBwcmUuZXJyb3Ige1xcbiAgYm9yZGVyOiBub25lO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwO1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMDtcXG4gIC1tb3otYm94LXNoYWRvdzogMDtcXG4gIGJveC1zaGFkb3c6IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgbWFyZ2luLXRvcDogMThweDtcXG4gIG1heC1oZWlnaHQ6IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqICgxKTogYXBwcm94aW1hdGUgZm9yIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIGNhbGNcXG4gKiAoMik6IDQyID0gMioxNSArIDIqMTAgKyAyKjEgKHBhZGRpbmcgKyBtYXJnaW4gKyBib3JkZXIpXFxuICogICAgICBeXiBzZXJpb3VzbHlcXG4gKi9cXG4jbW9jaGEgLnRlc3QgcHJlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBjbGVhcjogbGVmdDtcXG4gIGZvbnQ6IDEycHgvMS41IG1vbmFjbywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiA1cHg7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIG1heC13aWR0aDogODUlOyAvKigxKSovXFxuICBtYXgtd2lkdGg6IC13ZWJraXQtY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IC1tb3otY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDQycHgpOyAvKigyKSovXFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZGRkO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCBoMiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbiNtb2NoYSAudGVzdCBhLnJlcGxheSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDNweDtcXG4gIHJpZ2h0OiAwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDE1cHg7XFxuICBoZWlnaHQ6IDE1cHg7XFxuICBsaW5lLWhlaWdodDogMTVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXM7XFxuICAtbW96LXRyYW5zaXRpb246b3BhY2l0eSAyMDBtcztcXG4gIC1vLXRyYW5zaXRpb246b3BhY2l0eSAyMDBtcztcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XFxuICBvcGFjaXR5OiAwLjM7XFxuICBjb2xvcjogIzg4ODtcXG59XFxuXFxuI21vY2hhIC50ZXN0OmhvdmVyIGEucmVwbGF5IHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQucGFzcyAudGVzdC5mYWlsIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQuZmFpbCAudGVzdC5wYXNzIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5wYXNzLFxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5mYWlsIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5wYXNzLnBlbmRpbmcge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbiNtb2NoYS1lcnJvciB7XFxuICBjb2xvcjogI2MwMDtcXG4gIGZvbnQtc2l6ZTogMS41ZW07XFxuICBmb250LXdlaWdodDogMTAwO1xcbiAgbGV0dGVyLXNwYWNpbmc6IDFweDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMTVweDtcXG4gIHJpZ2h0OiAxMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgY29sb3I6ICM4ODg7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgLnByb2dyZXNzIHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIHBhZGRpbmctdG9wOiAwO1xcblxcbiAgLyoqXFxuICAgKiBTZXQgc2FmZSBpbml0aWFsIHZhbHVlcywgc28gbW9jaGFzIC5wcm9ncmVzcyBkb2VzIG5vdCBpbmhlcml0IHRoZXNlXFxuICAgKiBwcm9wZXJ0aWVzIGZyb20gQm9vdHN0cmFwIC5wcm9ncmVzcyAod2hpY2ggY2F1c2VzIC5wcm9ncmVzcyBoZWlnaHQgdG9cXG4gICAqIGVxdWFsIGxpbmUgaGVpZ2h0IHNldCBpbiBCb290c3RyYXApLlxcbiAgICovXFxuICBoZWlnaHQ6IGF1dG87XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAtbW96LWJveC1zaGFkb3c6IG5vbmU7XFxuICBib3gtc2hhZG93OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5pdGlhbDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGVtIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuI21vY2hhLXN0YXRzIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBhOmhvdmVyIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luOiAwIDVweDtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nLXRvcDogMTFweDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGNhbnZhcyB7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuXFxuI21vY2hhIGNvZGUgLmNvbW1lbnQgeyBjb2xvcjogI2RkZDsgfVxcbiNtb2NoYSBjb2RlIC5pbml0IHsgY29sb3I6ICMyZjZmYWQ7IH1cXG4jbW9jaGEgY29kZSAuc3RyaW5nIHsgY29sb3I6ICM1ODkwYWQ7IH1cXG4jbW9jaGEgY29kZSAua2V5d29yZCB7IGNvbG9yOiAjOGE2MzQzOyB9XFxuI21vY2hhIGNvZGUgLm51bWJlciB7IGNvbG9yOiAjMmY2ZmFkOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1kZXZpY2Utd2lkdGg6IDQ4MHB4KSB7XFxuICAjbW9jaGEge1xcbiAgICBtYXJnaW46IDYwcHggMHB4O1xcbiAgfVxcblxcbiAgI21vY2hhICNzdGF0cyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21vY2hhLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21vY2hhLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9jaGEuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAoc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiIsInByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdGRlbGV0ZSByZXF1aXJlLmNhY2hlW21vZHVsZS5pZF07XG5cdGlmKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm1vY2hhUGhhbnRvbUpTKVxuXHRcdG1vY2hhUGhhbnRvbUpTLnJ1bigpO1xuXHRlbHNlXG5cdFx0bW9jaGEucnVuKCk7XG59KTtcbiIsImlmICghIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibW9jaGFcIikpIHsgZG9jdW1lbnQud3JpdGUoXCI8ZGl2IGlkPVxcXCJtb2NoYVxcXCI+PC9kaXY+XCIpOyB9XG5cbnJlcXVpcmUoXCIhc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhbW9jaGEvbW9jaGEuY3NzXCIpO1xucmVxdWlyZShcIiFzY3JpcHQtbG9hZGVyIW1vY2hhL21vY2hhLmpzXCIpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVxcXCJmdW5jdGlvblxcXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXFxcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXFxcIitvK1xcXCInXFxcIik7dGhyb3cgZi5jb2RlPVxcXCJNT0RVTEVfTk9UX0ZPVU5EXFxcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVxcXCJmdW5jdGlvblxcXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBvZmYgKi9cXG4vKiBlc2xpbnQtZW52IGNvbW1vbmpzICovXFxuXFxuLyoqXFxuICogU2hpbSBwcm9jZXNzLnN0ZG91dC5cXG4gKi9cXG5cXG5wcm9jZXNzLnN0ZG91dCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3Rkb3V0Jykoe2xldmVsOiBmYWxzZX0pO1xcblxcbnZhciBNb2NoYSA9IHJlcXVpcmUoJy4vbGliL21vY2hhJyk7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgTW9jaGEgaW5zdGFuY2UuXFxuICpcXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XFxuICovXFxuXFxudmFyIG1vY2hhID0gbmV3IE1vY2hhKHsgcmVwb3J0ZXI6ICdodG1sJyB9KTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG5cXG52YXIgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycyA9IFtdO1xcblxcbnZhciBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyID0gZ2xvYmFsLm9uZXJyb3I7XFxuXFxuLyoqXFxuICogUmVtb3ZlIHVuY2F1Z2h0RXhjZXB0aW9uIGxpc3RlbmVyLlxcbiAqIFJldmVydCB0byBvcmlnaW5hbCBvbmVycm9yIGhhbmRsZXIgaWYgcHJldmlvdXNseSBkZWZpbmVkLlxcbiAqL1xcblxcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSwgZm4pIHtcXG4gIGlmIChlID09PSAndW5jYXVnaHRFeGNlcHRpb24nKSB7XFxuICAgIGlmIChvcmlnaW5hbE9uZXJyb3JIYW5kbGVyKSB7XFxuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBvcmlnaW5hbE9uZXJyb3JIYW5kbGVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdsb2JhbC5vbmVycm9yID0gZnVuY3Rpb24gKCkge307XFxuICAgIH1cXG4gICAgdmFyIGkgPSB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLmluZGV4T2YoZm4pO1xcbiAgICBpZiAoaSAhPT0gLTEpIHtcXG4gICAgICB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLnNwbGljZShpLCAxKTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSW1wbGVtZW50cyB1bmNhdWdodEV4Y2VwdGlvbiBsaXN0ZW5lci5cXG4gKi9cXG5cXG5wcm9jZXNzLm9uID0gZnVuY3Rpb24gKGUsIGZuKSB7XFxuICBpZiAoZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xcbiAgICBnbG9iYWwub25lcnJvciA9IGZ1bmN0aW9uIChlcnIsIHVybCwgbGluZSkge1xcbiAgICAgIGZuKG5ldyBFcnJvcihlcnIgKyAnICgnICsgdXJsICsgJzonICsgbGluZSArICcpJykpO1xcbiAgICAgIHJldHVybiAhbW9jaGEuYWxsb3dVbmNhdWdodDtcXG4gICAgfTtcXG4gICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5wdXNoKGZuKTtcXG4gIH1cXG59O1xcblxcbi8vIFRoZSBCREQgVUkgaXMgcmVnaXN0ZXJlZCBieSBkZWZhdWx0LCBidXQgbm8gVUkgd2lsbCBiZSBmdW5jdGlvbmFsIGluIHRoZVxcbi8vIGJyb3dzZXIgd2l0aG91dCBhbiBleHBsaWNpdCBjYWxsIHRvIHRoZSBvdmVycmlkZGVuIGBtb2NoYS51aWAgKHNlZSBiZWxvdykuXFxuLy8gRW5zdXJlIHRoYXQgdGhpcyBkZWZhdWx0IFVJIGRvZXMgbm90IGV4cG9zZSBpdHMgbWV0aG9kcyB0byB0aGUgZ2xvYmFsIHNjb3BlLlxcbm1vY2hhLnN1aXRlLnJlbW92ZUFsbExpc3RlbmVycygncHJlLXJlcXVpcmUnKTtcXG5cXG52YXIgaW1tZWRpYXRlUXVldWUgPSBbXTtcXG52YXIgaW1tZWRpYXRlVGltZW91dDtcXG5cXG5mdW5jdGlvbiB0aW1lc2xpY2UgKCkge1xcbiAgdmFyIGltbWVkaWF0ZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICB3aGlsZSAoaW1tZWRpYXRlUXVldWUubGVuZ3RoICYmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGltbWVkaWF0ZVN0YXJ0KSA8IDEwMCkge1xcbiAgICBpbW1lZGlhdGVRdWV1ZS5zaGlmdCgpKCk7XFxuICB9XFxuICBpZiAoaW1tZWRpYXRlUXVldWUubGVuZ3RoKSB7XFxuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpbWVzbGljZSwgMCk7XFxuICB9IGVsc2Uge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gbnVsbDtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogSGlnaC1wZXJmb3JtYW5jZSBvdmVycmlkZSBvZiBSdW5uZXIuaW1tZWRpYXRlbHkuXFxuICovXFxuXFxuTW9jaGEuUnVubmVyLmltbWVkaWF0ZWx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XFxuICBpbW1lZGlhdGVRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcXG4gIGlmICghaW1tZWRpYXRlVGltZW91dCkge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogRnVuY3Rpb24gdG8gYWxsb3cgYXNzZXJ0aW9uIGxpYnJhcmllcyB0byB0aHJvdyBlcnJvcnMgZGlyZWN0bHkgaW50byBtb2NoYS5cXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHJ1bm5pbmcgdGVzdHMgaW4gYSBicm93c2VyIGJlY2F1c2Ugd2luZG93Lm9uZXJyb3Igd2lsbFxcbiAqIG9ubHkgcmVjZWl2ZSB0aGUgJ21lc3NhZ2UnIGF0dHJpYnV0ZSBvZiB0aGUgRXJyb3IuXFxuICovXFxubW9jaGEudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcXG4gICAgZm4oZXJyKTtcXG4gIH0pO1xcbiAgdGhyb3cgZXJyO1xcbn07XFxuXFxuLyoqXFxuICogT3ZlcnJpZGUgdWkgdG8gZW5zdXJlIHRoYXQgdGhlIHVpIGZ1bmN0aW9ucyBhcmUgaW5pdGlhbGl6ZWQuXFxuICogTm9ybWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gaW4gTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlcy5cXG4gKi9cXG5cXG5tb2NoYS51aSA9IGZ1bmN0aW9uICh1aSkge1xcbiAgTW9jaGEucHJvdG90eXBlLnVpLmNhbGwodGhpcywgdWkpO1xcbiAgdGhpcy5zdWl0ZS5lbWl0KCdwcmUtcmVxdWlyZScsIGdsb2JhbCwgbnVsbCwgdGhpcyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldHVwIG1vY2hhIHdpdGggdGhlIGdpdmVuIHNldHRpbmcgb3B0aW9ucy5cXG4gKi9cXG5cXG5tb2NoYS5zZXR1cCA9IGZ1bmN0aW9uIChvcHRzKSB7XFxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG9wdHMgPSB7IHVpOiBvcHRzIH07XFxuICB9XFxuICBmb3IgKHZhciBvcHQgaW4gb3B0cykge1xcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XFxuICAgICAgdGhpc1tvcHRdKG9wdHNbb3B0XSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIG1vY2hhLCByZXR1cm5pbmcgdGhlIFJ1bm5lci5cXG4gKi9cXG5cXG5tb2NoYS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHZhciBvcHRpb25zID0gbW9jaGEub3B0aW9ucztcXG4gIG1vY2hhLmdsb2JhbHMoJ2xvY2F0aW9uJyk7XFxuXFxuICB2YXIgcXVlcnkgPSBNb2NoYS51dGlscy5wYXJzZVF1ZXJ5KGdsb2JhbC5sb2NhdGlvbi5zZWFyY2ggfHwgJycpO1xcbiAgaWYgKHF1ZXJ5LmdyZXApIHtcXG4gICAgbW9jaGEuZ3JlcChxdWVyeS5ncmVwKTtcXG4gIH1cXG4gIGlmIChxdWVyeS5mZ3JlcCkge1xcbiAgICBtb2NoYS5mZ3JlcChxdWVyeS5mZ3JlcCk7XFxuICB9XFxuICBpZiAocXVlcnkuaW52ZXJ0KSB7XFxuICAgIG1vY2hhLmludmVydCgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIE1vY2hhLnByb3RvdHlwZS5ydW4uY2FsbChtb2NoYSwgZnVuY3Rpb24gKGVycikge1xcbiAgICAvLyBUaGUgRE9NIERvY3VtZW50IGlzIG5vdCBhdmFpbGFibGUgaW4gV2ViIFdvcmtlcnMuXFxuICAgIHZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcXG4gICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpICYmIG9wdGlvbnMubm9IaWdobGlnaHRpbmcgIT09IHRydWUpIHtcXG4gICAgICBNb2NoYS51dGlscy5oaWdobGlnaHRUYWdzKCdjb2RlJyk7XFxuICAgIH1cXG4gICAgaWYgKGZuKSB7XFxuICAgICAgZm4oZXJyKTtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgdGhlIHByb2Nlc3Mgc2hpbS5cXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW9jaGFqcy9tb2NoYS9wdWxsLzkxNlxcbiAqL1xcblxcbk1vY2hhLnByb2Nlc3MgPSBwcm9jZXNzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBtb2NoYS5cXG4gKi9cXG5cXG5nbG9iYWwuTW9jaGEgPSBNb2NoYTtcXG5nbG9iYWwubW9jaGEgPSBtb2NoYTtcXG5cXG4vLyB0aGlzIGFsbG93cyB0ZXN0L2FjY2VwdGFuY2UvcmVxdWlyZWQtdG9rZW5zLmpzIHRvIHBhc3M7IHRodXMsXFxuLy8geW91IGNhbiBub3cgZG8gYGNvbnN0IGRlc2NyaWJlID0gcmVxdWlyZSgnbW9jaGEnKS5kZXNjcmliZWAgaW4gYVxcbi8vIGJyb3dzZXIgY29udGV4dCAoYXNzdW1pbmcgYnJvd3NlcmlmaWNhdGlvbikuICBzaG91bGQgZml4ICM4ODBcXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL2xpYi9tb2NoYVxcXCI6MTMsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiYnJvd3Nlci1zdGRvdXRcXFwiOjM5fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8vIGp1c3Qgc3R1YiBvdXQgZ3Jvd2xcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykubm9vcDtcXG5cXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUHJvZ3Jlc3NgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUHJvZ3Jlc3NgIGluZGljYXRvci5cXG4gKi9cXG5mdW5jdGlvbiBQcm9ncmVzcyAoKSB7XFxuICB0aGlzLnBlcmNlbnQgPSAwO1xcbiAgdGhpcy5zaXplKDApO1xcbiAgdGhpcy5mb250U2l6ZSgxMSk7XFxuICB0aGlzLmZvbnQoJ2hlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWYnKTtcXG59XFxuXFxuLyoqXFxuICogU2V0IHByb2dyZXNzIHNpemUgdG8gYHNpemVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICB0aGlzLl9zaXplID0gc2l6ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRleHQgdG8gYHRleHRgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XFxuICB0aGlzLl90ZXh0ID0gdGV4dDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IGZvbnQgc2l6ZSB0byBgc2l6ZWAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS5mb250U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICB0aGlzLl9mb250U2l6ZSA9IHNpemU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBmb250IHRvIGBmYW1pbHlgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGZhbWlseVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZm9udCA9IGZ1bmN0aW9uIChmYW1pbHkpIHtcXG4gIHRoaXMuX2ZvbnQgPSBmYW1pbHk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVwZGF0ZSBwZXJjZW50YWdlIHRvIGBuYC5cXG4gKlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobikge1xcbiAgdGhpcy5wZXJjZW50ID0gbjtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyBvbiBgY3R4YC5cXG4gKlxcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJkfSBjdHhcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XFxuICB0cnkge1xcbiAgICB2YXIgcGVyY2VudCA9IE1hdGgubWluKHRoaXMucGVyY2VudCwgMTAwKTtcXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xcbiAgICB2YXIgaGFsZiA9IHNpemUgLyAyO1xcbiAgICB2YXIgeCA9IGhhbGY7XFxuICAgIHZhciB5ID0gaGFsZjtcXG4gICAgdmFyIHJhZCA9IGhhbGYgLSAxO1xcbiAgICB2YXIgZm9udFNpemUgPSB0aGlzLl9mb250U2l6ZTtcXG5cXG4gICAgY3R4LmZvbnQgPSBmb250U2l6ZSArICdweCAnICsgdGhpcy5fZm9udDtcXG5cXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgKiAocGVyY2VudCAvIDEwMCk7XFxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XFxuXFxuICAgIC8vIG91dGVyIGNpcmNsZVxcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzlmOWY5Zic7XFxuICAgIGN0eC5iZWdpblBhdGgoKTtcXG4gICAgY3R4LmFyYyh4LCB5LCByYWQsIDAsIGFuZ2xlLCBmYWxzZSk7XFxuICAgIGN0eC5zdHJva2UoKTtcXG5cXG4gICAgLy8gaW5uZXIgY2lyY2xlXFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZWVlJztcXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xcbiAgICBjdHguYXJjKHgsIHksIHJhZCAtIDEsIDAsIGFuZ2xlLCB0cnVlKTtcXG4gICAgY3R4LnN0cm9rZSgpO1xcblxcbiAgICAvLyB0ZXh0XFxuICAgIHZhciB0ZXh0ID0gdGhpcy5fdGV4dCB8fCAocGVyY2VudCB8IDApICsgJyUnO1xcbiAgICB2YXIgdyA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcXG5cXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHggLSB3IC8gMiArIDEsIHkgKyBmb250U2l6ZSAvIDIgLSAxKTtcXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICAvLyBkb24ndCBmYWlsIGlmIHdlIGNhbid0IHJlbmRlciBwcm9ncmVzc1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG59LHt9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuaXNhdHR5ID0gZnVuY3Rpb24gaXNhdHR5ICgpIHtcXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxuZXhwb3J0cy5nZXRXaW5kb3dTaXplID0gZnVuY3Rpb24gZ2V0V2luZG93U2l6ZSAoKSB7XFxuICBpZiAoJ2lubmVySGVpZ2h0JyBpbiBnbG9iYWwpIHtcXG4gICAgcmV0dXJuIFtnbG9iYWwuaW5uZXJIZWlnaHQsIGdsb2JhbC5pbm5lcldpZHRoXTtcXG4gIH1cXG4gIC8vIEluIGEgV2ViIFdvcmtlciwgdGhlIERPTSBXaW5kb3cgaXMgbm90IGF2YWlsYWJsZS5cXG4gIHJldHVybiBbNjQwLCA0ODBdO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgQ29udGV4dFxcbiAqL1xcbi8qKlxcbiAqIEV4cG9zZSBgQ29udGV4dGAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYENvbnRleHRgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gQ29udGV4dCAoKSB7fVxcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgdGhlIGNvbnRleHQgYFJ1bm5hYmxlYCB0byBgcnVubmFibGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtSdW5uYWJsZX0gcnVubmFibGVcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBjb250ZXh0XFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUucnVubmFibGUgPSBmdW5jdGlvbiAocnVubmFibGUpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fcnVubmFibGU7XFxuICB9XFxuICB0aGlzLnRlc3QgPSB0aGlzLl9ydW5uYWJsZSA9IHJ1bm5hYmxlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRlc3QgdGltZW91dCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQoKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS50aW1lb3V0KG1zKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgdGltZW91dCBgZW5hYmxlZGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLnJ1bm5hYmxlKCkuZW5hYmxlVGltZW91dHMoKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS5lbmFibGVUaW1lb3V0cyhlbmFibGVkKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCB0ZXN0IHNsb3duZXNzIHRocmVzaG9sZCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnNsb3coKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS5zbG93KG1zKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTWFyayBhIHRlc3QgYXMgc2tpcHBlZC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEB0aHJvd3MgUGVuZGluZ1xcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLnJ1bm5hYmxlKCkuc2tpcCgpO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBhIG51bWJlciBvZiBhbGxvd2VkIHJldHJpZXMgb24gZmFpbGVkIHRlc3RzXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnJldHJpZXMoKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS5yZXRyaWVzKG4pO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBIb29rXFxuICpcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBSdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuL3V0aWxzJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBIb29rYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEhvb2s7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSG9va2Agd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYC4gRGVyaXZlZCBmcm9tXFxuICogYFJ1bm5hYmxlYC5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIEhvb2sgKHRpdGxlLCBmbikge1xcbiAgUnVubmFibGUuY2FsbCh0aGlzLCB0aXRsZSwgZm4pO1xcbiAgdGhpcy50eXBlID0gJ2hvb2snO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoSG9vaywgUnVubmFibGUpO1xcblxcbi8qKlxcbiAqIEdldCBvciBzZXQgdGhlIHRlc3QgYGVycmAuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuSG9va1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbkhvb2sucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIGVyciA9IHRoaXMuX2Vycm9yO1xcbiAgICB0aGlzLl9lcnJvciA9IG51bGw7XFxuICAgIHJldHVybiBlcnI7XFxuICB9XFxuXFxuICB0aGlzLl9lcnJvciA9IGVycjtcXG59O1xcblxcbn0se1xcXCIuL3J1bm5hYmxlXFxcIjozMixcXFwiLi91dGlsc1xcXCI6MzZ9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBCREQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgICBkZXNjcmliZSgnQXJyYXknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgZGVzY3JpYmUoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgICAvLyAuLi5cXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBpbmRleCB3aGVuIHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICAgIC8vIC4uLlxcbiAqICAgICAgICAgIH0pO1xcbiAqICAgICAgICB9KTtcXG4gKiAgICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XFxuXFxuICAgIGNvbnRleHQuYmVmb3JlID0gY29tbW9uLmJlZm9yZTtcXG4gICAgY29udGV4dC5hZnRlciA9IGNvbW1vbi5hZnRlcjtcXG4gICAgY29udGV4dC5iZWZvcmVFYWNoID0gY29tbW9uLmJlZm9yZUVhY2g7XFxuICAgIGNvbnRleHQuYWZ0ZXJFYWNoID0gY29tbW9uLmFmdGVyRWFjaDtcXG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBcXFwic3VpdGVcXFwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWBcXG4gICAgICogYW5kIGNhbGxiYWNrIGBmbmAgY29udGFpbmluZyBuZXN0ZWQgc3VpdGVzXFxuICAgICAqIGFuZC9vciB0ZXN0cy5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuZGVzY3JpYmUgPSBjb250ZXh0LmNvbnRleHQgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5jcmVhdGUoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyBkZXNjcmliZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQueGRlc2NyaWJlID0gY29udGV4dC54Y29udGV4dCA9IGNvbnRleHQuZGVzY3JpYmUuc2tpcCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHN1aXRlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5kZXNjcmliZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlXFxuICAgICAqIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmBcXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0Lml0ID0gY29udGV4dC5zcGVjaWZ5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlc1swXTtcXG4gICAgICBpZiAoc3VpdGUuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgIGZuID0gbnVsbDtcXG4gICAgICB9XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGUuYWRkVGVzdCh0ZXN0KTtcXG4gICAgICByZXR1cm4gdGVzdDtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0Lml0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQuaXQodGl0bGUsIGZuKSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQueGl0ID0gY29udGV4dC54c3BlY2lmeSA9IGNvbnRleHQuaXQuc2tpcCA9IGZ1bmN0aW9uICh0aXRsZSkge1xcbiAgICAgIHJldHVybiBjb250ZXh0Lml0KHRpdGxlKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIE51bWJlciBvZiBhdHRlbXB0cyB0byByZXRyeS5cXG4gICAgICovXFxuICAgIGNvbnRleHQuaXQucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICAgICAgY29udGV4dC5yZXRyaWVzKG4pO1xcbiAgICB9O1xcbiAgfSk7XFxufTtcXG5cXG59LHtcXFwiLi4vdGVzdFxcXCI6MzUsXFxcIi4vY29tbW9uXFxcIjo4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4uL3N1aXRlJyk7XFxuXFxuLyoqXFxuICogRnVuY3Rpb25zIGNvbW1vbiB0byBtb3JlIHRoYW4gb25lIGludGVyZmFjZS5cXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGVbXX0gc3VpdGVzXFxuICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XFxuICogQHBhcmFtIHtNb2NoYX0gbW9jaGFcXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGNvbW1vbiBmdW5jdGlvbnMuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSkge1xcbiAgcmV0dXJuIHtcXG4gICAgLyoqXFxuICAgICAqIFRoaXMgaXMgb25seSBwcmVzZW50IGlmIGZsYWcgLS1kZWxheSBpcyBwYXNzZWQgaW50byBNb2NoYS4gSXQgdHJpZ2dlcnNcXG4gICAgICogcm9vdCBzdWl0ZSBleGVjdXRpb24uXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFRoZSByb290IHN1aXRlLlxcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB3aGljaCBydW5zIHRoZSByb290IHN1aXRlXFxuICAgICAqL1xcbiAgICBydW5XaXRoU3VpdGU6IGZ1bmN0aW9uIHJ1bldpdGhTdWl0ZSAoc3VpdGUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcnVuICgpIHtcXG4gICAgICAgIHN1aXRlLnJ1bigpO1xcbiAgICAgIH07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBydW5uaW5nIHRlc3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYmVmb3JlOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYWZ0ZXIgcnVubmluZyB0ZXN0cy5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGFmdGVyOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJBbGwobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBiZWZvcmUgZWFjaCB0ZXN0IGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBiZWZvcmVFYWNoOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYmVmb3JlRWFjaChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGFmdGVyIGVhY2ggdGVzdCBjYXNlLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYWZ0ZXJFYWNoOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgc3VpdGU6IHtcXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGUgYW4gZXhjbHVzaXZlIFN1aXRlOyBjb252ZW5pZW5jZSBmdW5jdGlvblxcbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XFxuICAgICAgICovXFxuICAgICAgb25seTogZnVuY3Rpb24gb25seSAob3B0cykge1xcbiAgICAgICAgb3B0cy5pc09ubHkgPSB0cnVlO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdHMpO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ3JlYXRlIGEgU3VpdGUsIGJ1dCBza2lwIGl0OyBjb252ZW5pZW5jZSBmdW5jdGlvblxcbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XFxuICAgICAgICovXFxuICAgICAgc2tpcDogZnVuY3Rpb24gc2tpcCAob3B0cykge1xcbiAgICAgICAgb3B0cy5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShvcHRzKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENyZWF0ZXMgYSBzdWl0ZS5cXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMudGl0bGUgVGl0bGUgb2YgU3VpdGVcXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5mbl0gU3VpdGUgRnVuY3Rpb24gKG5vdCBhbHdheXMgYXBwbGljYWJsZSlcXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBlbmRpbmddIElzIFN1aXRlIHBlbmRpbmc/XFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZpbGVdIEZpbGVwYXRoIHdoZXJlIHRoaXMgU3VpdGUgcmVzaWRlc1xcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaXNPbmx5XSBJcyBTdWl0ZSBleGNsdXNpdmU/XFxuICAgICAgICogQHJldHVybnMge1N1aXRlfVxcbiAgICAgICAqL1xcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChvcHRzKSB7XFxuICAgICAgICB2YXIgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBvcHRzLnRpdGxlKTtcXG4gICAgICAgIHN1aXRlLnBlbmRpbmcgPSBCb29sZWFuKG9wdHMucGVuZGluZyk7XFxuICAgICAgICBzdWl0ZS5maWxlID0gb3B0cy5maWxlO1xcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgICAgaWYgKG9wdHMuaXNPbmx5KSB7XFxuICAgICAgICAgIHN1aXRlLnBhcmVudC5fb25seVN1aXRlcyA9IHN1aXRlLnBhcmVudC5fb25seVN1aXRlcy5jb25jYXQoc3VpdGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIG9wdHMuZm4uY2FsbChzdWl0ZSk7XFxuICAgICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5mbiA9PT0gJ3VuZGVmaW5lZCcgJiYgIXN1aXRlLnBlbmRpbmcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWl0ZSBcXFwiJyArIHN1aXRlLmZ1bGxUaXRsZSgpICsgJ1xcXCIgd2FzIGRlZmluZWQgYnV0IG5vIGNhbGxiYWNrIHdhcyBzdXBwbGllZC4gU3VwcGx5IGEgY2FsbGJhY2sgb3IgZXhwbGljaXRseSBza2lwIHRoZSBzdWl0ZS4nKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMuZm4gJiYgc3VpdGUucGVuZGluZykge1xcbiAgICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHRlc3Q6IHtcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vY2hhXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdFxcbiAgICAgICAqIEByZXR1cm5zIHsqfVxcbiAgICAgICAqL1xcbiAgICAgIG9ubHk6IGZ1bmN0aW9uIChtb2NoYSwgdGVzdCkge1xcbiAgICAgICAgdGVzdC5wYXJlbnQuX29ubHlUZXN0cyA9IHRlc3QucGFyZW50Ll9vbmx5VGVzdHMuY29uY2F0KHRlc3QpO1xcbiAgICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAgICAgICAqL1xcbiAgICAgIHNraXA6IGZ1bmN0aW9uICh0aXRsZSkge1xcbiAgICAgICAgY29udGV4dC50ZXN0KHRpdGxlKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIE51bWJlciBvZiByZXRyeSBhdHRlbXB0c1xcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gICAgICAgKi9cXG4gICAgICByZXRyaWVzOiBmdW5jdGlvbiAobikge1xcbiAgICAgICAgY29udGV4dC5yZXRyaWVzKG4pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG59O1xcblxcbn0se1xcXCIuLi9zdWl0ZVxcXCI6MzR9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcbnZhciBUZXN0ID0gcmVxdWlyZSgnLi4vdGVzdCcpO1xcblxcbi8qKlxcbiAqIEV4cG9ydHMtc3R5bGUgKGFzIE5vZGUuanMgbW9kdWxlKSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgZXhwb3J0cy5BcnJheSA9IHtcXG4gKiAgICAgICAnI2luZGV4T2YoKSc6IHtcXG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIC0xIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50JzogZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgIH0sXFxuICpcXG4gKiAgICAgICAgICdzaG91bGQgcmV0dXJuIHRoZSBjb3JyZWN0IGluZGV4IHdoZW4gdGhlIHZhbHVlIGlzIHByZXNlbnQnOiBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgfVxcbiAqICAgICAgIH1cXG4gKiAgICAgfTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3JlcXVpcmUnLCB2aXNpdCk7XFxuXFxuICBmdW5jdGlvbiB2aXNpdCAob2JqLCBmaWxlKSB7XFxuICAgIHZhciBzdWl0ZTtcXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHZhciBmbiA9IG9ialtrZXldO1xcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcXG4gICAgICAgICAgY2FzZSAnYmVmb3JlJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYmVmb3JlQWxsKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYWZ0ZXInOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckFsbChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ2JlZm9yZUVhY2gnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYWZ0ZXJFYWNoJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWZ0ZXJFYWNoKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KGtleSwgZm4pO1xcbiAgICAgICAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwga2V5KTtcXG4gICAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcXG4gICAgICAgIHZpc2l0KG9ialtrZXldLCBmaWxlKTtcXG4gICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn07XFxuXFxufSx7XFxcIi4uL3N1aXRlXFxcIjozNCxcXFwiLi4vdGVzdFxcXCI6MzV9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuYmRkID0gcmVxdWlyZSgnLi9iZGQnKTtcXG5leHBvcnRzLnRkZCA9IHJlcXVpcmUoJy4vdGRkJyk7XFxuZXhwb3J0cy5xdW5pdCA9IHJlcXVpcmUoJy4vcXVuaXQnKTtcXG5leHBvcnRzLmV4cG9ydHMgPSByZXF1aXJlKCcuL2V4cG9ydHMnKTtcXG5cXG59LHtcXFwiLi9iZGRcXFwiOjcsXFxcIi4vZXhwb3J0c1xcXCI6OSxcXFwiLi9xdW5pdFxcXCI6MTEsXFxcIi4vdGRkXFxcIjoxMn1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBRVW5pdC1zdHlsZSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgc3VpdGUoJ0FycmF5Jyk7XFxuICpcXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xcbiAqICAgICAgIG9rKGFyci5sZW5ndGggPT0gMyk7XFxuICogICAgIH0pO1xcbiAqXFxuICogICAgIHRlc3QoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICB2YXIgYXJyID0gWzEsMiwzXTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigxKSA9PSAwKTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigyKSA9PSAxKTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigzKSA9PSAyKTtcXG4gKiAgICAgfSk7XFxuICpcXG4gKiAgICAgc3VpdGUoJ1N0cmluZycpO1xcbiAqXFxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICBvaygnZm9vJy5sZW5ndGggPT0gMyk7XFxuICogICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XFxuXFxuICAgIGNvbnRleHQuYmVmb3JlID0gY29tbW9uLmJlZm9yZTtcXG4gICAgY29udGV4dC5hZnRlciA9IGNvbW1vbi5hZnRlcjtcXG4gICAgY29udGV4dC5iZWZvcmVFYWNoID0gY29tbW9uLmJlZm9yZUVhY2g7XFxuICAgIGNvbnRleHQuYWZ0ZXJFYWNoID0gY29tbW9uLmFmdGVyRWFjaDtcXG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBcXFwic3VpdGVcXFwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnN1aXRlID0gZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgaWYgKHN1aXRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5jcmVhdGUoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIFN1aXRlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgaWYgKHN1aXRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcXG4gICAgICogd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYFxcbiAgICAgKiBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZXNbMF0uYWRkVGVzdCh0ZXN0KTtcXG4gICAgICByZXR1cm4gdGVzdDtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnRlc3Qub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC50ZXN0KHRpdGxlLCBmbikpO1xcbiAgICB9O1xcblxcbiAgICBjb250ZXh0LnRlc3Quc2tpcCA9IGNvbW1vbi50ZXN0LnNraXA7XFxuICAgIGNvbnRleHQudGVzdC5yZXRyaWVzID0gY29tbW9uLnRlc3QucmV0cmllcztcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3Rlc3RcXFwiOjM1LFxcXCIuL2NvbW1vblxcXCI6OH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBUREQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgICBzdWl0ZSgnQXJyYXknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgc3VpdGUoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICBzdWl0ZVNldHVwKGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIC0xIHdoZW4gbm90IHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiB0aGUgaW5kZXggd2hlbiBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHN1aXRlVGVhcmRvd24oZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKiAgICAgICAgfSk7XFxuICogICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xcblxcbiAgICBjb250ZXh0LnNldHVwID0gY29tbW9uLmJlZm9yZUVhY2g7XFxuICAgIGNvbnRleHQudGVhcmRvd24gPSBjb21tb24uYWZ0ZXJFYWNoO1xcbiAgICBjb250ZXh0LnN1aXRlU2V0dXAgPSBjb21tb24uYmVmb3JlO1xcbiAgICBjb250ZXh0LnN1aXRlVGVhcmRvd24gPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmdcXG4gICAgICogbmVzdGVkIHN1aXRlcyBhbmQvb3IgdGVzdHMuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFBlbmRpbmcgc3VpdGUuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlLnNraXAgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5za2lwKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlLm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2Ugd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmRcXG4gICAgICogY2FsbGJhY2sgYGZuYCBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuICAgIGNvbnRleHQudGVzdCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZXNbMF07XFxuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XFxuICAgICAgICBmbiA9IG51bGw7XFxuICAgICAgfVxcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi90ZXN0XFxcIjozNSxcXFwiLi9jb21tb25cXFwiOjh9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxfX2Rpcm5hbWUpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiFcXG4gKiBtb2NoYVxcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XFxuICogTUlUIExpY2Vuc2VkXFxuICovXFxuLyoqXFxuICogQG5hbWVzcGFjZSBNb2NoYVxcbiAqIEBtb2R1bGUgTW9jaGFcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XFxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxudmFyIHJlcG9ydGVycyA9IHJlcXVpcmUoJy4vcmVwb3J0ZXJzJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTW9jaGFgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1vY2hhO1xcblxcbi8qKlxcbiAqIFRvIHJlcXVpcmUgbG9jYWwgVUlzIGFuZCByZXBvcnRlcnMgd2hlbiBydW5uaW5nIGluIG5vZGUuXFxuICovXFxuXFxuaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHtcXG4gIHZhciBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xcbiAgbW9kdWxlLnBhdGhzLnB1c2goY3dkLCBwYXRoLmpvaW4oY3dkLCAnbm9kZV9tb2R1bGVzJykpO1xcbn1cXG5cXG4vKipcXG4gKiBFeHBvc2UgaW50ZXJuYWxzLlxcbiAqL1xcblxcbi8qKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3MgdXRpbHNcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKi9cXG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XFxuZXhwb3J0cy5pbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XFxuLyoqXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICovXFxuZXhwb3J0cy5yZXBvcnRlcnMgPSByZXBvcnRlcnM7XFxuZXhwb3J0cy5SdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG5leHBvcnRzLkNvbnRleHQgPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcXG4vKipcXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqL1xcbmV4cG9ydHMuUnVubmVyID0gcmVxdWlyZSgnLi9ydW5uZXInKTtcXG5leHBvcnRzLlN1aXRlID0gcmVxdWlyZSgnLi9zdWl0ZScpO1xcbmV4cG9ydHMuSG9vayA9IHJlcXVpcmUoJy4vaG9vaycpO1xcbmV4cG9ydHMuVGVzdCA9IHJlcXVpcmUoJy4vdGVzdCcpO1xcblxcbi8qKlxcbiAqIFJldHVybiBpbWFnZSBgbmFtZWAgcGF0aC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGltYWdlIChuYW1lKSB7XFxuICByZXR1cm4gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2ltYWdlcycsIG5hbWUgKyAnLnBuZycpO1xcbn1cXG5cXG4vKipcXG4gKiBTZXQgdXAgbW9jaGEgd2l0aCBgb3B0aW9uc2AuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogICAtIGB1aWAgbmFtZSBcXFwiYmRkXFxcIiwgXFxcInRkZFxcXCIsIFxcXCJleHBvcnRzXFxcIiBldGNcXG4gKiAgIC0gYHJlcG9ydGVyYCByZXBvcnRlciBpbnN0YW5jZSwgZGVmYXVsdHMgdG8gYG1vY2hhLnJlcG9ydGVycy5zcGVjYFxcbiAqICAgLSBgZ2xvYmFsc2AgYXJyYXkgb2YgYWNjZXB0ZWQgZ2xvYmFsc1xcbiAqICAgLSBgdGltZW91dGAgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcXG4gKiAgIC0gYHJldHJpZXNgIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBmYWlsZWQgdGVzdHNcXG4gKiAgIC0gYGJhaWxgIGJhaWwgb24gdGhlIGZpcnN0IHRlc3QgZmFpbHVyZVxcbiAqICAgLSBgc2xvd2AgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGNvbnNpZGVyaW5nIGEgdGVzdCBzbG93XFxuICogICAtIGBpZ25vcmVMZWFrc2AgaWdub3JlIGdsb2JhbCBsZWFrc1xcbiAqICAgLSBgZnVsbFRyYWNlYCBkaXNwbGF5IHRoZSBmdWxsIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKiAgIC0gYGdyZXBgIHN0cmluZyBvciByZWdleHAgdG8gZmlsdGVyIHRlc3RzIHdpdGhcXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3MgTW9jaGFcXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuZnVuY3Rpb24gTW9jaGEgKG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgdGhpcy5maWxlcyA9IFtdO1xcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG4gIGlmIChvcHRpb25zLmdyZXApIHtcXG4gICAgdGhpcy5ncmVwKG5ldyBSZWdFeHAob3B0aW9ucy5ncmVwKSk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5mZ3JlcCkge1xcbiAgICB0aGlzLmZncmVwKG9wdGlvbnMuZmdyZXApO1xcbiAgfVxcbiAgdGhpcy5zdWl0ZSA9IG5ldyBleHBvcnRzLlN1aXRlKCcnLCBuZXcgZXhwb3J0cy5Db250ZXh0KCkpO1xcbiAgdGhpcy51aShvcHRpb25zLnVpKTtcXG4gIHRoaXMuYmFpbChvcHRpb25zLmJhaWwpO1xcbiAgdGhpcy5yZXBvcnRlcihvcHRpb25zLnJlcG9ydGVyLCBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyk7XFxuICBpZiAodHlwZW9mIG9wdGlvbnMudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy50aW1lb3V0ICE9PSBudWxsKSB7XFxuICAgIHRoaXMudGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJldHJpZXMgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMucmV0cmllcyAhPT0gbnVsbCkge1xcbiAgICB0aGlzLnJldHJpZXMob3B0aW9ucy5yZXRyaWVzKTtcXG4gIH1cXG4gIHRoaXMudXNlQ29sb3JzKG9wdGlvbnMudXNlQ29sb3JzKTtcXG4gIGlmIChvcHRpb25zLmVuYWJsZVRpbWVvdXRzICE9PSBudWxsKSB7XFxuICAgIHRoaXMuZW5hYmxlVGltZW91dHMob3B0aW9ucy5lbmFibGVUaW1lb3V0cyk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5zbG93KSB7XFxuICAgIHRoaXMuc2xvdyhvcHRpb25zLnNsb3cpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBiYWlsaW5nIG9uIHRoZSBmaXJzdCBmYWlsdXJlLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBbYmFpbF1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuYmFpbCA9IGZ1bmN0aW9uIChiYWlsKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgYmFpbCA9IHRydWU7XFxuICB9XFxuICB0aGlzLnN1aXRlLmJhaWwoYmFpbCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCB0ZXN0IGBmaWxlYC5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFkZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSkge1xcbiAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgcmVwb3J0ZXIgdG8gYHJlcG9ydGVyYCwgZGVmYXVsdHMgdG8gXFxcInNwZWNcXFwiLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSByZXBvcnRlciBuYW1lIG9yIGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtPYmplY3R9IHJlcG9ydGVyT3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gcmVwb3J0ZXIgbmFtZSBvciBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRlck9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5yZXBvcnRlciA9IGZ1bmN0aW9uIChyZXBvcnRlciwgcmVwb3J0ZXJPcHRpb25zKSB7XFxuICBpZiAodHlwZW9mIHJlcG9ydGVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRoaXMuX3JlcG9ydGVyID0gcmVwb3J0ZXI7XFxuICB9IGVsc2Uge1xcbiAgICByZXBvcnRlciA9IHJlcG9ydGVyIHx8ICdzcGVjJztcXG4gICAgdmFyIF9yZXBvcnRlcjtcXG4gICAgLy8gVHJ5IHRvIGxvYWQgYSBidWlsdC1pbiByZXBvcnRlci5cXG4gICAgaWYgKHJlcG9ydGVyc1tyZXBvcnRlcl0pIHtcXG4gICAgICBfcmVwb3J0ZXIgPSByZXBvcnRlcnNbcmVwb3J0ZXJdO1xcbiAgICB9XFxuICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIHByb2Nlc3MuY3dkKCkgYW5kIG5vZGVfbW9kdWxlc1xcbiAgICBpZiAoIV9yZXBvcnRlcikge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBfcmVwb3J0ZXIgPSByZXF1aXJlKHJlcG9ydGVyKTtcXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdDYW5ub3QgZmluZCBtb2R1bGUnKSAhPT0gLTEpIHtcXG4gICAgICAgICAgLy8gVHJ5IHRvIGxvYWQgcmVwb3J0ZXJzIGZyb20gYSBwYXRoIChhYnNvbHV0ZSBvciByZWxhdGl2ZSlcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBfcmVwb3J0ZXIgPSByZXF1aXJlKHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXBvcnRlcikpO1xcbiAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XFxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UuaW5kZXhPZignQ2Fubm90IGZpbmQgbW9kdWxlJykgIT09IC0xID8gY29uc29sZS53YXJuKCdcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCIgcmVwb3J0ZXIgbm90IGZvdW5kJylcXG4gICAgICAgICAgICAgIDogY29uc29sZS53YXJuKCdcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCIgcmVwb3J0ZXIgYmxldyB1cCB3aXRoIGVycm9yOlxcXFxuJyArIGVyci5zdGFjayk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIGJsZXcgdXAgd2l0aCBlcnJvcjpcXFxcbicgKyBlcnIuc3RhY2spO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoIV9yZXBvcnRlciAmJiByZXBvcnRlciA9PT0gJ3RlYW1jaXR5Jykge1xcbiAgICAgIGNvbnNvbGUud2FybignVGhlIFRlYW1jaXR5IHJlcG9ydGVyIHdhcyBtb3ZlZCB0byBhIHBhY2thZ2UgbmFtZWQgJyArXFxuICAgICAgICAnbW9jaGEtdGVhbWNpdHktcmVwb3J0ZXIgJyArXFxuICAgICAgICAnKGh0dHBzOi8vbnBtanMub3JnL3BhY2thZ2UvbW9jaGEtdGVhbWNpdHktcmVwb3J0ZXIpLicpO1xcbiAgICB9XFxuICAgIGlmICghX3JlcG9ydGVyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlcG9ydGVyIFxcXCInICsgcmVwb3J0ZXIgKyAnXFxcIicpO1xcbiAgICB9XFxuICAgIHRoaXMuX3JlcG9ydGVyID0gX3JlcG9ydGVyO1xcbiAgfVxcbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9ucyA9IHJlcG9ydGVyT3B0aW9ucztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgVUkgYG5hbWVgLCBkZWZhdWx0cyB0byBcXFwiYmRkXFxcIi5cXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gYmRkXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVpID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIG5hbWUgPSBuYW1lIHx8ICdiZGQnO1xcbiAgdGhpcy5fdWkgPSBleHBvcnRzLmludGVyZmFjZXNbbmFtZV07XFxuICBpZiAoIXRoaXMuX3VpKSB7XFxuICAgIHRyeSB7XFxuICAgICAgdGhpcy5fdWkgPSByZXF1aXJlKG5hbWUpO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW50ZXJmYWNlIFxcXCInICsgbmFtZSArICdcXFwiJyk7XFxuICAgIH1cXG4gIH1cXG4gIHRoaXMuX3VpID0gdGhpcy5fdWkodGhpcy5zdWl0ZSk7XFxuXFxuICB0aGlzLnN1aXRlLm9uKCdwcmUtcmVxdWlyZScsIGZ1bmN0aW9uIChjb250ZXh0KSB7XFxuICAgIGV4cG9ydHMuYWZ0ZXJFYWNoID0gY29udGV4dC5hZnRlckVhY2ggfHwgY29udGV4dC50ZWFyZG93bjtcXG4gICAgZXhwb3J0cy5hZnRlciA9IGNvbnRleHQuYWZ0ZXIgfHwgY29udGV4dC5zdWl0ZVRlYXJkb3duO1xcbiAgICBleHBvcnRzLmJlZm9yZUVhY2ggPSBjb250ZXh0LmJlZm9yZUVhY2ggfHwgY29udGV4dC5zZXR1cDtcXG4gICAgZXhwb3J0cy5iZWZvcmUgPSBjb250ZXh0LmJlZm9yZSB8fCBjb250ZXh0LnN1aXRlU2V0dXA7XFxuICAgIGV4cG9ydHMuZGVzY3JpYmUgPSBjb250ZXh0LmRlc2NyaWJlIHx8IGNvbnRleHQuc3VpdGU7XFxuICAgIGV4cG9ydHMuaXQgPSBjb250ZXh0Lml0IHx8IGNvbnRleHQudGVzdDtcXG4gICAgZXhwb3J0cy54aXQgPSBjb250ZXh0LnhpdCB8fCBjb250ZXh0LnRlc3Quc2tpcDtcXG4gICAgZXhwb3J0cy5zZXR1cCA9IGNvbnRleHQuc2V0dXAgfHwgY29udGV4dC5iZWZvcmVFYWNoO1xcbiAgICBleHBvcnRzLnN1aXRlU2V0dXAgPSBjb250ZXh0LnN1aXRlU2V0dXAgfHwgY29udGV4dC5iZWZvcmU7XFxuICAgIGV4cG9ydHMuc3VpdGVUZWFyZG93biA9IGNvbnRleHQuc3VpdGVUZWFyZG93biB8fCBjb250ZXh0LmFmdGVyO1xcbiAgICBleHBvcnRzLnN1aXRlID0gY29udGV4dC5zdWl0ZSB8fCBjb250ZXh0LmRlc2NyaWJlO1xcbiAgICBleHBvcnRzLnRlYXJkb3duID0gY29udGV4dC50ZWFyZG93biB8fCBjb250ZXh0LmFmdGVyRWFjaDtcXG4gICAgZXhwb3J0cy50ZXN0ID0gY29udGV4dC50ZXN0IHx8IGNvbnRleHQuaXQ7XFxuICAgIGV4cG9ydHMucnVuID0gY29udGV4dC5ydW47XFxuICB9KTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTG9hZCByZWdpc3RlcmVkIGZpbGVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmxvYWRGaWxlcyA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHRoaXMuZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xcbiAgICBmaWxlID0gcGF0aC5yZXNvbHZlKGZpbGUpO1xcbiAgICBzdWl0ZS5lbWl0KCdwcmUtcmVxdWlyZScsIGdsb2JhbCwgZmlsZSwgc2VsZik7XFxuICAgIHN1aXRlLmVtaXQoJ3JlcXVpcmUnLCByZXF1aXJlKGZpbGUpLCBmaWxlLCBzZWxmKTtcXG4gICAgc3VpdGUuZW1pdCgncG9zdC1yZXF1aXJlJywgZ2xvYmFsLCBmaWxlLCBzZWxmKTtcXG4gIH0pO1xcbiAgZm4gJiYgZm4oKTtcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSBncm93bCBzdXBwb3J0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuTW9jaGEucHJvdG90eXBlLl9ncm93bCA9IGZ1bmN0aW9uIChydW5uZXIsIHJlcG9ydGVyKSB7XFxuICB2YXIgbm90aWZ5ID0gcmVxdWlyZSgnZ3Jvd2wnKTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc3RhdHMgPSByZXBvcnRlci5zdGF0cztcXG4gICAgaWYgKHN0YXRzLmZhaWx1cmVzKSB7XFxuICAgICAgdmFyIG1zZyA9IHN0YXRzLmZhaWx1cmVzICsgJyBvZiAnICsgcnVubmVyLnRvdGFsICsgJyB0ZXN0cyBmYWlsZWQnO1xcbiAgICAgIG5vdGlmeShtc2csIHsgbmFtZTogJ21vY2hhJywgdGl0bGU6ICdGYWlsZWQnLCBpbWFnZTogaW1hZ2UoJ2Vycm9yJykgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbm90aWZ5KHN0YXRzLnBhc3NlcyArICcgdGVzdHMgcGFzc2VkIGluICcgKyBzdGF0cy5kdXJhdGlvbiArICdtcycsIHtcXG4gICAgICAgIG5hbWU6ICdtb2NoYScsXFxuICAgICAgICB0aXRsZTogJ1Bhc3NlZCcsXFxuICAgICAgICBpbWFnZTogaW1hZ2UoJ29rJylcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBFc2NhcGUgc3RyaW5nIGFuZCBhZGQgaXQgdG8gZ3JlcCBhcyBhIHJlZ2V4cC5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSBzdHJcXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZncmVwID0gZnVuY3Rpb24gKHN0cikge1xcbiAgcmV0dXJuIHRoaXMuZ3JlcChuZXcgUmVnRXhwKGVzY2FwZVJlKHN0cikpKTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZCByZWdleHAgdG8gZ3JlcCwgaWYgYHJlYCBpcyBhIHN0cmluZyBpdCBpcyBlc2NhcGVkLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uIChyZSkge1xcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJlKSkge1xcbiAgICAvLyBleHRyYWN0IGFyZ3MgaWYgaXQncyByZWdleC1saWtlLCBpLmU6IFtzdHJpbmcsIHBhdHRlcm4sIGZsYWddXFxuICAgIHZhciBhcmcgPSByZS5tYXRjaCgvXlxcXFwvKC4qKVxcXFwvKGd8aXwpJHwuKi8pO1xcbiAgICB0aGlzLm9wdGlvbnMuZ3JlcCA9IG5ldyBSZWdFeHAoYXJnWzFdIHx8IGFyZ1swXSwgYXJnWzJdKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gcmU7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcbi8qKlxcbiAqIEludmVydCBgLmdyZXAoKWAgbWF0Y2hlcy5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuaW52ZXJ0ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGdsb2JhbCBsZWFrcy5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaWdub3JlTGVha3MgPSBmdW5jdGlvbiAoaWdub3JlKSB7XFxuICB0aGlzLm9wdGlvbnMuaWdub3JlTGVha3MgPSBCb29sZWFuKGlnbm9yZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSBnbG9iYWwgbGVhayBjaGVja2luZy5cXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5jaGVja0xlYWtzID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmlnbm9yZUxlYWtzID0gZmFsc2U7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERpc3BsYXkgbG9uZyBzdGFjay10cmFjZSBvbiBmYWlsaW5nXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZnVsbFRyYWNlID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmZ1bGxTdGFja1RyYWNlID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIGdyb3dsIHN1cHBvcnQuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ3Jvd2wgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZ3Jvd2wgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBJZ25vcmUgYGdsb2JhbHNgIGFycmF5IG9yIHN0cmluZy5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBnbG9iYWxzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uIChnbG9iYWxzKSB7XFxuICB0aGlzLm9wdGlvbnMuZ2xvYmFscyA9ICh0aGlzLm9wdGlvbnMuZ2xvYmFscyB8fCBbXSkuY29uY2F0KGdsb2JhbHMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbWl0IGNvbG9yIG91dHB1dC5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3JzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBjb2xvcnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudXNlQ29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xcbiAgaWYgKGNvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXMub3B0aW9ucy51c2VDb2xvcnMgPSBjb2xvcnM7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVzZSBpbmxpbmUgZGlmZnMgcmF0aGVyIHRoYW4gKy8tLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBpbmxpbmVEaWZmc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5saW5lRGlmZnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudXNlSW5saW5lRGlmZnMgPSBmdW5jdGlvbiAoaW5saW5lRGlmZnMpIHtcXG4gIHRoaXMub3B0aW9ucy51c2VJbmxpbmVEaWZmcyA9IGlubGluZURpZmZzICE9PSB1bmRlZmluZWQgJiYgaW5saW5lRGlmZnM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERvIG5vdCBzaG93IGRpZmZzIGF0IGFsbC5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaGlkZURpZmZcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGVEaWZmXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmhpZGVEaWZmID0gZnVuY3Rpb24gKGhpZGVEaWZmKSB7XFxuICB0aGlzLm9wdGlvbnMuaGlkZURpZmYgPSBoaWRlRGlmZiAhPT0gdW5kZWZpbmVkICYmIGhpZGVEaWZmO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcXG4gIHRoaXMuc3VpdGUudGltZW91dCh0aW1lb3V0KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgZmFpbGVkIHRlc3RzLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IHJldHJ5IHRpbWVzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xcbiAgdGhpcy5zdWl0ZS5yZXRyaWVzKG4pO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgc2xvd25lc3MgdGhyZXNob2xkIGluIG1pbGxpc2Vjb25kcy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBzbG93XFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNsb3dcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChzbG93KSB7XFxuICB0aGlzLnN1aXRlLnNsb3coc2xvdyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSB0aW1lb3V0cy5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5lbmFibGVUaW1lb3V0cyA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XFxuICB0aGlzLnN1aXRlLmVuYWJsZVRpbWVvdXRzKGFyZ3VtZW50cy5sZW5ndGggJiYgZW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gZW5hYmxlZCA6IHRydWUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBNYWtlcyBhbGwgdGVzdHMgYXN5bmMgKGFjY2VwdGluZyBhIGNhbGxiYWNrKVxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFzeW5jT25seSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5hc3luY09ubHkgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNhYmxlIHN5bnRheCBoaWdobGlnaHRpbmcgKGluIGJyb3dzZXIpLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLm5vSGlnaGxpZ2h0aW5nID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLm5vSGlnaGxpZ2h0aW5nID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIHVuY2F1Z2h0IGVycm9ycyB0byBwcm9wYWdhdGUgKGluIGJyb3dzZXIpLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFsbG93VW5jYXVnaHQgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuYWxsb3dVbmNhdWdodCA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERlbGF5IHJvb3Qgc3VpdGUgZXhlY3V0aW9uLlxcbiAqIEByZXR1cm5zIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiBkZWxheSAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZGVsYXkgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBUZXN0cyBtYXJrZWQgb25seSBmYWlsIHRoZSBzdWl0ZVxcbiAqIEByZXR1cm5zIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZm9yYmlkT25seSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5mb3JiaWRPbmx5ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUGVuZGluZyB0ZXN0cyBhbmQgdGVzdHMgbWFya2VkIHNraXAgZmFpbCB0aGUgc3VpdGVcXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZvcmJpZFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZm9yYmlkUGVuZGluZyA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyBhbmQgaW52b2tlIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxcbiAqXFxuICogTm90ZSB0aGF0IGBsb2FkRmlsZXNgIHJlbGllcyBvbiBOb2RlJ3MgYHJlcXVpcmVgIHRvIGV4ZWN1dGVcXG4gKiB0aGUgdGVzdCBpbnRlcmZhY2UgZnVuY3Rpb25zIGFuZCB3aWxsIGJlIHN1YmplY3QgdG8gdGhlXFxuICogY2FjaGUgLSBpZiB0aGUgZmlsZXMgYXJlIGFscmVhZHkgaW4gdGhlIGByZXF1aXJlYCBjYWNoZSxcXG4gKiB0aGV5IHdpbGwgZWZmZWN0aXZlbHkgYmUgc2tpcHBlZC4gVGhlcmVmb3JlLCB0byBydW4gdGVzdHNcXG4gKiBtdWx0aXBsZSB0aW1lcyBvciB0byBydW4gdGVzdHMgaW4gZmlsZXMgdGhhdCBhcmUgYWxyZWFkeVxcbiAqIGluIHRoZSBgcmVxdWlyZWAgY2FjaGUsIG1ha2Ugc3VyZSB0byBjbGVhciB0aGVtIGZyb20gdGhlXFxuICogY2FjaGUgZmlyc3QgaW4gd2hpY2hldmVyIG1hbm5lciBiZXN0IHN1aXRzIHlvdXIgbmVlZHMuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1J1bm5lcn1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XFxuICBpZiAodGhpcy5maWxlcy5sZW5ndGgpIHtcXG4gICAgdGhpcy5sb2FkRmlsZXMoKTtcXG4gIH1cXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG4gIG9wdGlvbnMuZmlsZXMgPSB0aGlzLmZpbGVzO1xcbiAgdmFyIHJ1bm5lciA9IG5ldyBleHBvcnRzLlJ1bm5lcihzdWl0ZSwgb3B0aW9ucy5kZWxheSk7XFxuICB2YXIgcmVwb3J0ZXIgPSBuZXcgdGhpcy5fcmVwb3J0ZXIocnVubmVyLCBvcHRpb25zKTtcXG4gIHJ1bm5lci5pZ25vcmVMZWFrcyA9IG9wdGlvbnMuaWdub3JlTGVha3MgIT09IGZhbHNlO1xcbiAgcnVubmVyLmZ1bGxTdGFja1RyYWNlID0gb3B0aW9ucy5mdWxsU3RhY2tUcmFjZTtcXG4gIHJ1bm5lci5hc3luY09ubHkgPSBvcHRpb25zLmFzeW5jT25seTtcXG4gIHJ1bm5lci5hbGxvd1VuY2F1Z2h0ID0gb3B0aW9ucy5hbGxvd1VuY2F1Z2h0O1xcbiAgcnVubmVyLmZvcmJpZE9ubHkgPSBvcHRpb25zLmZvcmJpZE9ubHk7XFxuICBydW5uZXIuZm9yYmlkUGVuZGluZyA9IG9wdGlvbnMuZm9yYmlkUGVuZGluZztcXG4gIGlmIChvcHRpb25zLmdyZXApIHtcXG4gICAgcnVubmVyLmdyZXAob3B0aW9ucy5ncmVwLCBvcHRpb25zLmludmVydCk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5nbG9iYWxzKSB7XFxuICAgIHJ1bm5lci5nbG9iYWxzKG9wdGlvbnMuZ2xvYmFscyk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5ncm93bCkge1xcbiAgICB0aGlzLl9ncm93bChydW5uZXIsIHJlcG9ydGVyKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLnVzZUNvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UudXNlQ29sb3JzID0gb3B0aW9ucy51c2VDb2xvcnM7XFxuICB9XFxuICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLmlubGluZURpZmZzID0gb3B0aW9ucy51c2VJbmxpbmVEaWZmcztcXG4gIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UuaGlkZURpZmYgPSBvcHRpb25zLmhpZGVEaWZmO1xcblxcbiAgZnVuY3Rpb24gZG9uZSAoZmFpbHVyZXMpIHtcXG4gICAgaWYgKHJlcG9ydGVyLmRvbmUpIHtcXG4gICAgICByZXBvcnRlci5kb25lKGZhaWx1cmVzLCBmbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm4gJiYgZm4oZmFpbHVyZXMpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcnVubmVyLnJ1bihkb25lKTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30sXFxcIi9saWJcXFwiKVxcbn0se1xcXCIuL2NvbnRleHRcXFwiOjUsXFxcIi4vaG9va1xcXCI6NixcXFwiLi9pbnRlcmZhY2VzXFxcIjoxMCxcXFwiLi9yZXBvcnRlcnNcXFwiOjIwLFxcXCIuL3J1bm5hYmxlXFxcIjozMixcXFwiLi9ydW5uZXJcXFwiOjMzLFxcXCIuL3N1aXRlXFxcIjozNCxcXFwiLi90ZXN0XFxcIjozNSxcXFwiLi91dGlsc1xcXCI6MzYsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiZXNjYXBlLXN0cmluZy1yZWdleHBcXFwiOjQ2LFxcXCJncm93bFxcXCI6MixcXFwicGF0aFxcXCI6NDB9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgbWlsbGlzZWNvbmRzXFxuICovXFxuLyoqXFxuICogSGVscGVycy5cXG4gKi9cXG5cXG52YXIgcyA9IDEwMDA7XFxudmFyIG0gPSBzICogNjA7XFxudmFyIGggPSBtICogNjA7XFxudmFyIGQgPSBoICogMjQ7XFxudmFyIHkgPSBkICogMzY1LjI1O1xcblxcbi8qKlxcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbFxcbiAqIEByZXR1cm4ge3N0cmluZ3xudW1iZXJ9XFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7XFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XFxuICB9XFxuICByZXR1cm4gZm9ybWF0KHZhbCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcbmZ1bmN0aW9uIHBhcnNlIChzdHIpIHtcXG4gIHZhciBtYXRjaCA9ICgvXigoPzpcXFxcZCspP1xcXFwuP1xcXFxkKykgKihtc3xzZWNvbmRzP3xzfG1pbnV0ZXM/fG18aG91cnM/fGh8ZGF5cz98ZHx5ZWFycz98eSk/JC9pKS5leGVjKHN0cik7XFxuICBpZiAoIW1hdGNoKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XFxuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xcbiAgc3dpdGNoICh0eXBlKSB7XFxuICAgIGNhc2UgJ3llYXJzJzpcXG4gICAgY2FzZSAneWVhcic6XFxuICAgIGNhc2UgJ3knOlxcbiAgICAgIHJldHVybiBuICogeTtcXG4gICAgY2FzZSAnZGF5cyc6XFxuICAgIGNhc2UgJ2RheSc6XFxuICAgIGNhc2UgJ2QnOlxcbiAgICAgIHJldHVybiBuICogZDtcXG4gICAgY2FzZSAnaG91cnMnOlxcbiAgICBjYXNlICdob3VyJzpcXG4gICAgY2FzZSAnaCc6XFxuICAgICAgcmV0dXJuIG4gKiBoO1xcbiAgICBjYXNlICdtaW51dGVzJzpcXG4gICAgY2FzZSAnbWludXRlJzpcXG4gICAgY2FzZSAnbSc6XFxuICAgICAgcmV0dXJuIG4gKiBtO1xcbiAgICBjYXNlICdzZWNvbmRzJzpcXG4gICAgY2FzZSAnc2Vjb25kJzpcXG4gICAgY2FzZSAncyc6XFxuICAgICAgcmV0dXJuIG4gKiBzO1xcbiAgICBjYXNlICdtcyc6XFxuICAgICAgcmV0dXJuIG47XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgLy8gTm8gZGVmYXVsdCBjYXNlXFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEZvcm1hdCBmb3IgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBmb3JtYXQgKG1zKSB7XFxuICBpZiAobXMgPj0gZCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xcbiAgfVxcbiAgaWYgKG1zID49IGgpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcXG4gIH1cXG4gIGlmIChtcyA+PSBtKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XFxuICB9XFxuICBpZiAobXMgPj0gcykge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xcbiAgfVxcbiAgcmV0dXJuIG1zICsgJ21zJztcXG59XFxuXFxufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFBlbmRpbmdgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUGVuZGluZztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQZW5kaW5nYCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcXG4gKi9cXG5mdW5jdGlvbiBQZW5kaW5nIChtZXNzYWdlKSB7XFxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xcbn1cXG5cXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgQmFzZVxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xcbnZhciBkaWZmID0gcmVxdWlyZSgnZGlmZicpO1xcbnZhciBtcyA9IHJlcXVpcmUoJy4uL21zJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgc3VwcG9ydHNDb2xvciA9IHByb2Nlc3MuYnJvd3NlciA/IG51bGwgOiByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgQmFzZWAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmFzZTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcuXFxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW9jaGFqcy9tb2NoYS9pc3N1ZXMvMjM3XFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBDaGVjayBpZiBib3RoIHN0ZGlvIHN0cmVhbXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHR0eS5cXG4gKi9cXG5cXG52YXIgaXNhdHR5ID0gdHR5LmlzYXR0eSgxKSAmJiB0dHkuaXNhdHR5KDIpO1xcblxcbi8qKlxcbiAqIEVuYWJsZSBjb2xvcmluZyBieSBkZWZhdWx0LCBleGNlcHQgaW4gdGhlIGJyb3dzZXIgaW50ZXJmYWNlLlxcbiAqL1xcblxcbmV4cG9ydHMudXNlQ29sb3JzID0gIXByb2Nlc3MuYnJvd3NlciAmJiAoc3VwcG9ydHNDb2xvciB8fCAocHJvY2Vzcy5lbnYuTU9DSEFfQ09MT1JTICE9PSB1bmRlZmluZWQpKTtcXG5cXG4vKipcXG4gKiBJbmxpbmUgZGlmZnMgaW5zdGVhZCBvZiArLy1cXG4gKi9cXG5cXG5leHBvcnRzLmlubGluZURpZmZzID0gZmFsc2U7XFxuXFxuLyoqXFxuICogRGVmYXVsdCBjb2xvciBtYXAuXFxuICovXFxuXFxuZXhwb3J0cy5jb2xvcnMgPSB7XFxuICBwYXNzOiA5MCxcXG4gIGZhaWw6IDMxLFxcbiAgJ2JyaWdodCBwYXNzJzogOTIsXFxuICAnYnJpZ2h0IGZhaWwnOiA5MSxcXG4gICdicmlnaHQgeWVsbG93JzogOTMsXFxuICBwZW5kaW5nOiAzNixcXG4gIHN1aXRlOiAwLFxcbiAgJ2Vycm9yIHRpdGxlJzogMCxcXG4gICdlcnJvciBtZXNzYWdlJzogMzEsXFxuICAnZXJyb3Igc3RhY2snOiA5MCxcXG4gIGNoZWNrbWFyazogMzIsXFxuICBmYXN0OiA5MCxcXG4gIG1lZGl1bTogMzMsXFxuICBzbG93OiAzMSxcXG4gIGdyZWVuOiAzMixcXG4gIGxpZ2h0OiA5MCxcXG4gICdkaWZmIGd1dHRlcic6IDkwLFxcbiAgJ2RpZmYgYWRkZWQnOiAzMixcXG4gICdkaWZmIHJlbW92ZWQnOiAzMVxcbn07XFxuXFxuLyoqXFxuICogRGVmYXVsdCBzeW1ib2wgbWFwLlxcbiAqL1xcblxcbmV4cG9ydHMuc3ltYm9scyA9IHtcXG4gIG9rOiAn4pyTJyxcXG4gIGVycjogJ+KclicsXFxuICBkb3Q6ICfigKQnLFxcbiAgY29tbWE6ICcsJyxcXG4gIGJhbmc6ICchJ1xcbn07XFxuXFxuLy8gV2l0aCBub2RlLmpzIG9uIFdpbmRvd3M6IHVzZSBzeW1ib2xzIGF2YWlsYWJsZSBpbiB0ZXJtaW5hbCBkZWZhdWx0IGZvbnRzXFxuaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcXG4gIGV4cG9ydHMuc3ltYm9scy5vayA9ICdcXFxcdTIyMUEnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmVyciA9ICdcXFxcdTAwRDcnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmRvdCA9ICcuJztcXG59XFxuXFxuLyoqXFxuICogQ29sb3IgYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYHR5cGVgLFxcbiAqIGFsbG93aW5nIGNvbG9ycyB0byBiZSBkaXNhYmxlZCxcXG4gKiBhcyB3ZWxsIGFzIHVzZXItZGVmaW5lZCBjb2xvclxcbiAqIHNjaGVtZXMuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxudmFyIGNvbG9yID0gZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uICh0eXBlLCBzdHIpIHtcXG4gIGlmICghZXhwb3J0cy51c2VDb2xvcnMpIHtcXG4gICAgcmV0dXJuIFN0cmluZyhzdHIpO1xcbiAgfVxcbiAgcmV0dXJuICdcXFxcdTAwMWJbJyArIGV4cG9ydHMuY29sb3JzW3R5cGVdICsgJ20nICsgc3RyICsgJ1xcXFx1MDAxYlswbSc7XFxufTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgdGVybSB3aW5kb3cgc2l6ZSwgd2l0aCBzb21lIGRlZmF1bHRzIGZvciB3aGVuIHN0ZGVyciBpcyBub3QgYSB0dHkuXFxuICovXFxuXFxuZXhwb3J0cy53aW5kb3cgPSB7XFxuICB3aWR0aDogNzVcXG59O1xcblxcbmlmIChpc2F0dHkpIHtcXG4gIGV4cG9ydHMud2luZG93LndpZHRoID0gcHJvY2Vzcy5zdGRvdXQuZ2V0V2luZG93U2l6ZVxcbiAgICA/IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemUoMSlbMF1cXG4gICAgOiB0dHkuZ2V0V2luZG93U2l6ZSgpWzFdO1xcbn1cXG5cXG4vKipcXG4gKiBFeHBvc2Ugc29tZSBiYXNpYyBjdXJzb3IgaW50ZXJhY3Rpb25zIHRoYXQgYXJlIGNvbW1vbiBhbW9uZyByZXBvcnRlcnMuXFxuICovXFxuXFxuZXhwb3J0cy5jdXJzb3IgPSB7XFxuICBoaWRlOiBmdW5jdGlvbiAoKSB7XFxuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWz8yNWwnKTtcXG4gIH0sXFxuXFxuICBzaG93OiBmdW5jdGlvbiAoKSB7XFxuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWz8yNWgnKTtcXG4gIH0sXFxuXFxuICBkZWxldGVMaW5lOiBmdW5jdGlvbiAoKSB7XFxuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzJLJyk7XFxuICB9LFxcblxcbiAgYmVnaW5uaW5nT2ZMaW5lOiBmdW5jdGlvbiAoKSB7XFxuICAgIGlzYXR0eSAmJiBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzBHJyk7XFxuICB9LFxcblxcbiAgQ1I6IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGlzYXR0eSkge1xcbiAgICAgIGV4cG9ydHMuY3Vyc29yLmRlbGV0ZUxpbmUoKTtcXG4gICAgICBleHBvcnRzLmN1cnNvci5iZWdpbm5pbmdPZkxpbmUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHInKTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gc2hvd0RpZmYgKGVycikge1xcbiAgcmV0dXJuIGVyciAmJiBlcnIuc2hvd0RpZmYgIT09IGZhbHNlICYmIHNhbWVUeXBlKGVyci5hY3R1YWwsIGVyci5leHBlY3RlZCkgJiYgZXJyLmV4cGVjdGVkICE9PSB1bmRlZmluZWQ7XFxufVxcblxcbmZ1bmN0aW9uIHN0cmluZ2lmeURpZmZPYmpzIChlcnIpIHtcXG4gIGlmICghdXRpbHMuaXNTdHJpbmcoZXJyLmFjdHVhbCkgfHwgIXV0aWxzLmlzU3RyaW5nKGVyci5leHBlY3RlZCkpIHtcXG4gICAgZXJyLmFjdHVhbCA9IHV0aWxzLnN0cmluZ2lmeShlcnIuYWN0dWFsKTtcXG4gICAgZXJyLmV4cGVjdGVkID0gdXRpbHMuc3RyaW5naWZ5KGVyci5leHBlY3RlZCk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBkaWZmIGJldHdlZW4gMiBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXQuXFxuICpcXG4gKiBUaGUgZGlmZiB3aWxsIGJlIGVpdGhlciBpbmxpbmUgb3IgdW5pZmllZCBkZXBlbmRhbnQgb24gdGhlIHZhbHVlXFxuICogb2YgYEJhc2UuaW5saW5lRGlmZmAuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0dWFsXFxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkXFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXFxuICovXFxudmFyIGdlbmVyYXRlRGlmZiA9IGV4cG9ydHMuZ2VuZXJhdGVEaWZmID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gIHJldHVybiBleHBvcnRzLmlubGluZURpZmZzXFxuICAgID8gaW5saW5lRGlmZihhY3R1YWwsIGV4cGVjdGVkKVxcbiAgICA6IHVuaWZpZWREaWZmKGFjdHVhbCwgZXhwZWN0ZWQpO1xcbn07XFxuXFxuLyoqXFxuICogT3V0cHV0IHRoZSBnaXZlbiBgZmFpbHVyZXNgIGFzIGEgbGlzdC5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAdmFyaWF0aW9uIDFcXG4gKiBAcGFyYW0ge0FycmF5fSBmYWlsdXJlc1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZXhwb3J0cy5saXN0ID0gZnVuY3Rpb24gKGZhaWx1cmVzKSB7XFxuICBjb25zb2xlLmxvZygpO1xcbiAgZmFpbHVyZXMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCwgaSkge1xcbiAgICAvLyBmb3JtYXRcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXFxcbicpICtcXG4gICAgICBjb2xvcignZXJyb3IgbWVzc2FnZScsICcgICAgICVzJykgK1xcbiAgICAgIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG5cXG4gICAgLy8gbXNnXFxuICAgIHZhciBtc2c7XFxuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcXG4gICAgdmFyIG1lc3NhZ2U7XFxuICAgIGlmIChlcnIubWVzc2FnZSAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2UgKyAnJztcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBtZXNzYWdlID0gZXJyLmluc3BlY3QoKSArICcnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG1lc3NhZ2UgPSAnJztcXG4gICAgfVxcbiAgICB2YXIgc3RhY2sgPSBlcnIuc3RhY2sgfHwgbWVzc2FnZTtcXG4gICAgdmFyIGluZGV4ID0gbWVzc2FnZSA/IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgOiAtMTtcXG5cXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xcbiAgICAgIG1zZyA9IG1lc3NhZ2U7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaW5kZXggKz0gbWVzc2FnZS5sZW5ndGg7XFxuICAgICAgbXNnID0gc3RhY2suc2xpY2UoMCwgaW5kZXgpO1xcbiAgICAgIC8vIHJlbW92ZSBtc2cgZnJvbSBzdGFja1xcbiAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoaW5kZXggKyAxKTtcXG4gICAgfVxcblxcbiAgICAvLyB1bmNhdWdodFxcbiAgICBpZiAoZXJyLnVuY2F1Z2h0KSB7XFxuICAgICAgbXNnID0gJ1VuY2F1Z2h0ICcgKyBtc2c7XFxuICAgIH1cXG4gICAgLy8gZXhwbGljaXRseSBzaG93IGRpZmZcXG4gICAgaWYgKCFleHBvcnRzLmhpZGVEaWZmICYmIHNob3dEaWZmKGVycikpIHtcXG4gICAgICBzdHJpbmdpZnlEaWZmT2JqcyhlcnIpO1xcbiAgICAgIGZtdCA9IGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXFxcbiVzJykgKyBjb2xvcignZXJyb3Igc3RhY2snLCAnXFxcXG4lc1xcXFxuJyk7XFxuICAgICAgdmFyIG1hdGNoID0gbWVzc2FnZS5tYXRjaCgvXihbXjpdKyk6IGV4cGVjdGVkLyk7XFxuICAgICAgbXNnID0gJ1xcXFxuICAgICAgJyArIGNvbG9yKCdlcnJvciBtZXNzYWdlJywgbWF0Y2ggPyBtYXRjaFsxXSA6IG1zZyk7XFxuXFxuICAgICAgbXNnICs9IGdlbmVyYXRlRGlmZihlcnIuYWN0dWFsLCBlcnIuZXhwZWN0ZWQpO1xcbiAgICB9XFxuXFxuICAgIC8vIGluZGVudCBzdGFjayB0cmFjZVxcbiAgICBzdGFjayA9IHN0YWNrLnJlcGxhY2UoL14vZ20sICcgICcpO1xcblxcbiAgICAvLyBpbmRlbnRlZCB0ZXN0IHRpdGxlXFxuICAgIHZhciB0ZXN0VGl0bGUgPSAnJztcXG4gICAgdGVzdC50aXRsZVBhdGgoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHIsIGluZGV4KSB7XFxuICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XFxuICAgICAgICB0ZXN0VGl0bGUgKz0gJ1xcXFxuICAgICAnO1xcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcXG4gICAgICAgIHRlc3RUaXRsZSArPSAnICAnO1xcbiAgICAgIH1cXG4gICAgICB0ZXN0VGl0bGUgKz0gc3RyO1xcbiAgICB9KTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCAoaSArIDEpLCB0ZXN0VGl0bGUsIG1zZywgc3RhY2spO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBCYXNlYCByZXBvcnRlci5cXG4gKlxcbiAqIEFsbCBvdGhlciByZXBvcnRlcnMgZ2VuZXJhbGx5XFxuICogaW5oZXJpdCBmcm9tIHRoaXMgcmVwb3J0ZXIsIHByb3ZpZGluZ1xcbiAqIHN0YXRzIHN1Y2ggYXMgdGVzdCBkdXJhdGlvbiwgbnVtYmVyXFxuICogb2YgdGVzdHMgcGFzc2VkIC8gZmFpbGVkIGV0Yy5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gQmFzZSAocnVubmVyKSB7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzID0geyBzdWl0ZXM6IDAsIHRlc3RzOiAwLCBwYXNzZXM6IDAsIHBlbmRpbmc6IDAsIGZhaWx1cmVzOiAwIH07XFxuICB2YXIgZmFpbHVyZXMgPSB0aGlzLmZhaWx1cmVzID0gW107XFxuXFxuICBpZiAoIXJ1bm5lcikge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLnJ1bm5lciA9IHJ1bm5lcjtcXG5cXG4gIHJ1bm5lci5zdGF0cyA9IHN0YXRzO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdHMuc3RhcnQgPSBuZXcgRGF0ZSgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIHN0YXRzLnN1aXRlcyA9IHN0YXRzLnN1aXRlcyB8fCAwO1xcbiAgICBzdWl0ZS5yb290IHx8IHN0YXRzLnN1aXRlcysrO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBzdGF0cy50ZXN0cyA9IHN0YXRzLnRlc3RzIHx8IDA7XFxuICAgIHN0YXRzLnRlc3RzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHN0YXRzLnBhc3NlcyA9IHN0YXRzLnBhc3NlcyB8fCAwO1xcblxcbiAgICBpZiAodGVzdC5kdXJhdGlvbiA+IHRlc3Quc2xvdygpKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdzbG93JztcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkgLyAyKSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdtZWRpdW0nO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRlc3Quc3BlZWQgPSAnZmFzdCc7XFxuICAgIH1cXG5cXG4gICAgc3RhdHMucGFzc2VzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgc3RhdHMuZmFpbHVyZXMgPSBzdGF0cy5mYWlsdXJlcyB8fCAwO1xcbiAgICBzdGF0cy5mYWlsdXJlcysrO1xcbiAgICBpZiAoc2hvd0RpZmYoZXJyKSkge1xcbiAgICAgIHN0cmluZ2lmeURpZmZPYmpzKGVycik7XFxuICAgIH1cXG4gICAgdGVzdC5lcnIgPSBlcnI7XFxuICAgIGZhaWx1cmVzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0YXRzLmVuZCA9IG5ldyBEYXRlKCk7XFxuICAgIHN0YXRzLmR1cmF0aW9uID0gc3RhdHMuZW5kIC0gc3RhdHMuc3RhcnQ7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdHMucGVuZGluZysrO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIE91dHB1dCBjb21tb24gZXBpbG9ndWUgdXNlZCBieSBtYW55IG9mXFxuICogdGhlIGJ1bmRsZWQgcmVwb3J0ZXJzLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuQmFzZS5wcm90b3R5cGUuZXBpbG9ndWUgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIGZtdDtcXG5cXG4gIGNvbnNvbGUubG9nKCk7XFxuXFxuICAvLyBwYXNzZXNcXG4gIGZtdCA9IGNvbG9yKCdicmlnaHQgcGFzcycsICcgJykgK1xcbiAgICBjb2xvcignZ3JlZW4nLCAnICVkIHBhc3NpbmcnKSArXFxuICAgIGNvbG9yKCdsaWdodCcsICcgKCVzKScpO1xcblxcbiAgY29uc29sZS5sb2coZm10LFxcbiAgICBzdGF0cy5wYXNzZXMgfHwgMCxcXG4gICAgbXMoc3RhdHMuZHVyYXRpb24pKTtcXG5cXG4gIC8vIHBlbmRpbmdcXG4gIGlmIChzdGF0cy5wZW5kaW5nKSB7XFxuICAgIGZtdCA9IGNvbG9yKCdwZW5kaW5nJywgJyAnKSArXFxuICAgICAgY29sb3IoJ3BlbmRpbmcnLCAnICVkIHBlbmRpbmcnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCBzdGF0cy5wZW5kaW5nKTtcXG4gIH1cXG5cXG4gIC8vIGZhaWx1cmVzXFxuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgZm10ID0gY29sb3IoJ2ZhaWwnLCAnICAlZCBmYWlsaW5nJyk7XFxuXFxuICAgIGNvbnNvbGUubG9nKGZtdCwgc3RhdHMuZmFpbHVyZXMpO1xcblxcbiAgICBCYXNlLmxpc3QodGhpcy5mYWlsdXJlcyk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICB9XFxuXFxuICBjb25zb2xlLmxvZygpO1xcbn07XFxuXFxuLyoqXFxuICogUGFkIHRoZSBnaXZlbiBgc3RyYCB0byBgbGVuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcGFyYW0ge3N0cmluZ30gbGVuXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHBhZCAoc3RyLCBsZW4pIHtcXG4gIHN0ciA9IFN0cmluZyhzdHIpO1xcbiAgcmV0dXJuIEFycmF5KGxlbiAtIHN0ci5sZW5ndGggKyAxKS5qb2luKCcgJykgKyBzdHI7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYW4gaW5saW5lIGRpZmYgYmV0d2VlbiAyIHN0cmluZ3Mgd2l0aCBjb2xvdXJlZCBBTlNJIG91dHB1dC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3R1YWxcXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERpZmZcXG4gKi9cXG5mdW5jdGlvbiBpbmxpbmVEaWZmIChhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICB2YXIgbXNnID0gZXJyb3JEaWZmKGFjdHVhbCwgZXhwZWN0ZWQpO1xcblxcbiAgLy8gbGluZW5vc1xcbiAgdmFyIGxpbmVzID0gbXNnLnNwbGl0KCdcXFxcbicpO1xcbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDQpIHtcXG4gICAgdmFyIHdpZHRoID0gU3RyaW5nKGxpbmVzLmxlbmd0aCkubGVuZ3RoO1xcbiAgICBtc2cgPSBsaW5lcy5tYXAoZnVuY3Rpb24gKHN0ciwgaSkge1xcbiAgICAgIHJldHVybiBwYWQoKytpLCB3aWR0aCkgKyAnIHwnICsgJyAnICsgc3RyO1xcbiAgICB9KS5qb2luKCdcXFxcbicpO1xcbiAgfVxcblxcbiAgLy8gbGVnZW5kXFxuICBtc2cgPSAnXFxcXG4nICtcXG4gICAgY29sb3IoJ2RpZmYgcmVtb3ZlZCcsICdhY3R1YWwnKSArXFxuICAgICcgJyArXFxuICAgIGNvbG9yKCdkaWZmIGFkZGVkJywgJ2V4cGVjdGVkJykgK1xcbiAgICAnXFxcXG5cXFxcbicgK1xcbiAgICBtc2cgK1xcbiAgICAnXFxcXG4nO1xcblxcbiAgLy8gaW5kZW50XFxuICBtc2cgPSBtc2cucmVwbGFjZSgvXi9nbSwgJyAgICAgICcpO1xcbiAgcmV0dXJuIG1zZztcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIHVuaWZpZWQgZGlmZiBiZXR3ZWVuIHR3byBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXFxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGlmZi5cXG4gKi9cXG5mdW5jdGlvbiB1bmlmaWVkRGlmZiAoYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgdmFyIGluZGVudCA9ICcgICAgICAnO1xcbiAgZnVuY3Rpb24gY2xlYW5VcCAobGluZSkge1xcbiAgICBpZiAobGluZVswXSA9PT0gJysnKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCBsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZVswXSA9PT0gJy0nKSB7XFxuICAgICAgcmV0dXJuIGluZGVudCArIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIGxpbmUpO1xcbiAgICB9XFxuICAgIGlmIChsaW5lLm1hdGNoKC9AQC8pKSB7XFxuICAgICAgcmV0dXJuICctLSc7XFxuICAgIH1cXG4gICAgaWYgKGxpbmUubWF0Y2goL1xcXFxcXFxcIE5vIG5ld2xpbmUvKSkge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBpbmRlbnQgKyBsaW5lO1xcbiAgfVxcbiAgZnVuY3Rpb24gbm90QmxhbmsgKGxpbmUpIHtcXG4gICAgcmV0dXJuIHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJyAmJiBsaW5lICE9PSBudWxsO1xcbiAgfVxcbiAgdmFyIG1zZyA9IGRpZmYuY3JlYXRlUGF0Y2goJ3N0cmluZycsIGFjdHVhbCwgZXhwZWN0ZWQpO1xcbiAgdmFyIGxpbmVzID0gbXNnLnNwbGl0KCdcXFxcbicpLnNwbGljZSg1KTtcXG4gIHJldHVybiAnXFxcXG4gICAgICAnICtcXG4gICAgY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsICcrIGV4cGVjdGVkJykgKyAnICcgK1xcbiAgICBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCAnLSBhY3R1YWwnKSArXFxuICAgICdcXFxcblxcXFxuJyArXFxuICAgIGxpbmVzLm1hcChjbGVhblVwKS5maWx0ZXIobm90QmxhbmspLmpvaW4oJ1xcXFxuJyk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIGNoYXJhY3RlciBkaWZmIGZvciBgZXJyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3R1YWxcXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBkaWZmXFxuICovXFxuZnVuY3Rpb24gZXJyb3JEaWZmIChhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICByZXR1cm4gZGlmZi5kaWZmV29yZHNXaXRoU3BhY2UoYWN0dWFsLCBleHBlY3RlZCkubWFwKGZ1bmN0aW9uIChzdHIpIHtcXG4gICAgaWYgKHN0ci5hZGRlZCkge1xcbiAgICAgIHJldHVybiBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgc3RyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBpZiAoc3RyLnJlbW92ZWQpIHtcXG4gICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgc3RyLnZhbHVlKTtcXG4gICAgfVxcbiAgICByZXR1cm4gc3RyLnZhbHVlO1xcbiAgfSkuam9pbignJyk7XFxufVxcblxcbi8qKlxcbiAqIENvbG9yIGxpbmVzIGZvciBgc3RyYCwgdXNpbmcgdGhlIGNvbG9yIGBuYW1lYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBjb2xvckxpbmVzIChuYW1lLCBzdHIpIHtcXG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uIChzdHIpIHtcXG4gICAgcmV0dXJuIGNvbG9yKG5hbWUsIHN0cik7XFxuICB9KS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogQ2hlY2sgdGhhdCBhIC8gYiBoYXZlIHRoZSBzYW1lIHR5cGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gYVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBzYW1lVHlwZSAoYSwgYikge1xcbiAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwoYSkgPT09IG9ialRvU3RyaW5nLmNhbGwoYik7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4uL21zXFxcIjoxNCxcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImRpZmZcXFwiOjQ1LFxcXCJzdXBwb3J0cy1jb2xvclxcXCI6NDAsXFxcInR0eVxcXCI6NH1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBEb2NcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYERvY2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRG9jO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYERvY2AgcmVwb3J0ZXIuXFxuICpcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMge0Jhc2V9XFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbmZ1bmN0aW9uIERvYyAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBpbmRlbnRzID0gMjtcXG5cXG4gIGZ1bmN0aW9uIGluZGVudCAoKSB7XFxuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxzZWN0aW9uIGNsYXNzPVxcXCJzdWl0ZVxcXCI+JywgaW5kZW50KCkpO1xcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczxoMT4lczwvaDE+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZShzdWl0ZS50aXRsZSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXM8ZGw+JywgaW5kZW50KCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBjb25zb2xlLmxvZygnJXM8L2RsPicsIGluZGVudCgpKTtcXG4gICAgLS1pbmRlbnRzO1xcbiAgICBjb25zb2xlLmxvZygnJXM8L3NlY3Rpb24+JywgaW5kZW50KCkpO1xcbiAgICAtLWluZGVudHM7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGR0PiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcXG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZHQgY2xhc3M9XFxcImVycm9yXFxcIj4lczwvZHQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKSk7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuZXNjYXBlKHV0aWxzLmNsZWFuKHRlc3QuYm9keSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZCBjbGFzcz1cXFwiZXJyb3JcXFwiPjxwcmU+PGNvZGU+JXM8L2NvZGU+PC9wcmU+PC9kZD4nLCBpbmRlbnQoKSwgY29kZSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkIGNsYXNzPVxcXCJlcnJvclxcXCI+JXM8L2RkPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoZXJyKSk7XFxuICB9KTtcXG59XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNn1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIERvdFxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIERvdCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC43NSB8IDA7XFxuICB2YXIgbiA9IC0xO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgfVxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncGVuZGluZycsIEJhc2Uuc3ltYm9scy5jb21tYSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIGlmICh0ZXN0LnNwZWVkID09PSAnc2xvdycpIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcignYnJpZ2h0IHllbGxvdycsIEJhc2Uuc3ltYm9scy5kb3QpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcih0ZXN0LnNwZWVkLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdmYWlsJywgQmFzZS5zeW1ib2xzLmJhbmcpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKERvdCwgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyogZXNsaW50LWVudiBicm93c2VyICovXFxuLyoqXFxuICogQG1vZHVsZSBIVE1MXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIFByb2dyZXNzID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9wcm9ncmVzcycpO1xcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XFxudmFyIGVzY2FwZSA9IHV0aWxzLmVzY2FwZTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogRXhwb3NlIGBIVE1MYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBIVE1MO1xcblxcbi8qKlxcbiAqIFN0YXRzIHRlbXBsYXRlLlxcbiAqL1xcblxcbnZhciBzdGF0c1RlbXBsYXRlID0gJzx1bCBpZD1cXFwibW9jaGEtc3RhdHNcXFwiPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPjxjYW52YXMgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIj48L2NhbnZhcz48L2xpPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwicGFzc2VzXFxcIj48YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMCk7XFxcIj5wYXNzZXM6PC9hPiA8ZW0+MDwvZW0+PC9saT4nICtcXG4gICc8bGkgY2xhc3M9XFxcImZhaWx1cmVzXFxcIj48YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMCk7XFxcIj5mYWlsdXJlczo8L2E+IDxlbT4wPC9lbT48L2xpPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwiZHVyYXRpb25cXFwiPmR1cmF0aW9uOiA8ZW0+MDwvZW0+czwvbGk+JyArXFxuICAnPC91bD4nO1xcblxcbnZhciBwbGF5SWNvbiA9ICcmI3gyMDIzOyc7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSFRNTGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gSFRNTCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgc3RhdCA9IGZyYWdtZW50KHN0YXRzVGVtcGxhdGUpO1xcbiAgdmFyIGl0ZW1zID0gc3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKTtcXG4gIHZhciBwYXNzZXMgPSBpdGVtc1sxXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZW0nKVswXTtcXG4gIHZhciBwYXNzZXNMaW5rID0gaXRlbXNbMV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcXG4gIHZhciBmYWlsdXJlcyA9IGl0ZW1zWzJdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIGZhaWx1cmVzTGluayA9IGl0ZW1zWzJdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF07XFxuICB2YXIgZHVyYXRpb24gPSBpdGVtc1szXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZW0nKVswXTtcXG4gIHZhciBjYW52YXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjYW52YXMnKVswXTtcXG4gIHZhciByZXBvcnQgPSBmcmFnbWVudCgnPHVsIGlkPVxcXCJtb2NoYS1yZXBvcnRcXFwiPjwvdWw+Jyk7XFxuICB2YXIgc3RhY2sgPSBbcmVwb3J0XTtcXG4gIHZhciBwcm9ncmVzcztcXG4gIHZhciBjdHg7XFxuICB2YXIgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpO1xcblxcbiAgaWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XFxuICAgIHZhciByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XFxuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aDtcXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XFxuICAgIGNhbnZhcy53aWR0aCAqPSByYXRpbztcXG4gICAgY2FudmFzLmhlaWdodCAqPSByYXRpbztcXG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XFxuICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xcbiAgICBwcm9ncmVzcyA9IG5ldyBQcm9ncmVzcygpO1xcbiAgfVxcblxcbiAgaWYgKCFyb290KSB7XFxuICAgIHJldHVybiBlcnJvcignI21vY2hhIGRpdiBtaXNzaW5nLCBhZGQgaXQgdG8geW91ciBkb2N1bWVudCcpO1xcbiAgfVxcblxcbiAgLy8gcGFzcyB0b2dnbGVcXG4gIG9uKHBhc3Nlc0xpbmssICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIHVuaGlkZSgpO1xcbiAgICB2YXIgbmFtZSA9ICgvcGFzcy8pLnRlc3QocmVwb3J0LmNsYXNzTmFtZSkgPyAnJyA6ICcgcGFzcyc7XFxuICAgIHJlcG9ydC5jbGFzc05hbWUgPSByZXBvcnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ZhaWx8cGFzcy9nLCAnJykgKyBuYW1lO1xcbiAgICBpZiAocmVwb3J0LmNsYXNzTmFtZS50cmltKCkpIHtcXG4gICAgICBoaWRlU3VpdGVzV2l0aG91dCgndGVzdCBwYXNzJyk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gZmFpbHVyZSB0b2dnbGVcXG4gIG9uKGZhaWx1cmVzTGluaywgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgdW5oaWRlKCk7XFxuICAgIHZhciBuYW1lID0gKC9mYWlsLykudGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBmYWlsJztcXG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XFxuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IGZhaWwnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByb290LmFwcGVuZENoaWxkKHN0YXQpO1xcbiAgcm9vdC5hcHBlbmRDaGlsZChyZXBvcnQpO1xcblxcbiAgaWYgKHByb2dyZXNzKSB7XFxuICAgIHByb2dyZXNzLnNpemUoNDApO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBzdWl0ZVxcbiAgICB2YXIgdXJsID0gc2VsZi5zdWl0ZVVSTChzdWl0ZSk7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInN1aXRlXFxcIj48aDE+PGEgaHJlZj1cXFwiJXNcXFwiPiVzPC9hPjwvaDE+PC9saT4nLCB1cmwsIGVzY2FwZShzdWl0ZS50aXRsZSkpO1xcblxcbiAgICAvLyBjb250YWluZXJcXG4gICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xcbiAgICBzdGFjay51bnNoaWZ0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJykpO1xcbiAgICBlbC5hcHBlbmRDaGlsZChzdGFja1swXSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgdXBkYXRlU3RhdHMoKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgc3RhY2suc2hpZnQoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIHVybCA9IHNlbGYudGVzdFVSTCh0ZXN0KTtcXG4gICAgdmFyIG1hcmt1cCA9ICc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyAlZVxcXCI+PGgyPiVlPHNwYW4gY2xhc3M9XFxcImR1cmF0aW9uXFxcIj4lZW1zPC9zcGFuPiAnICtcXG4gICAgICAnPGEgaHJlZj1cXFwiJXNcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPicgKyBwbGF5SWNvbiArICc8L2E+PC9oMj48L2xpPic7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KG1hcmt1cCwgdGVzdC5zcGVlZCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbiwgdXJsKTtcXG4gICAgc2VsZi5hZGRDb2RlVG9nZ2xlKGVsLCB0ZXN0LmJvZHkpO1xcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcXG4gICAgdXBkYXRlU3RhdHMoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQoJzxsaSBjbGFzcz1cXFwidGVzdCBmYWlsXFxcIj48aDI+JWUgPGEgaHJlZj1cXFwiJWVcXFwiIGNsYXNzPVxcXCJyZXBsYXlcXFwiPicgKyBwbGF5SWNvbiArICc8L2E+PC9oMj48L2xpPicsXFxuICAgICAgdGVzdC50aXRsZSwgc2VsZi50ZXN0VVJMKHRlc3QpKTtcXG4gICAgdmFyIHN0YWNrU3RyaW5nOyAvLyBOb3RlOiBJbmNsdWRlcyBsZWFkaW5nIG5ld2xpbmVcXG4gICAgdmFyIG1lc3NhZ2UgPSB0ZXN0LmVyci50b1N0cmluZygpO1xcblxcbiAgICAvLyA8PUlFNyBzdHJpbmdpZmllcyB0byBbT2JqZWN0IEVycm9yXS4gU2luY2UgaXQgY2FuIGJlIG92ZXJsb2FkZWQsIHdlXFxuICAgIC8vIGNoZWNrIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBzdHJpbmdpZnlpbmcuXFxuICAgIGlmIChtZXNzYWdlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XFxuICAgICAgbWVzc2FnZSA9IHRlc3QuZXJyLm1lc3NhZ2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRlc3QuZXJyLnN0YWNrKSB7XFxuICAgICAgdmFyIGluZGV4T2ZNZXNzYWdlID0gdGVzdC5lcnIuc3RhY2suaW5kZXhPZih0ZXN0LmVyci5tZXNzYWdlKTtcXG4gICAgICBpZiAoaW5kZXhPZk1lc3NhZ2UgPT09IC0xKSB7XFxuICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdGFja1N0cmluZyA9IHRlc3QuZXJyLnN0YWNrLnN1YnN0cih0ZXN0LmVyci5tZXNzYWdlLmxlbmd0aCArIGluZGV4T2ZNZXNzYWdlKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuc291cmNlVVJMICYmIHRlc3QuZXJyLmxpbmUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGdpdmUgeW91IGEgc3RhY2suIExldCdzIGF0IGxlYXN0IHByb3ZpZGUgYSBzb3VyY2UgbGluZS5cXG4gICAgICBzdGFja1N0cmluZyA9ICdcXFxcbignICsgdGVzdC5lcnIuc291cmNlVVJMICsgJzonICsgdGVzdC5lcnIubGluZSArICcpJztcXG4gICAgfVxcblxcbiAgICBzdGFja1N0cmluZyA9IHN0YWNrU3RyaW5nIHx8ICcnO1xcblxcbiAgICBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UgJiYgc3RhY2tTdHJpbmcpIHtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBjbGFzcz1cXFwiaHRtbC1lcnJvclxcXCI+JXNcXFxcbjxwcmUgY2xhc3M9XFxcImVycm9yXFxcIj4lZTwvcHJlPjwvZGl2PicsXFxuICAgICAgICB0ZXN0LmVyci5odG1sTWVzc2FnZSwgc3RhY2tTdHJpbmcpKTtcXG4gICAgfSBlbHNlIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSkge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGNsYXNzPVxcXCJodG1sLWVycm9yXFxcIj4lczwvZGl2PicsIHRlc3QuZXJyLmh0bWxNZXNzYWdlKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxwcmUgY2xhc3M9XFxcImVycm9yXFxcIj4lZSVlPC9wcmU+JywgbWVzc2FnZSwgc3RhY2tTdHJpbmcpKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJ0ZXN0IHBhc3MgcGVuZGluZ1xcXCI+PGgyPiVlPC9oMj48L2xpPicsIHRlc3QudGl0bGUpO1xcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcXG4gICAgdXBkYXRlU3RhdHMoKTtcXG4gIH0pO1xcblxcbiAgZnVuY3Rpb24gYXBwZW5kVG9TdGFjayAoZWwpIHtcXG4gICAgLy8gRG9uJ3QgY2FsbCAuYXBwZW5kQ2hpbGQgaWYgI21vY2hhLXJlcG9ydCB3YXMgYWxyZWFkeSAuc2hpZnQoKSdlZCBvZmYgdGhlIHN0YWNrLlxcbiAgICBpZiAoc3RhY2tbMF0pIHtcXG4gICAgICBzdGFja1swXS5hcHBlbmRDaGlsZChlbCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRzICgpIHtcXG4gICAgLy8gVE9ETzogYWRkIHRvIHN0YXRzXFxuICAgIHZhciBwZXJjZW50ID0gc3RhdHMudGVzdHMgLyBydW5uZXIudG90YWwgKiAxMDAgfCAwO1xcbiAgICBpZiAocHJvZ3Jlc3MpIHtcXG4gICAgICBwcm9ncmVzcy51cGRhdGUocGVyY2VudCkuZHJhdyhjdHgpO1xcbiAgICB9XFxuXFxuICAgIC8vIHVwZGF0ZSBzdGF0c1xcbiAgICB2YXIgbXMgPSBuZXcgRGF0ZSgpIC0gc3RhdHMuc3RhcnQ7XFxuICAgIHRleHQocGFzc2VzLCBzdGF0cy5wYXNzZXMpO1xcbiAgICB0ZXh0KGZhaWx1cmVzLCBzdGF0cy5mYWlsdXJlcyk7XFxuICAgIHRleHQoZHVyYXRpb24sIChtcyAvIDEwMDApLnRvRml4ZWQoMikpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBNYWtlcyBhIFVSTCwgcHJlc2VydmluZyBxdWVyeXN0cmluZyAoXFxcInNlYXJjaFxcXCIpIHBhcmFtZXRlcnMuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBuZXcgVVJMLlxcbiAqL1xcbmZ1bmN0aW9uIG1ha2VVcmwgKHMpIHtcXG4gIHZhciBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xcblxcbiAgLy8gUmVtb3ZlIHByZXZpb3VzIGdyZXAgcXVlcnkgcGFyYW1ldGVyIGlmIHByZXNlbnRcXG4gIGlmIChzZWFyY2gpIHtcXG4gICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoL1s/Jl1ncmVwPVteJlxcXFxzXSovZywgJycpLnJlcGxhY2UoL14mLywgJz8nKTtcXG4gIH1cXG5cXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAoc2VhcmNoID8gc2VhcmNoICsgJyYnIDogJz8nKSArICdncmVwPScgKyBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlUmUocykpO1xcbn1cXG5cXG4vKipcXG4gKiBQcm92aWRlIHN1aXRlIFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3VpdGVdXFxuICovXFxuSFRNTC5wcm90b3R5cGUuc3VpdGVVUkwgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHJldHVybiBtYWtlVXJsKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG59O1xcblxcbi8qKlxcbiAqIFByb3ZpZGUgdGVzdCBVUkwuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gW3Rlc3RdXFxuICovXFxuSFRNTC5wcm90b3R5cGUudGVzdFVSTCA9IGZ1bmN0aW9uICh0ZXN0KSB7XFxuICByZXR1cm4gbWFrZVVybCh0ZXN0LmZ1bGxUaXRsZSgpKTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZHMgY29kZSB0b2dnbGUgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIHByb3ZpZGVkIHRlc3QncyBsaXN0IGVsZW1lbnQuXFxuICpcXG4gKiBAcGFyYW0ge0hUTUxMSUVsZW1lbnR9IGVsXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXFxuICovXFxuSFRNTC5wcm90b3R5cGUuYWRkQ29kZVRvZ2dsZSA9IGZ1bmN0aW9uIChlbCwgY29udGVudHMpIHtcXG4gIHZhciBoMiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMicpWzBdO1xcblxcbiAgb24oaDIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJlLnN0eWxlLmRpc3BsYXkgPSBwcmUuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJ2Jsb2NrJyA6ICdub25lJztcXG4gIH0pO1xcblxcbiAgdmFyIHByZSA9IGZyYWdtZW50KCc8cHJlPjxjb2RlPiVlPC9jb2RlPjwvcHJlPicsIHV0aWxzLmNsZWFuKGNvbnRlbnRzKSk7XFxuICBlbC5hcHBlbmRDaGlsZChwcmUpO1xcbiAgcHJlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNwbGF5IGVycm9yIGBtc2dgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xcbiAqL1xcbmZ1bmN0aW9uIGVycm9yIChtc2cpIHtcXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxkaXYgaWQ9XFxcIm1vY2hhLWVycm9yXFxcIj4lczwvZGl2PicsIG1zZykpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBET00gZnJhZ21lbnQgZnJvbSBgaHRtbGAuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxcbiAqL1xcbmZ1bmN0aW9uIGZyYWdtZW50IChodG1sKSB7XFxuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gIHZhciBpID0gMTtcXG5cXG4gIGRpdi5pbm5lckhUTUwgPSBodG1sLnJlcGxhY2UoLyUoW3NlXSkvZywgZnVuY3Rpb24gKF8sIHR5cGUpIHtcXG4gICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgY2FzZSAncyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcXG4gICAgICBjYXNlICdlJzogcmV0dXJuIGVzY2FwZShhcmdzW2krK10pO1xcbiAgICAgIC8vIG5vIGRlZmF1bHRcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrIGZvciBzdWl0ZXMgdGhhdCBkbyBub3QgaGF2ZSBlbGVtZW50c1xcbiAqIHdpdGggYGNsYXNzbmFtZWAsIGFuZCBoaWRlIHRoZW0uXFxuICpcXG4gKiBAcGFyYW0ge3RleHR9IGNsYXNzbmFtZVxcbiAqL1xcbmZ1bmN0aW9uIGhpZGVTdWl0ZXNXaXRob3V0IChjbGFzc25hbWUpIHtcXG4gIHZhciBzdWl0ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzdWl0ZScpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWl0ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGVscyA9IHN1aXRlc1tpXS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzbmFtZSk7XFxuICAgIGlmICghZWxzLmxlbmd0aCkge1xcbiAgICAgIHN1aXRlc1tpXS5jbGFzc05hbWUgKz0gJyBoaWRkZW4nO1xcbiAgICB9XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFVuaGlkZSAuaGlkZGVuIHN1aXRlcy5cXG4gKi9cXG5mdW5jdGlvbiB1bmhpZGUgKCkge1xcbiAgdmFyIGVscyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlIGhpZGRlbicpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyArK2kpIHtcXG4gICAgZWxzW2ldLmNsYXNzTmFtZSA9IGVsc1tpXS5jbGFzc05hbWUucmVwbGFjZSgnc3VpdGUgaGlkZGVuJywgJ3N1aXRlJyk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFNldCBhbiBlbGVtZW50J3MgdGV4dCBjb250ZW50cy5cXG4gKlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRzXFxuICovXFxuZnVuY3Rpb24gdGV4dCAoZWwsIGNvbnRlbnRzKSB7XFxuICBpZiAoZWwudGV4dENvbnRlbnQpIHtcXG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50cztcXG4gIH0gZWxzZSB7XFxuICAgIGVsLmlubmVyVGV4dCA9IGNvbnRlbnRzO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBMaXN0ZW4gb24gYGV2ZW50YCB3aXRoIGNhbGxiYWNrIGBmbmAuXFxuICovXFxuZnVuY3Rpb24gb24gKGVsLCBldmVudCwgZm4pIHtcXG4gIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XFxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBmYWxzZSk7XFxuICB9IGVsc2Uge1xcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZuKTtcXG4gIH1cXG59XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4uL2Jyb3dzZXIvcHJvZ3Jlc3NcXFwiOjMsXFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiZXNjYXBlLXN0cmluZy1yZWdleHBcXFwiOjQ2fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vLyBBbGlhcyBleHBvcnRzIHRvIGEgdGhlaXIgbm9ybWFsaXplZCBmb3JtYXQgTW9jaGEjcmVwb3J0ZXIgdG8gcHJldmVudCBhIG5lZWRcXG4vLyBmb3IgZHluYW1pYyAodHJ5L2NhdGNoKSByZXF1aXJlcywgd2hpY2ggQnJvd3NlcmlmeSBkb2Vzbid0IGhhbmRsZS5cXG5leHBvcnRzLkJhc2UgPSBleHBvcnRzLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5leHBvcnRzLkRvdCA9IGV4cG9ydHMuZG90ID0gcmVxdWlyZSgnLi9kb3QnKTtcXG5leHBvcnRzLkRvYyA9IGV4cG9ydHMuZG9jID0gcmVxdWlyZSgnLi9kb2MnKTtcXG5leHBvcnRzLlRBUCA9IGV4cG9ydHMudGFwID0gcmVxdWlyZSgnLi90YXAnKTtcXG5leHBvcnRzLkpTT04gPSBleHBvcnRzLmpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcXG5leHBvcnRzLkhUTUwgPSBleHBvcnRzLmh0bWwgPSByZXF1aXJlKCcuL2h0bWwnKTtcXG5leHBvcnRzLkxpc3QgPSBleHBvcnRzLmxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKTtcXG5leHBvcnRzLk1pbiA9IGV4cG9ydHMubWluID0gcmVxdWlyZSgnLi9taW4nKTtcXG5leHBvcnRzLlNwZWMgPSBleHBvcnRzLnNwZWMgPSByZXF1aXJlKCcuL3NwZWMnKTtcXG5leHBvcnRzLk55YW4gPSBleHBvcnRzLm55YW4gPSByZXF1aXJlKCcuL255YW4nKTtcXG5leHBvcnRzLlhVbml0ID0gZXhwb3J0cy54dW5pdCA9IHJlcXVpcmUoJy4veHVuaXQnKTtcXG5leHBvcnRzLk1hcmtkb3duID0gZXhwb3J0cy5tYXJrZG93biA9IHJlcXVpcmUoJy4vbWFya2Rvd24nKTtcXG5leHBvcnRzLlByb2dyZXNzID0gZXhwb3J0cy5wcm9ncmVzcyA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3MnKTtcXG5leHBvcnRzLkxhbmRpbmcgPSBleHBvcnRzLmxhbmRpbmcgPSByZXF1aXJlKCcuL2xhbmRpbmcnKTtcXG5leHBvcnRzLkpTT05TdHJlYW0gPSBleHBvcnRzWydqc29uLXN0cmVhbSddID0gcmVxdWlyZSgnLi9qc29uLXN0cmVhbScpO1xcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjE2LFxcXCIuL2RvY1xcXCI6MTcsXFxcIi4vZG90XFxcIjoxOCxcXFwiLi9odG1sXFxcIjoxOSxcXFwiLi9qc29uXFxcIjoyMixcXFwiLi9qc29uLXN0cmVhbVxcXCI6MjEsXFxcIi4vbGFuZGluZ1xcXCI6MjMsXFxcIi4vbGlzdFxcXCI6MjQsXFxcIi4vbWFya2Rvd25cXFwiOjI1LFxcXCIuL21pblxcXCI6MjYsXFxcIi4vbnlhblxcXCI6MjcsXFxcIi4vcHJvZ3Jlc3NcXFwiOjI4LFxcXCIuL3NwZWNcXFwiOjI5LFxcXCIuL3RhcFxcXCI6MzAsXFxcIi4veHVuaXRcXFwiOjMxfV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgSlNPTlN0cmVhbVxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExpc3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSlNPTlN0cmVhbWAgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAbmFtZSBKU09OU3RyZWFtXFxuICogQGNsYXNzIEpTT05TdHJlYW1cXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMaXN0IChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoWydzdGFydCcsIHsgdG90YWw6IHRvdGFsIH1dKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsncGFzcycsIGNsZWFuKHRlc3QpXSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XFxuICAgIHRlc3QgPSBjbGVhbih0ZXN0KTtcXG4gICAgdGVzdC5lcnIgPSBlcnIubWVzc2FnZTtcXG4gICAgdGVzdC5zdGFjayA9IGVyci5zdGFjayB8fCBudWxsO1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ2ZhaWwnLCB0ZXN0XSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShbJ2VuZCcsIHNlbGYuc3RhdHNdKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4gKHRlc3QpIHtcXG4gIHJldHVybiB7XFxuICAgIHRpdGxlOiB0ZXN0LnRpdGxlLFxcbiAgICBmdWxsVGl0bGU6IHRlc3QuZnVsbFRpdGxlKCksXFxuICAgIGR1cmF0aW9uOiB0ZXN0LmR1cmF0aW9uLFxcbiAgICBjdXJyZW50UmV0cnk6IHRlc3QuY3VycmVudFJldHJ5KClcXG4gIH07XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBKU09OXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSlNPTmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSlNPTlJlcG9ydGVyO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEpTT05gIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzcyBKU09OXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gSlNPTlJlcG9ydGVyIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3RzID0gW107XFxuICB2YXIgcGVuZGluZyA9IFtdO1xcbiAgdmFyIGZhaWx1cmVzID0gW107XFxuICB2YXIgcGFzc2VzID0gW107XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgcGFzc2VzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGZhaWx1cmVzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHBlbmRpbmcucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG9iaiA9IHtcXG4gICAgICBzdGF0czogc2VsZi5zdGF0cyxcXG4gICAgICB0ZXN0czogdGVzdHMubWFwKGNsZWFuKSxcXG4gICAgICBwZW5kaW5nOiBwZW5kaW5nLm1hcChjbGVhbiksXFxuICAgICAgZmFpbHVyZXM6IGZhaWx1cmVzLm1hcChjbGVhbiksXFxuICAgICAgcGFzc2VzOiBwYXNzZXMubWFwKGNsZWFuKVxcbiAgICB9O1xcblxcbiAgICBydW5uZXIudGVzdFJlc3VsdHMgPSBvYmo7XFxuXFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMikpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIHBsYWluLW9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBgdGVzdGBcXG4gKiBmcmVlIG9mIGN5Y2xpYyBwcm9wZXJ0aWVzIGV0Yy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0XFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmZ1bmN0aW9uIGNsZWFuICh0ZXN0KSB7XFxuICB2YXIgZXJyID0gdGVzdC5lcnIgfHwge307XFxuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgZXJyID0gZXJyb3JKU09OKGVycik7XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpLFxcbiAgICBlcnI6IGNsZWFuQ3ljbGVzKGVycilcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIFJlcGxhY2VzIGFueSBjaXJjdWxhciByZWZlcmVuY2VzIGluc2lkZSBgb2JqYCB3aXRoICdbb2JqZWN0IE9iamVjdF0nXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmZ1bmN0aW9uIGNsZWFuQ3ljbGVzIChvYmopIHtcXG4gIHZhciBjYWNoZSA9IFtdO1xcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xcbiAgICAgIGlmIChjYWNoZS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZ29pbmcgaW4gYSBjaXJjbGUsIHdlJ2xsIHByaW50IFtvYmplY3QgT2JqZWN0XVxcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH0pKTtcXG59XFxuXFxuLyoqXFxuICogVHJhbnNmb3JtIGFuIEVycm9yIG9iamVjdCBpbnRvIGEgSlNPTiBvYmplY3QuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gZXJyb3JKU09OIChlcnIpIHtcXG4gIHZhciByZXMgPSB7fTtcXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHJlc1trZXldID0gZXJyW2tleV07XFxuICB9LCBlcnIpO1xcbiAgcmV0dXJuIHJlcztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIExhbmRpbmdcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExhbmRpbmdgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExhbmRpbmc7XFxuXFxuLyoqXFxuICogQWlycGxhbmUgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucGxhbmUgPSAwO1xcblxcbi8qKlxcbiAqIEFpcnBsYW5lIGNyYXNoIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzWydwbGFuZSBjcmFzaCddID0gMzE7XFxuXFxuLyoqXFxuICogUnVud2F5IGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnJ1bndheSA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExhbmRpbmdgIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIExhbmRpbmcgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUgfCAwO1xcbiAgdmFyIHRvdGFsID0gcnVubmVyLnRvdGFsO1xcbiAgdmFyIHN0cmVhbSA9IHByb2Nlc3Muc3Rkb3V0O1xcbiAgdmFyIHBsYW5lID0gY29sb3IoJ3BsYW5lJywgJ+KciCcpO1xcbiAgdmFyIGNyYXNoZWQgPSAtMTtcXG4gIHZhciBuID0gMDtcXG5cXG4gIGZ1bmN0aW9uIHJ1bndheSAoKSB7XFxuICAgIHZhciBidWYgPSBBcnJheSh3aWR0aCkuam9pbignLScpO1xcbiAgICByZXR1cm4gJyAgJyArIGNvbG9yKCdydW53YXknLCBidWYpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RyZWFtLndyaXRlKCdcXFxcblxcXFxuXFxcXG4gICcpO1xcbiAgICBjdXJzb3IuaGlkZSgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgLy8gY2hlY2sgaWYgdGhlIHBsYW5lIGNyYXNoZWRcXG4gICAgdmFyIGNvbCA9IGNyYXNoZWQgPT09IC0xID8gd2lkdGggKiArK24gLyB0b3RhbCB8IDAgOiBjcmFzaGVkO1xcblxcbiAgICAvLyBzaG93IHRoZSBjcmFzaFxcbiAgICBpZiAodGVzdC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcXG4gICAgICBwbGFuZSA9IGNvbG9yKCdwbGFuZSBjcmFzaCcsICfinIgnKTtcXG4gICAgICBjcmFzaGVkID0gY29sO1xcbiAgICB9XFxuXFxuICAgIC8vIHJlbmRlciBsYW5kaW5nIHN0cmlwXFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXHUwMDFiWycgKyAod2lkdGggKyAxKSArICdEXFxcXHUwMDFiWzJBJyk7XFxuICAgIHN0cmVhbS53cml0ZShydW53YXkoKSk7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXG4gICcpO1xcbiAgICBzdHJlYW0ud3JpdGUoY29sb3IoJ3J1bndheScsIEFycmF5KGNvbCkuam9pbign4ouFJykpKTtcXG4gICAgc3RyZWFtLndyaXRlKHBsYW5lKTtcXG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheSh3aWR0aCAtIGNvbCkuam9pbign4ouFJykgKyAnXFxcXG4nKSk7XFxuICAgIHN0cmVhbS53cml0ZShydW53YXkoKSk7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXHUwMDFiWzBtJyk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGN1cnNvci5zaG93KCk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhMYW5kaW5nLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBMaXN0XFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBMaXN0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYExpc3RgIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGlzdCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBuID0gMDtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwYXNzJywgJyAgICAnICsgdGVzdC5mdWxsVGl0bGUoKSArICc6ICcpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdjaGVja21hcmsnLCAnICAtJykgK1xcbiAgICAgIGNvbG9yKCdwZW5kaW5nJywgJyAlcycpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZm10ID0gY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcXG4gICAgICBjb2xvcigncGFzcycsICcgJXM6ICcpICtcXG4gICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnJWRtcycpO1xcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LmZ1bGxUaXRsZSgpLCB0ZXN0LmR1cmF0aW9uKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY3Vyc29yLkNSKCk7XFxuICAgIGNvbnNvbGUubG9nKGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC5mdWxsVGl0bGUoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBzZWxmLmVwaWxvZ3VlLmJpbmQoc2VsZikpO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhMaXN0LCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBNYXJrZG93blxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcblxcbi8qKlxcbiAqIENvbnN0YW50c1xcbiAqL1xcblxcbnZhciBTVUlURV9QUkVGSVggPSAnJCc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBNYXJrZG93bmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWFya2Rvd247XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTWFya2Rvd25gIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIE1hcmtkb3duIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIGxldmVsID0gMDtcXG4gIHZhciBidWYgPSAnJztcXG5cXG4gIGZ1bmN0aW9uIHRpdGxlIChzdHIpIHtcXG4gICAgcmV0dXJuIEFycmF5KGxldmVsKS5qb2luKCcjJykgKyAnICcgKyBzdHI7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtYXBUT0MgKHN1aXRlLCBvYmopIHtcXG4gICAgdmFyIHJldCA9IG9iajtcXG4gICAgdmFyIGtleSA9IFNVSVRFX1BSRUZJWCArIHN1aXRlLnRpdGxlO1xcblxcbiAgICBvYmogPSBvYmpba2V5XSA9IG9ialtrZXldIHx8IHsgc3VpdGU6IHN1aXRlIH07XFxuICAgIHN1aXRlLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICAgIG1hcFRPQyhzdWl0ZSwgb2JqKTtcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzdHJpbmdpZnlUT0MgKG9iaiwgbGV2ZWwpIHtcXG4gICAgKytsZXZlbDtcXG4gICAgdmFyIGJ1ZiA9ICcnO1xcbiAgICB2YXIgbGluaztcXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICAgIGlmIChrZXkgPT09ICdzdWl0ZScpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoa2V5ICE9PSBTVUlURV9QUkVGSVgpIHtcXG4gICAgICAgIGxpbmsgPSAnIC0gWycgKyBrZXkuc3Vic3RyaW5nKDEpICsgJ10nO1xcbiAgICAgICAgbGluayArPSAnKCMnICsgdXRpbHMuc2x1ZyhvYmpba2V5XS5zdWl0ZS5mdWxsVGl0bGUoKSkgKyAnKVxcXFxuJztcXG4gICAgICAgIGJ1ZiArPSBBcnJheShsZXZlbCkuam9pbignICAnKSArIGxpbms7XFxuICAgICAgfVxcbiAgICAgIGJ1ZiArPSBzdHJpbmdpZnlUT0Mob2JqW2tleV0sIGxldmVsKTtcXG4gICAgfVxcbiAgICByZXR1cm4gYnVmO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2VuZXJhdGVUT0MgKHN1aXRlKSB7XFxuICAgIHZhciBvYmogPSBtYXBUT0Moc3VpdGUsIHt9KTtcXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRPQyhvYmosIDApO1xcbiAgfVxcblxcbiAgZ2VuZXJhdGVUT0MocnVubmVyLnN1aXRlKTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgKytsZXZlbDtcXG4gICAgdmFyIHNsdWcgPSB1dGlscy5zbHVnKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG4gICAgYnVmICs9ICc8YSBuYW1lPVxcXCInICsgc2x1ZyArICdcXFwiPjwvYT4nICsgJ1xcXFxuJztcXG4gICAgYnVmICs9IHRpdGxlKHN1aXRlLnRpdGxlKSArICdcXFxcbic7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICAtLWxldmVsO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmNsZWFuKHRlc3QuYm9keSk7XFxuICAgIGJ1ZiArPSB0ZXN0LnRpdGxlICsgJy5cXFxcbic7XFxuICAgIGJ1ZiArPSAnXFxcXG5gYGBqc1xcXFxuJztcXG4gICAgYnVmICs9IGNvZGUgKyAnXFxcXG4nO1xcbiAgICBidWYgKz0gJ2BgYFxcXFxuXFxcXG4nO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnIyBUT0NcXFxcbicpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShnZW5lcmF0ZVRPQyhydW5uZXIuc3VpdGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYnVmKTtcXG4gIH0pO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBNaW5cXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1pbmAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTWluO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1pbmAgbWluaW1hbCB0ZXN0IHJlcG9ydGVyIChiZXN0IHVzZWQgd2l0aCAtLXdhdGNoKS5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBNaW4gKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICAvLyBjbGVhciBzY3JlZW5cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsySicpO1xcbiAgICAvLyBzZXQgY3Vyc29yIHBvc2l0aW9uXFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMTszSCcpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgdGhpcy5lcGlsb2d1ZS5iaW5kKHRoaXMpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTWluLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBOeWFuXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE55YW5DYXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG90YCBtYXRyaXggdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3MgTnlhblxcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqL1xcblxcbmZ1bmN0aW9uIE55YW5DYXQgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUgfCAwO1xcbiAgdmFyIG55YW5DYXRXaWR0aCA9IHRoaXMubnlhbkNhdFdpZHRoID0gMTE7XFxuXFxuICB0aGlzLmNvbG9ySW5kZXggPSAwO1xcbiAgdGhpcy5udW1iZXJPZkxpbmVzID0gNDtcXG4gIHRoaXMucmFpbmJvd0NvbG9ycyA9IHNlbGYuZ2VuZXJhdGVDb2xvcnMoKTtcXG4gIHRoaXMuc2NvcmVib2FyZFdpZHRoID0gNTtcXG4gIHRoaXMudGljayA9IDA7XFxuICB0aGlzLnRyYWplY3RvcmllcyA9IFtbXSwgW10sIFtdLCBbXV07XFxuICB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCA9ICh3aWR0aCAtIG55YW5DYXRXaWR0aCk7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBCYXNlLmN1cnNvci5oaWRlKCk7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYuZHJhdygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBCYXNlLmN1cnNvci5zaG93KCk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5udW1iZXJPZkxpbmVzOyBpKyspIHtcXG4gICAgICB3cml0ZSgnXFxcXG4nKTtcXG4gICAgfVxcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTnlhbkNhdCwgQmFzZSk7XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgbnlhbiBjYXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmFwcGVuZFJhaW5ib3coKTtcXG4gIHRoaXMuZHJhd1Njb3JlYm9hcmQoKTtcXG4gIHRoaXMuZHJhd1JhaW5ib3coKTtcXG4gIHRoaXMuZHJhd055YW5DYXQoKTtcXG4gIHRoaXMudGljayA9ICF0aGlzLnRpY2s7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSBcXFwic2NvcmVib2FyZFxcXCIgc2hvd2luZyB0aGUgbnVtYmVyXFxuICogb2YgcGFzc2VzLCBmYWlsdXJlcyBhbmQgcGVuZGluZyB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmRyYXdTY29yZWJvYXJkID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG5cXG4gIGZ1bmN0aW9uIGRyYXcgKHR5cGUsIG4pIHtcXG4gICAgd3JpdGUoJyAnKTtcXG4gICAgd3JpdGUoQmFzZS5jb2xvcih0eXBlLCBuKSk7XFxuICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgfVxcblxcbiAgZHJhdygnZ3JlZW4nLCBzdGF0cy5wYXNzZXMpO1xcbiAgZHJhdygnZmFpbCcsIHN0YXRzLmZhaWx1cmVzKTtcXG4gIGRyYXcoJ3BlbmRpbmcnLCBzdGF0cy5wZW5kaW5nKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogQXBwZW5kIHRoZSByYWluYm93LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuYXBwZW5kUmFpbmJvdyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWdtZW50ID0gdGhpcy50aWNrID8gJ18nIDogJy0nO1xcbiAgdmFyIHJhaW5ib3dpZmllZCA9IHRoaXMucmFpbmJvd2lmeShzZWdtZW50KTtcXG5cXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLm51bWJlck9mTGluZXM7IGluZGV4KyspIHtcXG4gICAgdmFyIHRyYWplY3RvcnkgPSB0aGlzLnRyYWplY3Rvcmllc1tpbmRleF07XFxuICAgIGlmICh0cmFqZWN0b3J5Lmxlbmd0aCA+PSB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCkge1xcbiAgICAgIHRyYWplY3Rvcnkuc2hpZnQoKTtcXG4gICAgfVxcbiAgICB0cmFqZWN0b3J5LnB1c2gocmFpbmJvd2lmaWVkKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIHJhaW5ib3cuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3UmFpbmJvdyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIHRoaXMudHJhamVjdG9yaWVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgc2VsZi5zY29yZWJvYXJkV2lkdGggKyAnQycpO1xcbiAgICB3cml0ZShsaW5lLmpvaW4oJycpKTtcXG4gICAgd3JpdGUoJ1xcXFxuJyk7XFxuICB9KTtcXG5cXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIG55YW4gY2F0XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3TnlhbkNhdCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdGFydFdpZHRoID0gdGhpcy5zY29yZWJvYXJkV2lkdGggKyB0aGlzLnRyYWplY3Rvcmllc1swXS5sZW5ndGg7XFxuICB2YXIgZGlzdCA9ICdcXFxcdTAwMWJbJyArIHN0YXJ0V2lkdGggKyAnQyc7XFxuICB2YXIgcGFkZGluZyA9ICcnO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICB3cml0ZSgnXywtLS0tLS0sJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICcgICcgOiAnICAgJztcXG4gIHdyaXRlKCdffCcgKyBwYWRkaW5nICsgJy9cXFxcXFxcXF8vXFxcXFxcXFwgJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICdfJyA6ICdfXyc7XFxuICB2YXIgdGFpbCA9IHNlbGYudGljayA/ICd+JyA6ICdeJztcXG4gIHdyaXRlKHRhaWwgKyAnfCcgKyBwYWRkaW5nICsgdGhpcy5mYWNlKCkgKyAnICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnICcgOiAnICAnO1xcbiAgd3JpdGUocGFkZGluZyArICdcXFwiXFxcIiAgXFxcIlxcXCIgJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgbnlhbiBjYXQgZmFjZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5mYWNlID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICByZXR1cm4gJyggeCAueCknO1xcbiAgfSBlbHNlIGlmIChzdGF0cy5wZW5kaW5nKSB7XFxuICAgIHJldHVybiAnKCBvIC5vKSc7XFxuICB9IGVsc2UgaWYgKHN0YXRzLnBhc3Nlcykge1xcbiAgICByZXR1cm4gJyggXiAuXiknO1xcbiAgfVxcbiAgcmV0dXJuICcoIC0gLi0pJztcXG59O1xcblxcbi8qKlxcbiAqIE1vdmUgY3Vyc29yIHVwIGBuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuY3Vyc29yVXAgPSBmdW5jdGlvbiAobikge1xcbiAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgbiArICdBJyk7XFxufTtcXG5cXG4vKipcXG4gKiBNb3ZlIGN1cnNvciBkb3duIGBuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuY3Vyc29yRG93biA9IGZ1bmN0aW9uIChuKSB7XFxuICB3cml0ZSgnXFxcXHUwMDFiWycgKyBuICsgJ0InKTtcXG59O1xcblxcbi8qKlxcbiAqIEdlbmVyYXRlIHJhaW5ib3cgY29sb3JzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuTnlhbkNhdC5wcm90b3R5cGUuZ2VuZXJhdGVDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgY29sb3JzID0gW107XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8ICg2ICogNyk7IGkrKykge1xcbiAgICB2YXIgcGkzID0gTWF0aC5mbG9vcihNYXRoLlBJIC8gMyk7XFxuICAgIHZhciBuID0gKGkgKiAoMS4wIC8gNikpO1xcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4pICsgMyk7XFxuICAgIHZhciBnID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obiArIDIgKiBwaTMpICsgMyk7XFxuICAgIHZhciBiID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obiArIDQgKiBwaTMpICsgMyk7XFxuICAgIGNvbG9ycy5wdXNoKDM2ICogciArIDYgKiBnICsgYiArIDE2KTtcXG4gIH1cXG5cXG4gIHJldHVybiBjb2xvcnM7XFxufTtcXG5cXG4vKipcXG4gKiBBcHBseSByYWluYm93IHRvIHRoZSBnaXZlbiBgc3RyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuTnlhbkNhdC5wcm90b3R5cGUucmFpbmJvd2lmeSA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gIGlmICghQmFzZS51c2VDb2xvcnMpIHtcXG4gICAgcmV0dXJuIHN0cjtcXG4gIH1cXG4gIHZhciBjb2xvciA9IHRoaXMucmFpbmJvd0NvbG9yc1t0aGlzLmNvbG9ySW5kZXggJSB0aGlzLnJhaW5ib3dDb2xvcnMubGVuZ3RoXTtcXG4gIHRoaXMuY29sb3JJbmRleCArPSAxO1xcbiAgcmV0dXJuICdcXFxcdTAwMWJbMzg7NTsnICsgY29sb3IgKyAnbScgKyBzdHIgKyAnXFxcXHUwMDFiWzBtJztcXG59O1xcblxcbi8qKlxcbiAqIFN0ZG91dCBoZWxwZXIuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEEgbWVzc2FnZSB0byB3cml0ZSB0byBzdGRvdXQuXFxuICovXFxuZnVuY3Rpb24gd3JpdGUgKHN0cmluZykge1xcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoc3RyaW5nKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgUHJvZ3Jlc3NcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFByb2dyZXNzYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBQcm9ncmVzcztcXG5cXG4vKipcXG4gKiBHZW5lcmFsIHByb2dyZXNzIGJhciBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5wcm9ncmVzcyA9IDkwO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFByb2dyZXNzYCBiYXIgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xcbiAqL1xcbmZ1bmN0aW9uIFByb2dyZXNzIChydW5uZXIsIG9wdGlvbnMpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAwLjUwIHwgMDtcXG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcXG4gIHZhciBjb21wbGV0ZSA9IDA7XFxuICB2YXIgbGFzdE4gPSAtMTtcXG5cXG4gIC8vIGRlZmF1bHQgY2hhcnNcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgdmFyIHJlcG9ydGVyT3B0aW9ucyA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zIHx8IHt9O1xcblxcbiAgb3B0aW9ucy5vcGVuID0gcmVwb3J0ZXJPcHRpb25zLm9wZW4gfHwgJ1snO1xcbiAgb3B0aW9ucy5jb21wbGV0ZSA9IHJlcG9ydGVyT3B0aW9ucy5jb21wbGV0ZSB8fCAn4pasJztcXG4gIG9wdGlvbnMuaW5jb21wbGV0ZSA9IHJlcG9ydGVyT3B0aW9ucy5pbmNvbXBsZXRlIHx8IEJhc2Uuc3ltYm9scy5kb3Q7XFxuICBvcHRpb25zLmNsb3NlID0gcmVwb3J0ZXJPcHRpb25zLmNsb3NlIHx8ICddJztcXG4gIG9wdGlvbnMudmVyYm9zZSA9IHJlcG9ydGVyT3B0aW9ucy52ZXJib3NlIHx8IGZhbHNlO1xcblxcbiAgLy8gdGVzdHMgc3RhcnRlZFxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgY3Vyc29yLmhpZGUoKTtcXG4gIH0pO1xcblxcbiAgLy8gdGVzdHMgY29tcGxldGVcXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbXBsZXRlKys7XFxuXFxuICAgIHZhciBwZXJjZW50ID0gY29tcGxldGUgLyB0b3RhbDtcXG4gICAgdmFyIG4gPSB3aWR0aCAqIHBlcmNlbnQgfCAwO1xcbiAgICB2YXIgaSA9IHdpZHRoIC0gbjtcXG5cXG4gICAgaWYgKG4gPT09IGxhc3ROICYmICFvcHRpb25zLnZlcmJvc2UpIHtcXG4gICAgICAvLyBEb24ndCByZS1yZW5kZXIgdGhlIGxpbmUgaWYgaXQgaGFzbid0IGNoYW5nZWRcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGFzdE4gPSBuO1xcblxcbiAgICBjdXJzb3IuQ1IoKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYltKJyk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgICcgKyBvcHRpb25zLm9wZW4pKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQXJyYXkobikuam9pbihvcHRpb25zLmNvbXBsZXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KGkpLmpvaW4ob3B0aW9ucy5pbmNvbXBsZXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsIG9wdGlvbnMuY2xvc2UpKTtcXG4gICAgaWYgKG9wdGlvbnMudmVyYm9zZSkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwcm9ncmVzcycsICcgJyArIGNvbXBsZXRlICsgJyBvZiAnICsgdG90YWwpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyB0ZXN0cyBhcmUgY29tcGxldGUsIG91dHB1dCBzb21lIHN0YXRzXFxuICAvLyBhbmQgdGhlIGZhaWx1cmVzIGlmIGFueVxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY3Vyc29yLnNob3coKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFByb2dyZXNzLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgU3BlY1xcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBTcGVjYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTcGVjO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFNwZWNgIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gU3BlYyAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBpbmRlbnRzID0gMDtcXG4gIHZhciBuID0gMDtcXG5cXG4gIGZ1bmN0aW9uIGluZGVudCAoKSB7XFxuICAgIHJldHVybiBBcnJheShpbmRlbnRzKS5qb2luKCcgICcpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICArK2luZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKGNvbG9yKCdzdWl0ZScsICclcyVzJyksIGluZGVudCgpLCBzdWl0ZS50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICAtLWluZGVudHM7XFxuICAgIGlmIChpbmRlbnRzID09PSAxKSB7XFxuICAgICAgY29uc29sZS5sb2coKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZm10ID0gaW5kZW50KCkgKyBjb2xvcigncGVuZGluZycsICcgIC0gJXMnKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LnRpdGxlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGZtdDtcXG4gICAgaWYgKHRlc3Quc3BlZWQgPT09ICdmYXN0Jykge1xcbiAgICAgIGZtdCA9IGluZGVudCgpICtcXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXFxuICAgICAgICBjb2xvcigncGFzcycsICcgJXMnKTtcXG4gICAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QudGl0bGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZtdCA9IGluZGVudCgpICtcXG4gICAgICAgIGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXFxuICAgICAgICBjb2xvcigncGFzcycsICcgJXMnKSArXFxuICAgICAgICBjb2xvcih0ZXN0LnNwZWVkLCAnICglZG1zKScpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSwgdGVzdC5kdXJhdGlvbik7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coaW5kZW50KCkgKyBjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgc2VsZi5lcGlsb2d1ZS5iaW5kKHNlbGYpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoU3BlYywgQmFzZSk7XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNn1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBUQVBcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBUQVBgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFRBUDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBUQVBgIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFRBUCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBuID0gMTtcXG4gIHZhciBwYXNzZXMgPSAwO1xcbiAgdmFyIGZhaWx1cmVzID0gMDtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0b3RhbCA9IHJ1bm5lci5ncmVwVG90YWwocnVubmVyLnN1aXRlKTtcXG4gICAgY29uc29sZS5sb2coJyVkLi4lZCcsIDEsIHRvdGFsKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgKytuO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjb25zb2xlLmxvZygnb2sgJWQgJXMgIyBTS0lQIC0nLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHBhc3NlcysrO1xcbiAgICBjb25zb2xlLmxvZygnb2sgJWQgJXMnLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgZmFpbHVyZXMrKztcXG4gICAgY29uc29sZS5sb2coJ25vdCBvayAlZCAlcycsIG4sIHRpdGxlKHRlc3QpKTtcXG4gICAgaWYgKGVyci5zdGFjaykge1xcbiAgICAgIGNvbnNvbGUubG9nKGVyci5zdGFjay5yZXBsYWNlKC9eL2dtLCAnICAnKSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coJyMgdGVzdHMgJyArIChwYXNzZXMgKyBmYWlsdXJlcykpO1xcbiAgICBjb25zb2xlLmxvZygnIyBwYXNzICcgKyBwYXNzZXMpO1xcbiAgICBjb25zb2xlLmxvZygnIyBmYWlsICcgKyBmYWlsdXJlcyk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgVEFQLXNhZmUgdGl0bGUgb2YgYHRlc3RgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge1N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiB0aXRsZSAodGVzdCkge1xcbiAgcmV0dXJuIHRlc3QuZnVsbFRpdGxlKCkucmVwbGFjZSgvIy9nLCAnJyk7XFxufVxcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjE2fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFhVbml0XFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcbnZhciBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogRXhwb3NlIGBYVW5pdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gWFVuaXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgWFVuaXRgIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFhVbml0IChydW5uZXIsIG9wdGlvbnMpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciB0ZXN0cyA9IFtdO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgLy8gdGhlIG5hbWUgb2YgdGhlIHRlc3Qgc3VpdGUsIGFzIGl0IHdpbGwgYXBwZWFyIGluIHRoZSByZXN1bHRpbmcgWE1MIGZpbGVcXG4gIHZhciBzdWl0ZU5hbWU7XFxuXFxuICAvLyB0aGUgZGVmYXVsdCBuYW1lIG9mIHRoZSB0ZXN0IHN1aXRlIGlmIG5vbmUgaXMgcHJvdmlkZWRcXG4gIHZhciBERUZBVUxUX1NVSVRFX05BTUUgPSAnTW9jaGEgVGVzdHMnO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMpIHtcXG4gICAgaWYgKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkge1xcbiAgICAgIGlmICghZnMuY3JlYXRlV3JpdGVTdHJlYW0pIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZSBvdXRwdXQgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XFxuICAgICAgfVxcblxcbiAgICAgIG1rZGlycC5zeW5jKHBhdGguZGlybmFtZShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpKTtcXG4gICAgICBzZWxmLmZpbGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpO1xcbiAgICB9XFxuXFxuICAgIC8vIGdldCB0aGUgc3VpdGUgbmFtZSBmcm9tIHRoZSByZXBvcnRlciBvcHRpb25zIChpZiBwcm92aWRlZClcXG4gICAgc3VpdGVOYW1lID0gb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMuc3VpdGVOYW1lO1xcbiAgfVxcblxcbiAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IHN1aXRlIG5hbWVcXG4gIHN1aXRlTmFtZSA9IHN1aXRlTmFtZSB8fCBERUZBVUxUX1NVSVRFX05BTUU7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBzZWxmLndyaXRlKHRhZygndGVzdHN1aXRlJywge1xcbiAgICAgIG5hbWU6IHN1aXRlTmFtZSxcXG4gICAgICB0ZXN0czogc3RhdHMudGVzdHMsXFxuICAgICAgZmFpbHVyZXM6IHN0YXRzLmZhaWx1cmVzLFxcbiAgICAgIGVycm9yczogc3RhdHMuZmFpbHVyZXMsXFxuICAgICAgc2tpcHBlZDogc3RhdHMudGVzdHMgLSBzdGF0cy5mYWlsdXJlcyAtIHN0YXRzLnBhc3NlcyxcXG4gICAgICB0aW1lc3RhbXA6IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpLFxcbiAgICAgIHRpbWU6IChzdGF0cy5kdXJhdGlvbiAvIDEwMDApIHx8IDBcXG4gICAgfSwgZmFsc2UpKTtcXG5cXG4gICAgdGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xcbiAgICAgIHNlbGYudGVzdCh0KTtcXG4gICAgfSk7XFxuXFxuICAgIHNlbGYud3JpdGUoJzwvdGVzdHN1aXRlPicpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFhVbml0LCBCYXNlKTtcXG5cXG4vKipcXG4gKiBPdmVycmlkZSBkb25lIHRvIGNsb3NlIHRoZSBzdHJlYW0gKGlmIGl0J3MgYSBmaWxlKS5cXG4gKlxcbiAqIEBwYXJhbSBmYWlsdXJlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuWFVuaXQucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGZuKSB7XFxuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XFxuICAgIHRoaXMuZmlsZVN0cmVhbS5lbmQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGZuKGZhaWx1cmVzKTtcXG4gICAgfSk7XFxuICB9IGVsc2Uge1xcbiAgICBmbihmYWlsdXJlcyk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBXcml0ZSBvdXQgdGhlIGdpdmVuIGxpbmUuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZVxcbiAqL1xcblhVbml0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XFxuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XFxuICAgIHRoaXMuZmlsZVN0cmVhbS53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnN0ZG91dCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2Uge1xcbiAgICBjb25zb2xlLmxvZyhsaW5lKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIE91dHB1dCB0YWcgZm9yIHRoZSBnaXZlbiBgdGVzdC5gXFxuICpcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh0ZXN0KSB7XFxuICB2YXIgYXR0cnMgPSB7XFxuICAgIGNsYXNzbmFtZTogdGVzdC5wYXJlbnQuZnVsbFRpdGxlKCksXFxuICAgIG5hbWU6IHRlc3QudGl0bGUsXFxuICAgIHRpbWU6ICh0ZXN0LmR1cmF0aW9uIC8gMTAwMCkgfHwgMFxcbiAgfTtcXG5cXG4gIGlmICh0ZXN0LnN0YXRlID09PSAnZmFpbGVkJykge1xcbiAgICB2YXIgZXJyID0gdGVzdC5lcnI7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdmYWlsdXJlJywge30sIGZhbHNlLCBlc2NhcGUoZXJyLm1lc3NhZ2UpICsgJ1xcXFxuJyArIGVzY2FwZShlcnIuc3RhY2spKSkpO1xcbiAgfSBlbHNlIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdza2lwcGVkJywge30sIHRydWUpKSk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgdHJ1ZSkpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSFRNTCB0YWcgaGVscGVyLlxcbiAqXFxuICogQHBhcmFtIG5hbWVcXG4gKiBAcGFyYW0gYXR0cnNcXG4gKiBAcGFyYW0gY2xvc2VcXG4gKiBAcGFyYW0gY29udGVudFxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiB0YWcgKG5hbWUsIGF0dHJzLCBjbG9zZSwgY29udGVudCkge1xcbiAgdmFyIGVuZCA9IGNsb3NlID8gJy8+JyA6ICc+JztcXG4gIHZhciBwYWlycyA9IFtdO1xcbiAgdmFyIHRhZztcXG5cXG4gIGZvciAodmFyIGtleSBpbiBhdHRycykge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzLCBrZXkpKSB7XFxuICAgICAgcGFpcnMucHVzaChrZXkgKyAnPVxcXCInICsgZXNjYXBlKGF0dHJzW2tleV0pICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdGFnID0gJzwnICsgbmFtZSArIChwYWlycy5sZW5ndGggPyAnICcgKyBwYWlycy5qb2luKCcgJykgOiAnJykgKyBlbmQ7XFxuICBpZiAoY29udGVudCkge1xcbiAgICB0YWcgKz0gY29udGVudCArICc8LycgKyBuYW1lICsgZW5kO1xcbiAgfVxcbiAgcmV0dXJuIHRhZztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM2LFxcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImZzXFxcIjo0MCxcXFwibWtkaXJwXFxcIjo1MyxcXFwicGF0aFxcXCI6NDB9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFJ1bm5hYmxlXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBQZW5kaW5nID0gcmVxdWlyZSgnLi9wZW5kaW5nJyk7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmFibGUnKTtcXG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi9tcycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogT2JqZWN0I3RvU3RyaW5nKCkuXFxuICovXFxuXFxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFJ1bm5hYmxlYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5hYmxlO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJ1bm5hYmxlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gLiAgRGVyaXZlZCBmcm9tIFtFdmVudEVtaXR0ZXJdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50ZW1pdHRlcilcXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFJ1bm5hYmxlICh0aXRsZSwgZm4pIHtcXG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcXG4gIHRoaXMuZm4gPSBmbjtcXG4gIHRoaXMuYm9keSA9IChmbiB8fCAnJykudG9TdHJpbmcoKTtcXG4gIHRoaXMuYXN5bmMgPSBmbiAmJiBmbi5sZW5ndGg7XFxuICB0aGlzLnN5bmMgPSAhdGhpcy5hc3luYztcXG4gIHRoaXMuX3RpbWVvdXQgPSAyMDAwO1xcbiAgdGhpcy5fc2xvdyA9IDc1O1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSB0cnVlO1xcbiAgdGhpcy50aW1lZE91dCA9IGZhbHNlO1xcbiAgdGhpcy5fcmV0cmllcyA9IC0xO1xcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gMDtcXG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcbnV0aWxzLmluaGVyaXRzKFJ1bm5hYmxlLCBFdmVudEVtaXR0ZXIpO1xcblxcbi8qKlxcbiAqIFNldCAmIGdldCB0aW1lb3V0IGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7UnVubmFibGV8bnVtYmVyfSBtcyBvciBSdW5uYWJsZSBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xcbiAgfVxcbiAgLy8gc2VlICMxNjUyIGZvciByZWFzb25pbmdcXG4gIGlmIChtcyA9PT0gMCB8fCBtcyA+IE1hdGgucG93KDIsIDMxKSkge1xcbiAgICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGZhbHNlO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3RpbWVvdXQgJWQnLCBtcyk7XFxuICB0aGlzLl90aW1lb3V0ID0gbXM7XFxuICBpZiAodGhpcy50aW1lcikge1xcbiAgICB0aGlzLnJlc2V0VGltZW91dCgpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHNsb3cgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxudW1iZXJ9IG1zIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgdHlwZW9mIG1zID09PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gdGhpcy5fc2xvdztcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCdzbG93ICVkJywgbXMpO1xcbiAgdGhpcy5fc2xvdyA9IG1zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgYW5kIGdldCB3aGV0aGVyIHRpbWVvdXQgaXMgYGVuYWJsZWRgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7UnVubmFibGV8Ym9vbGVhbn0gZW5hYmxlZCBvciBSdW5uYWJsZSBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbmFibGVUaW1lb3V0cztcXG4gIH1cXG4gIGRlYnVnKCdlbmFibGVUaW1lb3V0cyAlcycsIGVuYWJsZWQpO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBlbmFibGVkO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBIYWx0IGFuZCBtYXJrIGFzIHBlbmRpbmcuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRocm93IG5ldyBQZW5kaW5nKCdzeW5jIHNraXAnKTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHRoaXMgcnVubmFibGUgb3IgaXRzIHBhcmVudCBzdWl0ZSBpcyBtYXJrZWQgYXMgcGVuZGluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5wZW5kaW5nIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1BlbmRpbmcoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoaXMgUnVubmFibGUgaGFzIGZhaWxlZC5cXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqIEBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmlzRmFpbGVkID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuICF0aGlzLmlzUGVuZGluZygpICYmIHRoaXMuc3RhdGUgPT09ICdmYWlsZWQnO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGlzIFJ1bm5hYmxlIGhhcyBwYXNzZWQuXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pc1Bhc3NlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiAhdGhpcy5pc1BlbmRpbmcoKSAmJiB0aGlzLnN0YXRlID09PSAncGFzc2VkJztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgbnVtYmVyIG9mIHJldHJpZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XFxuICB9XFxuICB0aGlzLl9yZXRyaWVzID0gbjtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgY3VycmVudCByZXRyeVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmN1cnJlbnRSZXRyeSA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXRyeTtcXG4gIH1cXG4gIHRoaXMuX2N1cnJlbnRSZXRyeSA9IG47XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXFxuICogZnVsbCB0aXRsZS5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uYWJsZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZnVsbFRpdGxlID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMudGl0bGVQYXRoKCkuam9pbignICcpO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSB0aXRsZSBwYXRoIGdlbmVyYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQncyB0aXRsZSBwYXRoIHdpdGggdGhlIHRpdGxlLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5hYmxlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS50aXRsZVBhdGggPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5wYXJlbnQudGl0bGVQYXRoKCkuY29uY2F0KFt0aGlzLnRpdGxlXSk7XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhciB0aGUgdGltZW91dC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XFxuICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XFxufTtcXG5cXG4vKipcXG4gKiBJbnNwZWN0IHRoZSBydW5uYWJsZSB2b2lkIG9mIHByaXZhdGUgcHJvcGVydGllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcXG4gICAgaWYgKGtleVswXSA9PT0gJ18nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChrZXkgPT09ICdwYXJlbnQnKSB7XFxuICAgICAgcmV0dXJuICcjPFN1aXRlPic7XFxuICAgIH1cXG4gICAgaWYgKGtleSA9PT0gJ2N0eCcpIHtcXG4gICAgICByZXR1cm4gJyM8Q29udGV4dD4nO1xcbiAgICB9XFxuICAgIHJldHVybiB2YWw7XFxuICB9LCAyKTtcXG59O1xcblxcbi8qKlxcbiAqIFJlc2V0IHRoZSB0aW1lb3V0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnJlc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBtcyA9IHRoaXMudGltZW91dCgpIHx8IDFlOTtcXG5cXG4gIGlmICghdGhpcy5fZW5hYmxlVGltZW91dHMpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcXG4gIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFzZWxmLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzZWxmLmNhbGxiYWNrKHNlbGYuX3RpbWVvdXRFcnJvcihtcykpO1xcbiAgICBzZWxmLnRpbWVkT3V0ID0gdHJ1ZTtcXG4gIH0sIG1zKTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgYSBsaXN0IG9mIHdoaXRlbGlzdGVkIGdsb2JhbHMgZm9yIHRoaXMgdGVzdCBydW4uXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBnbG9iYWxzXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoZ2xvYmFscykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9hbGxvd2VkR2xvYmFscztcXG4gIH1cXG4gIHRoaXMuX2FsbG93ZWRHbG9iYWxzID0gZ2xvYmFscztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0aGUgdGVzdCBhbmQgaW52b2tlIGBmbihlcnIpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcXG4gIHZhciBjdHggPSB0aGlzLmN0eDtcXG4gIHZhciBmaW5pc2hlZDtcXG4gIHZhciBlbWl0dGVkO1xcblxcbiAgLy8gU29tZXRpbWVzIHRoZSBjdHggZXhpc3RzLCBidXQgaXQgaXMgbm90IHJ1bm5hYmxlXFxuICBpZiAoY3R4ICYmIGN0eC5ydW5uYWJsZSkge1xcbiAgICBjdHgucnVubmFibGUodGhpcyk7XFxuICB9XFxuXFxuICAvLyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcXG4gIGZ1bmN0aW9uIG11bHRpcGxlIChlcnIpIHtcXG4gICAgaWYgKGVtaXR0ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZW1pdHRlZCA9IHRydWU7XFxuICAgIHZhciBtc2cgPSAnZG9uZSgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyc7XFxuICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHtcXG4gICAgICBlcnIubWVzc2FnZSArPSBcXFwiIChhbmQgTW9jaGEncyBcXFwiICsgbXNnICsgJyknO1xcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobXNnKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGZpbmlzaGVkXFxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcXG4gICAgdmFyIG1zID0gc2VsZi50aW1lb3V0KCk7XFxuICAgIGlmIChzZWxmLnRpbWVkT3V0KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChmaW5pc2hlZCkge1xcbiAgICAgIHJldHVybiBtdWx0aXBsZShlcnIpO1xcbiAgICB9XFxuXFxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KCk7XFxuICAgIHNlbGYuZHVyYXRpb24gPSBuZXcgRGF0ZSgpIC0gc3RhcnQ7XFxuICAgIGZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgaWYgKCFlcnIgJiYgc2VsZi5kdXJhdGlvbiA+IG1zICYmIHNlbGYuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgICAgZXJyID0gc2VsZi5fdGltZW91dEVycm9yKG1zKTtcXG4gICAgfVxcbiAgICBmbihlcnIpO1xcbiAgfVxcblxcbiAgLy8gZm9yIC5yZXNldFRpbWVvdXQoKVxcbiAgdGhpcy5jYWxsYmFjayA9IGRvbmU7XFxuXFxuICAvLyBleHBsaWNpdCBhc3luYyB3aXRoIGBkb25lYCBhcmd1bWVudFxcbiAgaWYgKHRoaXMuYXN5bmMpIHtcXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcXG5cXG4gICAgLy8gYWxsb3dzIHNraXAoKSB0byBiZSB1c2VkIGluIGFuIGV4cGxpY2l0IGFzeW5jIGNvbnRleHRcXG4gICAgdGhpcy5za2lwID0gZnVuY3Rpb24gYXN5bmNTa2lwICgpIHtcXG4gICAgICBkb25lKG5ldyBQZW5kaW5nKCdhc3luYyBza2lwIGNhbGwnKSk7XFxuICAgICAgLy8gaGFsdCBleGVjdXRpb24uICB0aGUgUnVubmFibGUgd2lsbCBiZSBtYXJrZWQgcGVuZGluZ1xcbiAgICAgIC8vIGJ5IHRoZSBwcmV2aW91cyBjYWxsLCBhbmQgdGhlIHVuY2F1Z2h0IGhhbmRsZXIgd2lsbCBpZ25vcmVcXG4gICAgICAvLyB0aGUgZmFpbHVyZS5cXG4gICAgICB0aHJvdyBuZXcgUGVuZGluZygnYXN5bmMgc2tpcDsgYWJvcnRpbmcgZXhlY3V0aW9uJyk7XFxuICAgIH07XFxuXFxuICAgIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgICByZXR1cm4gY2FsbEZuQXN5bmModGhpcy5mbik7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICBjYWxsRm5Bc3luYyh0aGlzLmZuKTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgZW1pdHRlZCA9IHRydWU7XFxuICAgICAgZG9uZSh1dGlscy5nZXRFcnJvcihlcnIpKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgICAgZG9uZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbGxGbih0aGlzLmZuKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBzeW5jIG9yIHByb21pc2UtcmV0dXJuaW5nXFxuICB0cnkge1xcbiAgICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICAgIGRvbmUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjYWxsRm4odGhpcy5mbik7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgZG9uZSh1dGlscy5nZXRFcnJvcihlcnIpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNhbGxGbiAoZm4pIHtcXG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4KTtcXG4gICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBzZWxmLnJlc2V0VGltZW91dCgpO1xcbiAgICAgIHJlc3VsdFxcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBkb25lKCk7XFxuICAgICAgICAgIC8vIFJldHVybiBudWxsIHNvIGxpYnJhcmllcyBsaWtlIGJsdWViaXJkIGRvIG5vdCB3YXJuIGFib3V0XFxuICAgICAgICAgIC8vIHN1YnNlcXVlbnRseSBjb25zdHJ1Y3RlZCBQcm9taXNlcy5cXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9LFxcbiAgICAgICAgZnVuY3Rpb24gKHJlYXNvbikge1xcbiAgICAgICAgICBkb25lKHJlYXNvbiB8fCBuZXcgRXJyb3IoJ1Byb21pc2UgcmVqZWN0ZWQgd2l0aCBubyBvciBmYWxzeSByZWFzb24nKSk7XFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoc2VsZi5hc3luY09ubHkpIHtcXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignLS1hc3luYy1vbmx5IG9wdGlvbiBpbiB1c2Ugd2l0aG91dCBkZWNsYXJpbmcgYGRvbmUoKWAgb3IgcmV0dXJuaW5nIGEgcHJvbWlzZScpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9uZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjYWxsRm5Bc3luYyAoZm4pIHtcXG4gICAgdmFyIHJlc3VsdCA9IGZuLmNhbGwoY3R4LCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICtcXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShlcnIpKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2RvbmUoKSBpbnZva2VkIHdpdGggbm9uLUVycm9yOiAnICsgZXJyKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChyZXN1bHQgJiYgdXRpbHMuaXNQcm9taXNlKHJlc3VsdCkpIHtcXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignUmVzb2x1dGlvbiBtZXRob2QgaXMgb3ZlcnNwZWNpZmllZC4gU3BlY2lmeSBhIGNhbGxiYWNrICpvciogcmV0dXJuIGEgUHJvbWlzZTsgbm90IGJvdGguJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb25lKCk7XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSW5zdGFudGlhdGVzIGEgXFxcInRpbWVvdXRcXFwiIGVycm9yXFxuICpcXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgLSBUaW1lb3V0IChpbiBtaWxsaXNlY29uZHMpXFxuICogQHJldHVybnMge0Vycm9yfSBhIFxcXCJ0aW1lb3V0XFxcIiBlcnJvclxcbiAqIEBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbiAobXMpIHtcXG4gIHZhciBtc2cgPSAnVGltZW91dCBvZiAnICsgbXMgKyAnbXMgZXhjZWVkZWQuIEZvciBhc3luYyB0ZXN0cyBhbmQgaG9va3MsIGVuc3VyZSBcXFwiZG9uZSgpXFxcIiBpcyBjYWxsZWQ7IGlmIHJldHVybmluZyBhIFByb21pc2UsIGVuc3VyZSBpdCByZXNvbHZlcy4nO1xcbiAgaWYgKHRoaXMuZmlsZSkge1xcbiAgICBtc2cgKz0gJyAoJyArIHRoaXMuZmlsZSArICcpJztcXG4gIH1cXG4gIHJldHVybiBuZXcgRXJyb3IobXNnKTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL21zXFxcIjoxNCxcXFwiLi9wZW5kaW5nXFxcIjoxNSxcXFwiLi91dGlsc1xcXCI6MzYsXFxcImRlYnVnXFxcIjo0MyxcXFwiZXZlbnRzXFxcIjo0N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogQG1vZHVsZSBSdW5uZXJcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIFBlbmRpbmcgPSByZXF1aXJlKCcuL3BlbmRpbmcnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmVyJyk7XFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciBzdGFja0ZpbHRlciA9IHV0aWxzLnN0YWNrVHJhY2VGaWx0ZXIoKTtcXG52YXIgc3RyaW5naWZ5ID0gdXRpbHMuc3RyaW5naWZ5O1xcbnZhciB0eXBlID0gdXRpbHMudHlwZTtcXG52YXIgdW5kZWZpbmVkRXJyb3IgPSB1dGlscy51bmRlZmluZWRFcnJvcjtcXG5cXG4vKipcXG4gKiBOb24tZW51bWVyYWJsZSBnbG9iYWxzLlxcbiAqL1xcblxcbnZhciBnbG9iYWxzID0gW1xcbiAgJ3NldFRpbWVvdXQnLFxcbiAgJ2NsZWFyVGltZW91dCcsXFxuICAnc2V0SW50ZXJ2YWwnLFxcbiAgJ2NsZWFySW50ZXJ2YWwnLFxcbiAgJ1hNTEh0dHBSZXF1ZXN0JyxcXG4gICdEYXRlJyxcXG4gICdzZXRJbW1lZGlhdGUnLFxcbiAgJ2NsZWFySW1tZWRpYXRlJ1xcbl07XFxuXFxuLyoqXFxuICogRXhwb3NlIGBSdW5uZXJgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUnVubmVyO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBgUnVubmVyYCBmb3IgdGhlIGdpdmVuIGBzdWl0ZWAuIERlcml2ZWQgZnJvbSBbRXZlbnRFbWl0dGVyXShodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXIpXFxuICpcXG4gKiBFdmVudHM6XFxuICpcXG4gKiAgIC0gYHN0YXJ0YCAgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYGVuZGAgIGV4ZWN1dGlvbiBjb21wbGV0ZVxcbiAqICAgLSBgc3VpdGVgICAoc3VpdGUpIHRlc3Qgc3VpdGUgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYHN1aXRlIGVuZGAgIChzdWl0ZSkgYWxsIHRlc3RzIChhbmQgc3ViLXN1aXRlcykgaGF2ZSBmaW5pc2hlZFxcbiAqICAgLSBgdGVzdGAgICh0ZXN0KSB0ZXN0IGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGB0ZXN0IGVuZGAgICh0ZXN0KSB0ZXN0IGNvbXBsZXRlZFxcbiAqICAgLSBgaG9va2AgIChob29rKSBob29rIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBob29rIGVuZGAgIChob29rKSBob29rIGNvbXBsZXRlXFxuICogICAtIGBwYXNzYCAgKHRlc3QpIHRlc3QgcGFzc2VkXFxuICogICAtIGBmYWlsYCAgKHRlc3QsIGVycikgdGVzdCBmYWlsZWRcXG4gKiAgIC0gYHBlbmRpbmdgICAodGVzdCkgdGVzdCBwZW5kaW5nXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBbc3VpdGVdIFJvb3Qgc3VpdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWxheV0gV2hldGhlciBvciBub3QgdG8gZGVsYXkgZXhlY3V0aW9uIG9mIHJvb3Qgc3VpdGVcXG4gKiB1bnRpbCByZWFkeS5cXG4gKi9cXG5mdW5jdGlvbiBSdW5uZXIgKHN1aXRlLCBkZWxheSkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdGhpcy5fZ2xvYmFscyA9IFtdO1xcbiAgdGhpcy5fYWJvcnQgPSBmYWxzZTtcXG4gIHRoaXMuX2RlbGF5ID0gZGVsYXk7XFxuICB0aGlzLnN1aXRlID0gc3VpdGU7XFxuICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcXG4gIHRoaXMudG90YWwgPSBzdWl0ZS50b3RhbCgpO1xcbiAgdGhpcy5mYWlsdXJlcyA9IDA7XFxuICB0aGlzLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHNlbGYuY2hlY2tHbG9iYWxzKHRlc3QpO1xcbiAgfSk7XFxuICB0aGlzLm9uKCdob29rIGVuZCcsIGZ1bmN0aW9uIChob29rKSB7XFxuICAgIHNlbGYuY2hlY2tHbG9iYWxzKGhvb2spO1xcbiAgfSk7XFxuICB0aGlzLl9kZWZhdWx0R3JlcCA9IC8uKi87XFxuICB0aGlzLmdyZXAodGhpcy5fZGVmYXVsdEdyZXApO1xcbiAgdGhpcy5nbG9iYWxzKHRoaXMuZ2xvYmFsUHJvcHMoKS5jb25jYXQoZXh0cmFHbG9iYWxzKCkpKTtcXG59XFxuXFxuLyoqXFxuICogV3JhcHBlciBmb3Igc2V0SW1tZWRpYXRlLCBwcm9jZXNzLm5leHRUaWNrLCBvciBicm93c2VyIHBvbHlmaWxsLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIuaW1tZWRpYXRlbHkgPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IHByb2Nlc3MubmV4dFRpY2s7XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhSdW5uZXIsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogUnVuIHRlc3RzIHdpdGggZnVsbCB0aXRsZXMgbWF0Y2hpbmcgYHJlYC4gVXBkYXRlcyBydW5uZXIudG90YWxcXG4gKiB3aXRoIG51bWJlciBvZiB0ZXN0cyBtYXRjaGVkLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5lclxcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW52ZXJ0XFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ncmVwID0gZnVuY3Rpb24gKHJlLCBpbnZlcnQpIHtcXG4gIGRlYnVnKCdncmVwICVzJywgcmUpO1xcbiAgdGhpcy5fZ3JlcCA9IHJlO1xcbiAgdGhpcy5faW52ZXJ0ID0gaW52ZXJ0O1xcbiAgdGhpcy50b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHRoaXMuc3VpdGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGVzdHMgbWF0Y2hpbmcgdGhlIGdyZXAgc2VhcmNoIGZvciB0aGVcXG4gKiBnaXZlbiBzdWl0ZS5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdyZXBUb3RhbCA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gMDtcXG5cXG4gIHN1aXRlLmVhY2hUZXN0KGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBtYXRjaCA9IHNlbGYuX2dyZXAudGVzdCh0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gICAgaWYgKHNlbGYuX2ludmVydCkge1xcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xcbiAgICB9XFxuICAgIGlmIChtYXRjaCkge1xcbiAgICAgIHRvdGFsKys7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcmV0dXJuIHRvdGFsO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbGlzdCBvZiBnbG9iYWwgcHJvcGVydGllcy5cXG4gKlxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ2xvYmFsUHJvcHMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhnbG9iYWwpO1xcblxcbiAgLy8gbm9uLWVudW1lcmFibGVzXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdsb2JhbHMubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKH5wcm9wcy5pbmRleE9mKGdsb2JhbHNbaV0pKSB7XFxuICAgICAgY29udGludWU7XFxuICAgIH1cXG4gICAgcHJvcHMucHVzaChnbG9iYWxzW2ldKTtcXG4gIH1cXG5cXG4gIHJldHVybiBwcm9wcztcXG59O1xcblxcbi8qKlxcbiAqIEFsbG93IHRoZSBnaXZlbiBgYXJyYCBvZiBnbG9iYWxzLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5lclxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uIChhcnIpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFscztcXG4gIH1cXG4gIGRlYnVnKCdnbG9iYWxzICVqJywgYXJyKTtcXG4gIHRoaXMuX2dsb2JhbHMgPSB0aGlzLl9nbG9iYWxzLmNvbmNhdChhcnIpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBmb3IgZ2xvYmFsIHZhcmlhYmxlIGxlYWtzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5jaGVja0dsb2JhbHMgPSBmdW5jdGlvbiAodGVzdCkge1xcbiAgaWYgKHRoaXMuaWdub3JlTGVha3MpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG9rID0gdGhpcy5fZ2xvYmFscztcXG5cXG4gIHZhciBnbG9iYWxzID0gdGhpcy5nbG9iYWxQcm9wcygpO1xcbiAgdmFyIGxlYWtzO1xcblxcbiAgaWYgKHRlc3QpIHtcXG4gICAgb2sgPSBvay5jb25jYXQodGVzdC5fYWxsb3dlZEdsb2JhbHMgfHwgW10pO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMucHJldkdsb2JhbHNMZW5ndGggPT09IGdsb2JhbHMubGVuZ3RoKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMucHJldkdsb2JhbHNMZW5ndGggPSBnbG9iYWxzLmxlbmd0aDtcXG5cXG4gIGxlYWtzID0gZmlsdGVyTGVha3Mob2ssIGdsb2JhbHMpO1xcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGxlYWtzKTtcXG5cXG4gIGlmIChsZWFrcy5sZW5ndGggPiAxKSB7XFxuICAgIHRoaXMuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ2dsb2JhbCBsZWFrcyBkZXRlY3RlZDogJyArIGxlYWtzLmpvaW4oJywgJykgKyAnJykpO1xcbiAgfSBlbHNlIGlmIChsZWFrcy5sZW5ndGgpIHtcXG4gICAgdGhpcy5mYWlsKHRlc3QsIG5ldyBFcnJvcignZ2xvYmFsIGxlYWsgZGV0ZWN0ZWQ6ICcgKyBsZWFrc1swXSkpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogRmFpbCB0aGUgZ2l2ZW4gYHRlc3RgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgKyt0aGlzLmZhaWx1cmVzO1xcbiAgdGVzdC5zdGF0ZSA9ICdmYWlsZWQnO1xcblxcbiAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgKGVyciAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSkpIHtcXG4gICAgZXJyID0gbmV3IEVycm9yKCd0aGUgJyArIHR5cGUoZXJyKSArICcgJyArIHN0cmluZ2lmeShlcnIpICsgJyB3YXMgdGhyb3duLCB0aHJvdyBhbiBFcnJvciA6KScpO1xcbiAgfVxcblxcbiAgdHJ5IHtcXG4gICAgZXJyLnN0YWNrID0gKHRoaXMuZnVsbFN0YWNrVHJhY2UgfHwgIWVyci5zdGFjaylcXG4gICAgICA/IGVyci5zdGFja1xcbiAgICAgIDogc3RhY2tGaWx0ZXIoZXJyLnN0YWNrKTtcXG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcXG4gICAgLy8gc29tZSBlbnZpcm9ubWVudHMgZG8gbm90IHRha2Uga2luZGx5IHRvIG1vbmtleWluZyB3aXRoIHRoZSBzdGFja1xcbiAgfVxcblxcbiAgdGhpcy5lbWl0KCdmYWlsJywgdGVzdCwgZXJyKTtcXG59O1xcblxcbi8qKlxcbiAqIEZhaWwgdGhlIGdpdmVuIGBob29rYCB3aXRoIGBlcnJgLlxcbiAqXFxuICogSG9vayBmYWlsdXJlcyB3b3JrIGluIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcXG4gKiAtIElmIGJhaWwsIHRoZW4gZXhpdFxcbiAqIC0gRmFpbGVkIGBiZWZvcmVgIGhvb2sgc2tpcHMgYWxsIHRlc3RzIGluIGEgc3VpdGUgYW5kIHN1YnN1aXRlcyxcXG4gKiAgIGJ1dCBqdW1wcyB0byBjb3JyZXNwb25kaW5nIGBhZnRlcmAgaG9va1xcbiAqIC0gRmFpbGVkIGBiZWZvcmUgZWFjaGAgaG9vayBza2lwcyByZW1haW5pbmcgdGVzdHMgaW4gYVxcbiAqICAgc3VpdGUgYW5kIGp1bXBzIHRvIGNvcnJlc3BvbmRpbmcgYGFmdGVyIGVhY2hgIGhvb2ssXFxuICogICB3aGljaCBpcyBydW4gb25seSBvbmNlXFxuICogLSBGYWlsZWQgYGFmdGVyYCBob29rIGRvZXMgbm90IGFsdGVyXFxuICogICBleGVjdXRpb24gb3JkZXJcXG4gKiAtIEZhaWxlZCBgYWZ0ZXIgZWFjaGAgaG9vayBza2lwcyByZW1haW5pbmcgdGVzdHMgaW4gYVxcbiAqICAgc3VpdGUgYW5kIHN1YnN1aXRlcywgYnV0IGV4ZWN1dGVzIG90aGVyIGBhZnRlciBlYWNoYFxcbiAqICAgaG9va3NcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7SG9va30gaG9va1xcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZmFpbEhvb2sgPSBmdW5jdGlvbiAoaG9vaywgZXJyKSB7XFxuICBpZiAoaG9vay5jdHggJiYgaG9vay5jdHguY3VycmVudFRlc3QpIHtcXG4gICAgaG9vay5vcmlnaW5hbFRpdGxlID0gaG9vay5vcmlnaW5hbFRpdGxlIHx8IGhvb2sudGl0bGU7XFxuICAgIGhvb2sudGl0bGUgPSBob29rLm9yaWdpbmFsVGl0bGUgKyAnIGZvciBcXFwiJyArIGhvb2suY3R4LmN1cnJlbnRUZXN0LnRpdGxlICsgJ1xcXCInO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMuc3VpdGUuYmFpbCgpKSB7XFxuICAgIHRoaXMuZW1pdCgnZW5kJyk7XFxuICB9XFxuICB0aGlzLmZhaWwoaG9vaywgZXJyKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rIGBuYW1lYCBjYWxsYmFja3MgYW5kIHRoZW4gaW52b2tlIGBmbigpYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5cXG5SdW5uZXIucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgaG9va3MgPSBzdWl0ZVsnXycgKyBuYW1lXTtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIGZ1bmN0aW9uIG5leHQgKGkpIHtcXG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcXG4gICAgaWYgKCFob29rKSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG4gICAgc2VsZi5jdXJyZW50UnVubmFibGUgPSBob29rO1xcblxcbiAgICBob29rLmN0eC5jdXJyZW50VGVzdCA9IHNlbGYudGVzdDtcXG5cXG4gICAgc2VsZi5lbWl0KCdob29rJywgaG9vayk7XFxuXFxuICAgIGlmICghaG9vay5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XFxuICAgICAgaG9vay5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICBzZWxmLmZhaWxIb29rKGhvb2ssIGVycik7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgaG9vay5ydW4oZnVuY3Rpb24gKGVycikge1xcbiAgICAgIHZhciB0ZXN0RXJyb3IgPSBob29rLmVycm9yKCk7XFxuICAgICAgaWYgKHRlc3RFcnJvcikge1xcbiAgICAgICAgc2VsZi5mYWlsKHNlbGYudGVzdCwgdGVzdEVycm9yKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdiZWZvcmVFYWNoJyB8fCBuYW1lID09PSAnYWZ0ZXJFYWNoJykge1xcbiAgICAgICAgICAgIHNlbGYudGVzdC5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzdWl0ZS50ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgICAgICAgICAgICB0ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIC8vIGEgcGVuZGluZyBob29rIHdvbid0IGJlIGV4ZWN1dGVkIHR3aWNlLlxcbiAgICAgICAgICAgIGhvb2sucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuZmFpbEhvb2soaG9vaywgZXJyKTtcXG5cXG4gICAgICAgICAgLy8gc3RvcCBleGVjdXRpbmcgaG9va3MsIG5vdGlmeSBjYWxsZWUgb2YgaG9vayBlcnJcXG4gICAgICAgICAgcmV0dXJuIGZuKGVycik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNlbGYuZW1pdCgnaG9vayBlbmQnLCBob29rKTtcXG4gICAgICBkZWxldGUgaG9vay5jdHguY3VycmVudFRlc3Q7XFxuICAgICAgbmV4dCgrK2kpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbiAoKSB7XFxuICAgIG5leHQoMCk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rIGBuYW1lYCBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGBzdWl0ZXNgXFxuICogaW4gb3JkZXIsIGFuZCBjYWxsYmFjayBgZm4oZXJyLCBlcnJTdWl0ZSlgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0FycmF5fSBzdWl0ZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuaG9va3MgPSBmdW5jdGlvbiAobmFtZSwgc3VpdGVzLCBmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIG9yaWcgPSB0aGlzLnN1aXRlO1xcblxcbiAgZnVuY3Rpb24gbmV4dCAoc3VpdGUpIHtcXG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xcblxcbiAgICBpZiAoIXN1aXRlKSB7XFxuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5ob29rKG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICB2YXIgZXJyU3VpdGUgPSBzZWxmLnN1aXRlO1xcbiAgICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgICByZXR1cm4gZm4oZXJyLCBlcnJTdWl0ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIG5leHQoc3VpdGVzLnBvcCgpKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBuZXh0KHN1aXRlcy5wb3AoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9va3MgZnJvbSB0aGUgdG9wIGxldmVsIGRvd24uXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rVXAgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gIHZhciBzdWl0ZXMgPSBbdGhpcy5zdWl0ZV0uY29uY2F0KHRoaXMucGFyZW50cygpKS5yZXZlcnNlKCk7XFxuICB0aGlzLmhvb2tzKG5hbWUsIHN1aXRlcywgZm4pO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2tzIGZyb20gdGhlIGJvdHRvbSB1cC5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmhvb2tEb3duID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSk7XFxuICB0aGlzLmhvb2tzKG5hbWUsIHN1aXRlcywgZm4pO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGFycmF5IG9mIHBhcmVudCBTdWl0ZXMgZnJvbVxcbiAqIGNsb3Nlc3QgdG8gZnVydGhlc3QuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIHN1aXRlcyA9IFtdO1xcbiAgd2hpbGUgKHN1aXRlLnBhcmVudCkge1xcbiAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudDtcXG4gICAgc3VpdGVzLnB1c2goc3VpdGUpO1xcbiAgfVxcbiAgcmV0dXJuIHN1aXRlcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0aGUgY3VycmVudCB0ZXN0IGFuZCBjYWxsYmFjayBgZm4oZXJyKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuVGVzdCA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3QgPSB0aGlzLnRlc3Q7XFxuXFxuICBpZiAoIXRlc3QpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKHRoaXMuZm9yYmlkT25seSAmJiBoYXNPbmx5KHRoaXMucGFyZW50cygpLnJldmVyc2UoKVswXSB8fCB0aGlzLnN1aXRlKSkge1xcbiAgICBmbihuZXcgRXJyb3IoJ2Aub25seWAgZm9yYmlkZGVuJykpO1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAodGhpcy5hc3luY09ubHkpIHtcXG4gICAgdGVzdC5hc3luY09ubHkgPSB0cnVlO1xcbiAgfVxcbiAgdGVzdC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xcbiAgfSk7XFxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgIHRlc3QuYWxsb3dVbmNhdWdodCA9IHRydWU7XFxuICAgIHJldHVybiB0ZXN0LnJ1bihmbik7XFxuICB9XFxuICB0cnkge1xcbiAgICB0ZXN0LnJ1bihmbik7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZm4oZXJyKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyBpbiB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3RzID0gZnVuY3Rpb24gKHN1aXRlLCBmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3RzID0gc3VpdGUudGVzdHMuc2xpY2UoKTtcXG4gIHZhciB0ZXN0O1xcblxcbiAgZnVuY3Rpb24gaG9va0VyciAoXywgZXJyU3VpdGUsIGFmdGVyKSB7XFxuICAgIC8vIGJlZm9yZS9hZnRlciBFYWNoIGhvb2sgZm9yIGVyclN1aXRlIGZhaWxlZDpcXG4gICAgdmFyIG9yaWcgPSBzZWxmLnN1aXRlO1xcblxcbiAgICAvLyBmb3IgZmFpbGVkICdhZnRlciBlYWNoJyBob29rIHN0YXJ0IGZyb20gZXJyU3VpdGUgcGFyZW50LFxcbiAgICAvLyBvdGhlcndpc2Ugc3RhcnQgZnJvbSBlcnJTdWl0ZSBpdHNlbGZcXG4gICAgc2VsZi5zdWl0ZSA9IGFmdGVyID8gZXJyU3VpdGUucGFyZW50IDogZXJyU3VpdGU7XFxuXFxuICAgIGlmIChzZWxmLnN1aXRlKSB7XFxuICAgICAgLy8gY2FsbCBob29rVXAgYWZ0ZXJFYWNoXFxuICAgICAgc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIGZ1bmN0aW9uIChlcnIyLCBlcnJTdWl0ZTIpIHtcXG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgICAgLy8gc29tZSBob29rcyBtYXkgZmFpbCBldmVuIG5vd1xcbiAgICAgICAgaWYgKGVycjIpIHtcXG4gICAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyMiwgZXJyU3VpdGUyLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIHJlcG9ydCBlcnJvciBzdWl0ZVxcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgY2FsbGluZyBvdGhlciAnYWZ0ZXIgZWFjaCcgaG9va3NcXG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICBmbihlcnJTdWl0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG5leHQgKGVyciwgZXJyU3VpdGUpIHtcXG4gICAgLy8gaWYgd2UgYmFpbCBhZnRlciBmaXJzdCBlcnJcXG4gICAgaWYgKHNlbGYuZmFpbHVyZXMgJiYgc3VpdGUuX2JhaWwpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2VsZi5fYWJvcnQpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgLy8gbmV4dCB0ZXN0XFxuICAgIHRlc3QgPSB0ZXN0cy5zaGlmdCgpO1xcblxcbiAgICAvLyBhbGwgZG9uZVxcbiAgICBpZiAoIXRlc3QpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICAvLyBncmVwXFxuICAgIHZhciBtYXRjaCA9IHNlbGYuX2dyZXAudGVzdCh0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gICAgaWYgKHNlbGYuX2ludmVydCkge1xcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xcbiAgICB9XFxuICAgIGlmICghbWF0Y2gpIHtcXG4gICAgICAvLyBSdW4gaW1tZWRpYXRlbHkgb25seSBpZiB3ZSBoYXZlIGRlZmluZWQgYSBncmVwLiBXaGVuIHdlXFxuICAgICAgLy8gZGVmaW5lIGEgZ3JlcCDigJQgSXQgY2FuIGNhdXNlIG1heGltdW0gY2FsbHN0YWNrIGVycm9yIGlmXFxuICAgICAgLy8gdGhlIGdyZXAgaXMgZG9pbmcgYSBsYXJnZSByZWN1cnNpdmUgbG9vcCBieSBuZWdsZWN0aW5nXFxuICAgICAgLy8gYWxsIHRlc3RzLiBUaGUgcnVuIGltbWVkaWF0ZWx5IGZ1bmN0aW9uIGFsc28gY29tZXMgd2l0aFxcbiAgICAgIC8vIGEgcGVyZm9ybWFuY2UgY29zdC4gU28gd2UgZG9uJ3Qgd2FudCB0byBydW4gaW1tZWRpYXRlbHlcXG4gICAgICAvLyBpZiB3ZSBydW4gdGhlIHdob2xlIHRlc3Qgc3VpdGUsIGJlY2F1c2UgcnVubmluZyB0aGUgd2hvbGVcXG4gICAgICAvLyB0ZXN0IHN1aXRlIGRvbid0IGRvIGFueSBpbW1lZGlhdGUgcmVjdXJzaXZlIGxvb3BzLiBUaHVzLFxcbiAgICAgIC8vIGFsbG93aW5nIGEgSlMgcnVudGltZSB0byBicmVhdGhlLlxcbiAgICAgIGlmIChzZWxmLl9ncmVwICE9PSBzZWxmLl9kZWZhdWx0R3JlcCkge1xcbiAgICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KG5leHQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBuZXh0KCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICAgIGlmIChzZWxmLmZvcmJpZFBlbmRpbmcpIHtcXG4gICAgICAgIHRlc3QuaXNQZW5kaW5nID0gYWx3YXlzRmFsc2U7XFxuICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJykpO1xcbiAgICAgICAgZGVsZXRlIHRlc3QuaXNQZW5kaW5nO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICB9XFxuICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcbiAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgIH1cXG5cXG4gICAgLy8gZXhlY3V0ZSB0ZXN0IGFuZCBob29rKHMpXFxuICAgIHNlbGYuZW1pdCgndGVzdCcsIHNlbGYudGVzdCA9IHRlc3QpO1xcbiAgICBzZWxmLmhvb2tEb3duKCdiZWZvcmVFYWNoJywgZnVuY3Rpb24gKGVyciwgZXJyU3VpdGUpIHtcXG4gICAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgaWYgKHNlbGYuZm9yYmlkUGVuZGluZykge1xcbiAgICAgICAgICB0ZXN0LmlzUGVuZGluZyA9IGFsd2F5c0ZhbHNlO1xcbiAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJykpO1xcbiAgICAgICAgICBkZWxldGUgdGVzdC5pc1BlbmRpbmc7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZWxmLmVtaXQoJ3BlbmRpbmcnLCB0ZXN0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIGZhbHNlKTtcXG4gICAgICB9XFxuICAgICAgc2VsZi5jdXJyZW50UnVubmFibGUgPSBzZWxmLnRlc3Q7XFxuICAgICAgc2VsZi5ydW5UZXN0KGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIHRlc3QgPSBzZWxmLnRlc3Q7XFxuICAgICAgICBpZiAoZXJyKSB7XFxuICAgICAgICAgIHZhciByZXRyeSA9IHRlc3QuY3VycmVudFJldHJ5KCk7XFxuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nICYmIHNlbGYuZm9yYmlkUGVuZGluZykge1xcbiAgICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ1BlbmRpbmcgdGVzdCBmb3JiaWRkZW4nKSk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xcbiAgICAgICAgICAgIHRlc3QucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgICAgc2VsZi5lbWl0KCdwZW5kaW5nJywgdGVzdCk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAocmV0cnkgPCB0ZXN0LnJldHJpZXMoKSkge1xcbiAgICAgICAgICAgIHZhciBjbG9uZWRUZXN0ID0gdGVzdC5jbG9uZSgpO1xcbiAgICAgICAgICAgIGNsb25lZFRlc3QuY3VycmVudFJldHJ5KHJldHJ5ICsgMSk7XFxuICAgICAgICAgICAgdGVzdHMudW5zaGlmdChjbG9uZWRUZXN0KTtcXG5cXG4gICAgICAgICAgICAvLyBFYXJseSByZXR1cm4gKyBob29rIHRyaWdnZXIgc28gdGhhdCBpdCBkb2Vzbid0XFxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBjb3VudCB3cm9uZ1xcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIGVycik7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcblxcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZykge1xcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRlc3Quc3RhdGUgPSAncGFzc2VkJztcXG4gICAgICAgIHNlbGYuZW1pdCgncGFzcycsIHRlc3QpO1xcbiAgICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcbiAgICAgICAgc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHRoaXMubmV4dCA9IG5leHQ7XFxuICB0aGlzLmhvb2tFcnIgPSBob29rRXJyO1xcbiAgbmV4dCgpO1xcbn07XFxuXFxuZnVuY3Rpb24gYWx3YXlzRmFsc2UgKCkge1xcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBSdW4gdGhlIGdpdmVuIGBzdWl0ZWAgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgYGZuKClgIHdoZW4gY29tcGxldGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5TdWl0ZSA9IGZ1bmN0aW9uIChzdWl0ZSwgZm4pIHtcXG4gIHZhciBpID0gMDtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0b3RhbCA9IHRoaXMuZ3JlcFRvdGFsKHN1aXRlKTtcXG4gIHZhciBhZnRlckFsbEhvb2tDYWxsZWQgPSBmYWxzZTtcXG5cXG4gIGRlYnVnKCdydW4gc3VpdGUgJXMnLCBzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuXFxuICBpZiAoIXRvdGFsIHx8IChzZWxmLmZhaWx1cmVzICYmIHN1aXRlLl9iYWlsKSkge1xcbiAgICByZXR1cm4gZm4oKTtcXG4gIH1cXG5cXG4gIHRoaXMuZW1pdCgnc3VpdGUnLCB0aGlzLnN1aXRlID0gc3VpdGUpO1xcblxcbiAgZnVuY3Rpb24gbmV4dCAoZXJyU3VpdGUpIHtcXG4gICAgaWYgKGVyclN1aXRlKSB7XFxuICAgICAgLy8gY3VycmVudCBzdWl0ZSBmYWlsZWQgb24gYSBob29rIGZyb20gZXJyU3VpdGVcXG4gICAgICBpZiAoZXJyU3VpdGUgPT09IHN1aXRlKSB7XFxuICAgICAgICAvLyBpZiBlcnJTdWl0ZSBpcyBjdXJyZW50IHN1aXRlXFxuICAgICAgICAvLyBjb250aW51ZSB0byB0aGUgbmV4dCBzaWJsaW5nIHN1aXRlXFxuICAgICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICAgIH1cXG4gICAgICAvLyBlcnJTdWl0ZSBpcyBhbW9uZyB0aGUgcGFyZW50cyBvZiBjdXJyZW50IHN1aXRlXFxuICAgICAgLy8gc3RvcCBleGVjdXRpb24gb2YgZXJyU3VpdGUgYW5kIGFsbCBzdWItc3VpdGVzXFxuICAgICAgcmV0dXJuIGRvbmUoZXJyU3VpdGUpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzZWxmLl9hYm9ydCkge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGN1cnIgPSBzdWl0ZS5zdWl0ZXNbaSsrXTtcXG4gICAgaWYgKCFjdXJyKSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcblxcbiAgICAvLyBBdm9pZCBncmVwIG5lZ2xlY3RpbmcgbGFyZ2UgbnVtYmVyIG9mIHRlc3RzIGNhdXNpbmcgYVxcbiAgICAvLyBodWdlIHJlY3Vyc2l2ZSBsb29wIGFuZCB0aHVzIGEgbWF4aW11bSBjYWxsIHN0YWNrIGVycm9yLlxcbiAgICAvLyBTZWUgY29tbWVudCBpbiBgdGhpcy5ydW5UZXN0cygpYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG4gICAgaWYgKHNlbGYuX2dyZXAgIT09IHNlbGYuX2RlZmF1bHRHcmVwKSB7XFxuICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNlbGYucnVuU3VpdGUoY3VyciwgbmV4dCk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZG9uZSAoZXJyU3VpdGUpIHtcXG4gICAgc2VsZi5zdWl0ZSA9IHN1aXRlO1xcbiAgICBzZWxmLm5leHRTdWl0ZSA9IG5leHQ7XFxuXFxuICAgIGlmIChhZnRlckFsbEhvb2tDYWxsZWQpIHtcXG4gICAgICBmbihlcnJTdWl0ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gbWFyayB0aGF0IHRoZSBhZnRlckFsbCBibG9jayBoYXMgYmVlbiBjYWxsZWQgb25jZVxcbiAgICAgIC8vIGFuZCBzbyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiBpdC5cXG4gICAgICBhZnRlckFsbEhvb2tDYWxsZWQgPSB0cnVlO1xcblxcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdGVzdFxcbiAgICAgIGRlbGV0ZSBzZWxmLnRlc3Q7XFxuXFxuICAgICAgc2VsZi5ob29rKCdhZnRlckFsbCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNlbGYuZW1pdCgnc3VpdGUgZW5kJywgc3VpdGUpO1xcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICB0aGlzLm5leHRTdWl0ZSA9IG5leHQ7XFxuXFxuICB0aGlzLmhvb2soJ2JlZm9yZUFsbCcsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgaWYgKGVycikge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG4gICAgc2VsZi5ydW5UZXN0cyhzdWl0ZSwgbmV4dCk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEhhbmRsZSB1bmNhdWdodCBleGNlcHRpb25zLlxcbiAqXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS51bmNhdWdodCA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIGlmIChlcnIpIHtcXG4gICAgZGVidWcoJ3VuY2F1Z2h0IGV4Y2VwdGlvbiAlcycsIGVyciA9PT0gKGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfS5jYWxsKGVycikpID8gKGVyci5tZXNzYWdlIHx8IGVycikgOiBlcnIpO1xcbiAgfSBlbHNlIHtcXG4gICAgZGVidWcoJ3VuY2F1Z2h0IHVuZGVmaW5lZCBleGNlcHRpb24nKTtcXG4gICAgZXJyID0gdW5kZWZpbmVkRXJyb3IoKTtcXG4gIH1cXG4gIGVyci51bmNhdWdodCA9IHRydWU7XFxuXFxuICB2YXIgcnVubmFibGUgPSB0aGlzLmN1cnJlbnRSdW5uYWJsZTtcXG5cXG4gIGlmICghcnVubmFibGUpIHtcXG4gICAgcnVubmFibGUgPSBuZXcgUnVubmFibGUoJ1VuY2F1Z2h0IGVycm9yIG91dHNpZGUgdGVzdCBzdWl0ZScpO1xcbiAgICBydW5uYWJsZS5wYXJlbnQgPSB0aGlzLnN1aXRlO1xcblxcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XFxuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIENhbid0IHJlY292ZXIgZnJvbSB0aGlzIGZhaWx1cmVcXG4gICAgICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XFxuICAgICAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcbiAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgcnVubmFibGUuY2xlYXJUaW1lb3V0KCk7XFxuXFxuICAvLyBJZ25vcmUgZXJyb3JzIGlmIGFscmVhZHkgZmFpbGVkIG9yIHBlbmRpbmdcXG4gIC8vIFNlZSAjMzIyNlxcbiAgaWYgKHJ1bm5hYmxlLmlzRmFpbGVkKCkgfHwgcnVubmFibGUuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgLy8gd2UgY2Fubm90IHJlY292ZXIgZ3JhY2VmdWxseSBpZiBhIFJ1bm5hYmxlIGhhcyBhbHJlYWR5IHBhc3NlZFxcbiAgLy8gdGhlbiBmYWlscyBhc3luY2hyb25vdXNseVxcbiAgdmFyIGFscmVhZHlQYXNzZWQgPSBydW5uYWJsZS5pc1Bhc3NlZCgpO1xcbiAgLy8gdGhpcyB3aWxsIGNoYW5nZSB0aGUgc3RhdGUgdG8gXFxcImZhaWxlZFxcXCIgcmVnYXJkbGVzcyBvZiB0aGUgY3VycmVudCB2YWx1ZVxcbiAgdGhpcy5mYWlsKHJ1bm5hYmxlLCBlcnIpO1xcbiAgaWYgKCFhbHJlYWR5UGFzc2VkKSB7XFxuICAgIC8vIHJlY292ZXIgZnJvbSB0ZXN0XFxuICAgIGlmIChydW5uYWJsZS50eXBlID09PSAndGVzdCcpIHtcXG4gICAgICB0aGlzLmVtaXQoJ3Rlc3QgZW5kJywgcnVubmFibGUpO1xcbiAgICAgIHRoaXMuaG9va1VwKCdhZnRlckVhY2gnLCB0aGlzLm5leHQpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyByZWNvdmVyIGZyb20gaG9va3NcXG4gICAgdmFyIGVyclN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGFmdGVyRWFjaCBibG9ja1xcbiAgICBpZiAocnVubmFibGUuZnVsbFRpdGxlKCkuaW5kZXhPZignYWZ0ZXIgZWFjaCcpID4gLTEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5ob29rRXJyKGVyciwgZXJyU3VpdGUsIHRydWUpO1xcbiAgICB9XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBiZWZvcmVFYWNoIGJsb2NrXFxuICAgIGlmIChydW5uYWJsZS5mdWxsVGl0bGUoKS5pbmRleE9mKCdiZWZvcmUgZWFjaCcpID4gLTEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5ob29rRXJyKGVyciwgZXJyU3VpdGUsIGZhbHNlKTtcXG4gICAgfVxcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYWZ0ZXIgb3IgYmVmb3JlIGJsb2Nrc1xcbiAgICByZXR1cm4gdGhpcy5uZXh0U3VpdGUoZXJyU3VpdGUpO1xcbiAgfVxcblxcbiAgLy8gYmFpbFxcbiAgdGhpcy5lbWl0KCdlbmQnKTtcXG59O1xcblxcbi8qKlxcbiAqIENsZWFucyB1cCB0aGUgcmVmZXJlbmNlcyB0byBhbGwgdGhlIGRlZmVycmVkIGZ1bmN0aW9uc1xcbiAqIChiZWZvcmUvYWZ0ZXIvYmVmb3JlRWFjaC9hZnRlckVhY2gpIGFuZCB0ZXN0cyBvZiBhIFN1aXRlLlxcbiAqIFRoZXNlIG11c3QgYmUgZGVsZXRlZCBvdGhlcndpc2UgYSBtZW1vcnkgbGVhayBjYW4gaGFwcGVuLFxcbiAqIGFzIHRob3NlIGZ1bmN0aW9ucyBtYXkgcmVmZXJlbmNlIHZhcmlhYmxlcyBmcm9tIGNsb3N1cmVzLFxcbiAqIHRodXMgdGhvc2UgdmFyaWFibGVzIGNhbiBuZXZlciBiZSBnYXJiYWdlIGNvbGxlY3RlZCBhcyBsb25nXFxuICogYXMgdGhlIGRlZmVycmVkIGZ1bmN0aW9ucyBleGlzdC5cXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICovXFxuZnVuY3Rpb24gY2xlYW5TdWl0ZVJlZmVyZW5jZXMgKHN1aXRlKSB7XFxuICBmdW5jdGlvbiBjbGVhbkFyclJlZmVyZW5jZXMgKGFycikge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgIGRlbGV0ZSBhcnJbaV0uZm47XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHN1aXRlLl9iZWZvcmVBbGwpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYmVmb3JlQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHN1aXRlLl9iZWZvcmVFYWNoKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2JlZm9yZUVhY2gpO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VpdGUuX2FmdGVyQWxsKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2FmdGVyQWxsKTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHN1aXRlLl9hZnRlckVhY2gpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYWZ0ZXJFYWNoKTtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGUudGVzdHMubGVuZ3RoOyBpKyspIHtcXG4gICAgZGVsZXRlIHN1aXRlLnRlc3RzW2ldLmZuO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBSdW4gdGhlIHJvb3Qgc3VpdGUgYW5kIGludm9rZSBgZm4oZmFpbHVyZXMpYFxcbiAqIG9uIGNvbXBsZXRpb24uXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHJvb3RTdWl0ZSA9IHRoaXMuc3VpdGU7XFxuXFxuICBmbiA9IGZuIHx8IGZ1bmN0aW9uICgpIHt9O1xcblxcbiAgZnVuY3Rpb24gdW5jYXVnaHQgKGVycikge1xcbiAgICBzZWxmLnVuY2F1Z2h0KGVycik7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzdGFydCAoKSB7XFxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGBvbmx5YCBmaWx0ZXJcXG4gICAgaWYgKGhhc09ubHkocm9vdFN1aXRlKSkge1xcbiAgICAgIGZpbHRlck9ubHkocm9vdFN1aXRlKTtcXG4gICAgfVxcbiAgICBzZWxmLnN0YXJ0ZWQgPSB0cnVlO1xcbiAgICBzZWxmLmVtaXQoJ3N0YXJ0Jyk7XFxuICAgIHNlbGYucnVuU3VpdGUocm9vdFN1aXRlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgZGVidWcoJ2ZpbmlzaGVkIHJ1bm5pbmcnKTtcXG4gICAgICBzZWxmLmVtaXQoJ2VuZCcpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGRlYnVnKCdzdGFydCcpO1xcblxcbiAgLy8gcmVmZXJlbmNlcyBjbGVhbnVwIHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xcbiAgdGhpcy5vbignc3VpdGUgZW5kJywgY2xlYW5TdWl0ZVJlZmVyZW5jZXMpO1xcblxcbiAgLy8gY2FsbGJhY2tcXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgZGVidWcoJ2VuZCcpO1xcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIHVuY2F1Z2h0KTtcXG4gICAgZm4oc2VsZi5mYWlsdXJlcyk7XFxuICB9KTtcXG5cXG4gIC8vIHVuY2F1Z2h0IGV4Y2VwdGlvblxcbiAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCB1bmNhdWdodCk7XFxuXFxuICBpZiAodGhpcy5fZGVsYXkpIHtcXG4gICAgLy8gZm9yIHJlcG9ydGVycywgSSBndWVzcy5cXG4gICAgLy8gbWlnaHQgYmUgbmljZSB0byBkZWJvdW5jZSBzb21lIGRvdHMgd2hpbGUgd2Ugd2FpdC5cXG4gICAgdGhpcy5lbWl0KCd3YWl0aW5nJywgcm9vdFN1aXRlKTtcXG4gICAgcm9vdFN1aXRlLm9uY2UoJ3J1bicsIHN0YXJ0KTtcXG4gIH0gZWxzZSB7XFxuICAgIHN0YXJ0KCk7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENsZWFubHkgYWJvcnQgZXhlY3V0aW9uLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5lclxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XFxuICBkZWJ1ZygnYWJvcnRpbmcnKTtcXG4gIHRoaXMuX2Fib3J0ID0gdHJ1ZTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRmlsdGVyIHN1aXRlcyBiYXNlZCBvbiBgaXNPbmx5YCBsb2dpYy5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlXFxuICogQHJldHVybnMge0Jvb2xlYW59XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gZmlsdGVyT25seSAoc3VpdGUpIHtcXG4gIGlmIChzdWl0ZS5fb25seVRlc3RzLmxlbmd0aCkge1xcbiAgICAvLyBJZiB0aGUgc3VpdGUgY29udGFpbnMgYG9ubHlgIHRlc3RzLCBydW4gdGhvc2UgYW5kIGlnbm9yZSBhbnkgbmVzdGVkIHN1aXRlcy5cXG4gICAgc3VpdGUudGVzdHMgPSBzdWl0ZS5fb25seVRlc3RzO1xcbiAgICBzdWl0ZS5zdWl0ZXMgPSBbXTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIE90aGVyd2lzZSwgZG8gbm90IHJ1biBhbnkgb2YgdGhlIHRlc3RzIGluIHRoaXMgc3VpdGUuXFxuICAgIHN1aXRlLnRlc3RzID0gW107XFxuICAgIHN1aXRlLl9vbmx5U3VpdGVzLmZvckVhY2goZnVuY3Rpb24gKG9ubHlTdWl0ZSkge1xcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBvdGhlciBgb25seWAgdGVzdHMvc3VpdGVzIG5lc3RlZCBpbiB0aGUgY3VycmVudCBgb25seWAgc3VpdGUsIHRoZW4gZmlsdGVyIHRoYXQgYG9ubHlgIHN1aXRlLlxcbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIG9mIHRoZSB0ZXN0cyBvbiB0aGlzIGBvbmx5YCBzdWl0ZSBzaG91bGQgYmUgcnVuLCBzbyBkb24ndCBmaWx0ZXIgaXQuXFxuICAgICAgaWYgKGhhc09ubHkob25seVN1aXRlKSkge1xcbiAgICAgICAgZmlsdGVyT25seShvbmx5U3VpdGUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIC8vIFJ1biB0aGUgYG9ubHlgIHN1aXRlcywgYXMgd2VsbCBhcyBhbnkgb3RoZXIgc3VpdGVzIHRoYXQgaGF2ZSBgb25seWAgdGVzdHMvc3VpdGVzIGFzIGRlc2NlbmRhbnRzLlxcbiAgICBzdWl0ZS5zdWl0ZXMgPSBzdWl0ZS5zdWl0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFN1aXRlKSB7XFxuICAgICAgcmV0dXJuIHN1aXRlLl9vbmx5U3VpdGVzLmluZGV4T2YoY2hpbGRTdWl0ZSkgIT09IC0xIHx8IGZpbHRlck9ubHkoY2hpbGRTdWl0ZSk7XFxuICAgIH0pO1xcbiAgfVxcbiAgLy8gS2VlcCB0aGUgc3VpdGUgb25seSBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdG8gcnVuXFxuICByZXR1cm4gc3VpdGUudGVzdHMubGVuZ3RoIHx8IHN1aXRlLnN1aXRlcy5sZW5ndGg7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZXMgd2hldGhlciBhIHN1aXRlIGhhcyBhbiBgb25seWAgdGVzdCBvciBzdWl0ZSBhcyBhIGRlc2NlbmRhbnQuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fSBzdWl0ZVxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGhhc09ubHkgKHN1aXRlKSB7XFxuICByZXR1cm4gc3VpdGUuX29ubHlUZXN0cy5sZW5ndGggfHwgc3VpdGUuX29ubHlTdWl0ZXMubGVuZ3RoIHx8IHN1aXRlLnN1aXRlcy5zb21lKGhhc09ubHkpO1xcbn1cXG5cXG4vKipcXG4gKiBGaWx0ZXIgbGVha3Mgd2l0aCB0aGUgZ2l2ZW4gZ2xvYmFscyBmbGFnZ2VkIGFzIGBva2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBva1xcbiAqIEBwYXJhbSB7QXJyYXl9IGdsb2JhbHNcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5mdW5jdGlvbiBmaWx0ZXJMZWFrcyAob2ssIGdsb2JhbHMpIHtcXG4gIHJldHVybiBnbG9iYWxzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XFxuICAgIC8vIEZpcmVmb3ggYW5kIENocm9tZSBleHBvc2VzIGlmcmFtZXMgYXMgaW5kZXggaW5zaWRlIHRoZSB3aW5kb3cgb2JqZWN0XFxuICAgIGlmICgvXlxcXFxkKy8udGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIGluIGZpcmVmb3hcXG4gICAgLy8gaWYgcnVubmVyIHJ1bnMgaW4gYW4gaWZyYW1lLCB0aGlzIGlmcmFtZSdzIHdpbmRvdy5nZXRJbnRlcmZhY2UgbWV0aG9kXFxuICAgIC8vIG5vdCBpbml0IGF0IGZpcnN0IGl0IGlzIGFzc2lnbmVkIGluIHNvbWUgc2Vjb25kc1xcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiAoL15nZXRJbnRlcmZhY2UvKS50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gYW4gaWZyYW1lIGNvdWxkIGJlIGFwcHJvYWNoZWQgYnkgd2luZG93W2lmcmFtZUluZGV4XVxcbiAgICAvLyBpbiBpZTYsNyw4IGFuZCBvcGVyYSwgaWZyYW1lSW5kZXggaXMgZW51bWVyYWJsZSwgdGhpcyBjb3VsZCBjYXVzZSBsZWFrXFxuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmICgvXlxcXFxkKy8pLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBPcGVyYSBhbmQgSUUgZXhwb3NlIGdsb2JhbCB2YXJpYWJsZXMgZm9yIEhUTUwgZWxlbWVudCBJRHMgKGlzc3VlICMyNDMpXFxuICAgIGlmICgvXm1vY2hhLS8udGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIHZhciBtYXRjaGVkID0gb2suZmlsdGVyKGZ1bmN0aW9uIChvaykge1xcbiAgICAgIGlmICh+b2suaW5kZXhPZignKicpKSB7XFxuICAgICAgICByZXR1cm4ga2V5LmluZGV4T2Yob2suc3BsaXQoJyonKVswXSkgPT09IDA7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBrZXkgPT09IG9rO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuICFtYXRjaGVkLmxlbmd0aCAmJiAoIWdsb2JhbC5uYXZpZ2F0b3IgfHwga2V5ICE9PSAnb25lcnJvcicpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEFycmF5IG9mIGdsb2JhbHMgZGVwZW5kZW50IG9uIHRoZSBlbnZpcm9ubWVudC5cXG4gKlxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGV4dHJhR2xvYmFscyAoKSB7XFxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb24gPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhciBwYXJ0cyA9IHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicpO1xcbiAgICB2YXIgbm9kZVZlcnNpb24gPSBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIHYpIHtcXG4gICAgICByZXR1cm4gYSA8PCA4IHwgdjtcXG4gICAgfSk7XFxuXFxuICAgIC8vICdlcnJubycgd2FzIHJlbmFtZWQgdG8gcHJvY2Vzcy5fZXJybm8gaW4gdjAuOS4xMS5cXG5cXG4gICAgaWYgKG5vZGVWZXJzaW9uIDwgMHgwMDA5MEIpIHtcXG4gICAgICByZXR1cm4gWydlcnJubyddO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gW107XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vcGVuZGluZ1xcXCI6MTUsXFxcIi4vcnVubmFibGVcXFwiOjMyLFxcXCIuL3V0aWxzXFxcIjozNixcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJkZWJ1Z1xcXCI6NDMsXFxcImV2ZW50c1xcXCI6NDd9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgU3VpdGVcXG4gKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIEhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6c3VpdGUnKTtcXG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi9tcycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgU3VpdGVgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN1aXRlO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBgU3VpdGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIHBhcmVudCBgU3VpdGVgLiBXaGVuIGEgc3VpdGVcXG4gKiB3aXRoIHRoZSBzYW1lIHRpdGxlIGlzIGFscmVhZHkgcHJlc2VudCwgdGhhdCBzdWl0ZSBpcyByZXR1cm5lZCB0byBwcm92aWRlXFxuICogbmljZXIgcmVwb3J0ZXIgYW5kIG1vcmUgZmxleGlibGUgbWV0YS10ZXN0aW5nLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gcGFyZW50XFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50LCB0aXRsZSkge1xcbiAgdmFyIHN1aXRlID0gbmV3IFN1aXRlKHRpdGxlLCBwYXJlbnQuY3R4KTtcXG4gIHN1aXRlLnBhcmVudCA9IHBhcmVudDtcXG4gIHRpdGxlID0gc3VpdGUuZnVsbFRpdGxlKCk7XFxuICBwYXJlbnQuYWRkU3VpdGUoc3VpdGUpO1xcbiAgcmV0dXJuIHN1aXRlO1xcbn07XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgU3VpdGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGBjdHhgLiBEZXJpdmVkIGZyb20gW0V2ZW50RW1pdHRlcl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfY2xhc3NfZXZlbnRlbWl0dGVyKVxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7Q29udGV4dH0gcGFyZW50Q29udGV4dFxcbiAqL1xcbmZ1bmN0aW9uIFN1aXRlICh0aXRsZSwgcGFyZW50Q29udGV4dCkge1xcbiAgaWYgKCF1dGlscy5pc1N0cmluZyh0aXRsZSkpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWl0ZSBgdGl0bGVgIHNob3VsZCBiZSBhIFxcXCJzdHJpbmdcXFwiIGJ1dCBcXFwiJyArIHR5cGVvZiB0aXRsZSArICdcXFwiIHdhcyBnaXZlbiBpbnN0ZWFkLicpO1xcbiAgfVxcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xcbiAgZnVuY3Rpb24gQ29udGV4dCAoKSB7fVxcbiAgQ29udGV4dC5wcm90b3R5cGUgPSBwYXJlbnRDb250ZXh0O1xcbiAgdGhpcy5jdHggPSBuZXcgQ29udGV4dCgpO1xcbiAgdGhpcy5zdWl0ZXMgPSBbXTtcXG4gIHRoaXMudGVzdHMgPSBbXTtcXG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xcbiAgdGhpcy5fYmVmb3JlRWFjaCA9IFtdO1xcbiAgdGhpcy5fYmVmb3JlQWxsID0gW107XFxuICB0aGlzLl9hZnRlckVhY2ggPSBbXTtcXG4gIHRoaXMuX2FmdGVyQWxsID0gW107XFxuICB0aGlzLnJvb3QgPSAhdGl0bGU7XFxuICB0aGlzLl90aW1lb3V0ID0gMjAwMDtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gdHJ1ZTtcXG4gIHRoaXMuX3Nsb3cgPSA3NTtcXG4gIHRoaXMuX2JhaWwgPSBmYWxzZTtcXG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcXG4gIHRoaXMuX29ubHlUZXN0cyA9IFtdO1xcbiAgdGhpcy5fb25seVN1aXRlcyA9IFtdO1xcbiAgdGhpcy5kZWxheWVkID0gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoU3VpdGUsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgY2xvbmUgb2YgdGhpcyBgU3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN1aXRlID0gbmV3IFN1aXRlKHRoaXMudGl0bGUpO1xcbiAgZGVidWcoJ2Nsb25lJyk7XFxuICBzdWl0ZS5jdHggPSB0aGlzLmN0eDtcXG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgc3VpdGUucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBzdWl0ZS5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XFxuICBzdWl0ZS5iYWlsKHRoaXMuYmFpbCgpKTtcXG4gIHJldHVybiBzdWl0ZTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgdGltZW91dCBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcXFwiMnNcXFwiLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcXG4gIH1cXG4gIGlmIChtcy50b1N0cmluZygpID09PSAnMCcpIHtcXG4gICAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBmYWxzZTtcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xcbiAgdGhpcy5fdGltZW91dCA9IHBhcnNlSW50KG1zLCAxMCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGEgZmFpbGVkIHRlc3QuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG5cXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllcztcXG4gIH1cXG4gIGRlYnVnKCdyZXRyaWVzICVkJywgbik7XFxuICB0aGlzLl9yZXRyaWVzID0gcGFyc2VJbnQobiwgMTApIHx8IDA7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAgKiBTZXQgb3IgZ2V0IHRpbWVvdXQgdG8gYGVuYWJsZWRgLlxcbiAgKlxcbiAgKiBAYXBpIHByaXZhdGVcXG4gICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICAqIEByZXR1cm4ge1N1aXRlfGJvb2xlYW59IHNlbGYgb3IgZW5hYmxlZFxcbiAgKi9cXG5TdWl0ZS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbmFibGVUaW1lb3V0cztcXG4gIH1cXG4gIGRlYnVnKCdlbmFibGVUaW1lb3V0cyAlcycsIGVuYWJsZWQpO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBlbmFibGVkO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHNsb3cgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXFxcIjJzXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1Zygnc2xvdyAlZCcsIG1zKTtcXG4gIHRoaXMuX3Nsb3cgPSBtcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCB3aGV0aGVyIHRvIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyb3IuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJhaWxcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fYmFpbDtcXG4gIH1cXG4gIGRlYnVnKCdiYWlsICVzJywgYmFpbCk7XFxuICB0aGlzLl9iYWlsID0gYmFpbDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdGhpcyBzdWl0ZSBvciBpdHMgcGFyZW50IHN1aXRlIGlzIG1hcmtlZCBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzUGVuZGluZygpKTtcXG59O1xcblxcbi8qKlxcbiAqIEdlbmVyaWMgaG9vay1jcmVhdG9yLlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gVGl0bGUgb2YgaG9va1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gSG9vayBjYWxsYmFja1xcbiAqIEByZXR1cm5zIHtIb29rfSBBIG5ldyBob29rXFxuICovXFxuU3VpdGUucHJvdG90eXBlLl9jcmVhdGVIb29rID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIGhvb2suZmlsZSA9IHRoaXMuZmlsZTtcXG4gIHJldHVybiBob29rO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBiZWZvcmUgcnVubmluZyB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iZWZvcmVBbGwgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XFxuICB0aGlzLl9iZWZvcmVBbGwucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYmVmb3JlQWxsJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgcnVubmluZyB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZnRlckFsbCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBmbiA9IHRpdGxlO1xcbiAgICB0aXRsZSA9IGZuLm5hbWU7XFxuICB9XFxuICB0aXRsZSA9ICdcXFwiYWZ0ZXIgYWxsXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xcbiAgdGhpcy5fYWZ0ZXJBbGwucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYWZ0ZXJBbGwnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBiZWZvcmUgZWFjaCB0ZXN0IGNhc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBmbiA9IHRpdGxlO1xcbiAgICB0aXRsZSA9IGZuLm5hbWU7XFxuICB9XFxuICB0aXRsZSA9ICdcXFwiYmVmb3JlIGVhY2hcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XFxuICB0aGlzLl9iZWZvcmVFYWNoLnB1c2goaG9vayk7XFxuICB0aGlzLmVtaXQoJ2JlZm9yZUVhY2gnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBlYWNoIHRlc3QgY2FzZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImFmdGVyIGVhY2hcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSB0aGlzLl9jcmVhdGVIb29rKHRpdGxlLCBmbik7XFxuICB0aGlzLl9hZnRlckVhY2gucHVzaChob29rKTtcXG4gIHRoaXMuZW1pdCgnYWZ0ZXJFYWNoJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCBhIHRlc3QgYHN1aXRlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZGRTdWl0ZSA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgc3VpdGUucGFyZW50ID0gdGhpcztcXG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgc3VpdGUucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBzdWl0ZS5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XFxuICBzdWl0ZS5iYWlsKHRoaXMuYmFpbCgpKTtcXG4gIHRoaXMuc3VpdGVzLnB1c2goc3VpdGUpO1xcbiAgdGhpcy5lbWl0KCdzdWl0ZScsIHN1aXRlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIGEgYHRlc3RgIHRvIHRoaXMgc3VpdGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFkZFRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xcbiAgdGVzdC5wYXJlbnQgPSB0aGlzO1xcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICB0ZXN0LnNsb3codGhpcy5zbG93KCkpO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMudGVzdHMucHVzaCh0ZXN0KTtcXG4gIHRoaXMuZW1pdCgndGVzdCcsIHRlc3QpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGZ1bGwgdGl0bGUgZ2VuZXJhdGVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbmNhdGVuYXRpbmcgdGhlIHBhcmVudCdzXFxuICogZnVsbCB0aXRsZS5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5TdWl0ZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuZnVsbFRpdGxlID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMudGl0bGVQYXRoKCkuam9pbignICcpO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSB0aXRsZSBwYXRoIGdlbmVyYXRlZCBieSByZWN1cnNpdmVseSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQnc1xcbiAqIHRpdGxlIHBhdGguXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuU3VpdGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLnRpdGxlUGF0aCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciByZXN1bHQgPSBbXTtcXG4gIGlmICh0aGlzLnBhcmVudCkge1xcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMucGFyZW50LnRpdGxlUGF0aCgpKTtcXG4gIH1cXG4gIGlmICghdGhpcy5yb290KSB7XFxuICAgIHJlc3VsdC5wdXNoKHRoaXMudGl0bGUpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgdG90YWwgbnVtYmVyIG9mIHRlc3RzLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlN1aXRlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS50b3RhbCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnN1aXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgc3VpdGUpIHtcXG4gICAgcmV0dXJuIHN1bSArIHN1aXRlLnRvdGFsKCk7XFxuICB9LCAwKSArIHRoaXMudGVzdHMubGVuZ3RoO1xcbn07XFxuXFxuLyoqXFxuICogSXRlcmF0ZXMgdGhyb3VnaCBlYWNoIHN1aXRlIHJlY3Vyc2l2ZWx5IHRvIGZpbmQgYWxsIHRlc3RzLiBBcHBsaWVzIGFcXG4gKiBmdW5jdGlvbiBpbiB0aGUgZm9ybWF0IGBmbih0ZXN0KWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5lYWNoVGVzdCA9IGZ1bmN0aW9uIChmbikge1xcbiAgdGhpcy50ZXN0cy5mb3JFYWNoKGZuKTtcXG4gIHRoaXMuc3VpdGVzLmZvckVhY2goZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIHN1aXRlLmVhY2hUZXN0KGZuKTtcXG4gIH0pO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBUaGlzIHdpbGwgcnVuIHRoZSByb290IHN1aXRlIGlmIHdlIGhhcHBlbiB0byBiZSBydW5uaW5nIGluIGRlbGF5ZWQgbW9kZS5cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcXG4gIGlmICh0aGlzLnJvb3QpIHtcXG4gICAgdGhpcy5lbWl0KCdydW4nKTtcXG4gIH1cXG59O1xcblxcbn0se1xcXCIuL2hvb2tcXFwiOjYsXFxcIi4vbXNcXFwiOjE0LFxcXCIuL3V0aWxzXFxcIjozNixcXFwiZGVidWdcXFwiOjQzLFxcXCJldmVudHNcXFwiOjQ3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBSdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBUZXN0YC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFRlc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVGVzdGAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZnVuY3Rpb24gVGVzdCAodGl0bGUsIGZuKSB7XFxuICBpZiAoIWlzU3RyaW5nKHRpdGxlKSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3QgYHRpdGxlYCBzaG91bGQgYmUgYSBcXFwic3RyaW5nXFxcIiBidXQgXFxcIicgKyB0eXBlb2YgdGl0bGUgKyAnXFxcIiB3YXMgZ2l2ZW4gaW5zdGVhZC4nKTtcXG4gIH1cXG4gIFJ1bm5hYmxlLmNhbGwodGhpcywgdGl0bGUsIGZuKTtcXG4gIHRoaXMucGVuZGluZyA9ICFmbjtcXG4gIHRoaXMudHlwZSA9ICd0ZXN0JztcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBSdW5uYWJsZS5wcm90b3R5cGVgLlxcbiAqL1xcbnV0aWxzLmluaGVyaXRzKFRlc3QsIFJ1bm5hYmxlKTtcXG5cXG5UZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciB0ZXN0ID0gbmV3IFRlc3QodGhpcy50aXRsZSwgdGhpcy5mbik7XFxuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHRlc3QuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmN1cnJlbnRSZXRyeSh0aGlzLmN1cnJlbnRSZXRyeSgpKTtcXG4gIHRlc3QuZ2xvYmFscyh0aGlzLmdsb2JhbHMoKSk7XFxuICB0ZXN0LnBhcmVudCA9IHRoaXMucGFyZW50O1xcbiAgdGVzdC5maWxlID0gdGhpcy5maWxlO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHJldHVybiB0ZXN0O1xcbn07XFxuXFxufSx7XFxcIi4vcnVubmFibGVcXFwiOjMyLFxcXCIuL3V0aWxzXFxcIjozNn1dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogQG1vZHVsZVxcbiAqL1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6d2F0Y2gnKTtcXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xcbnZhciBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciBqb2luID0gcGF0aC5qb2luO1xcbnZhciBoZSA9IHJlcXVpcmUoJ2hlJyk7XFxuXFxuLyoqXFxuICogSWdub3JlZCBkaXJlY3Rvcmllcy5cXG4gKi9cXG5cXG52YXIgaWdub3JlID0gWydub2RlX21vZHVsZXMnLCAnLmdpdCddO1xcblxcbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGh0bWxcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5lc2NhcGUgPSBmdW5jdGlvbiAoaHRtbCkge1xcbiAgcmV0dXJuIGhlLmVuY29kZShTdHJpbmcoaHRtbCksIHsgdXNlTmFtZWRSZWZlcmVuY2VzOiBmYWxzZSB9KTtcXG59O1xcblxcbi8qKlxcbiAqIFRlc3QgaWYgdGhlIGdpdmVuIG9iaiBpcyB0eXBlIG9mIHN0cmluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcmV0dXJuIHtib29sZWFufVxcbiAqL1xcbmV4cG9ydHMuaXNTdHJpbmcgPSBmdW5jdGlvbiAob2JqKSB7XFxuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XFxufTtcXG5cXG4vKipcXG4gKiBXYXRjaCB0aGUgZ2l2ZW4gYGZpbGVzYCBmb3IgY2hhbmdlc1xcbiAqIGFuZCBpbnZva2UgYGZuKGZpbGUpYCBvbiBtb2RpZmljYXRpb24uXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBmaWxlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZXhwb3J0cy53YXRjaCA9IGZ1bmN0aW9uIChmaWxlcywgZm4pIHtcXG4gIHZhciBvcHRpb25zID0geyBpbnRlcnZhbDogMTAwIH07XFxuICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgIGRlYnVnKCdmaWxlICVzJywgZmlsZSk7XFxuICAgIGZzLndhdGNoRmlsZShmaWxlLCBvcHRpb25zLCBmdW5jdGlvbiAoY3VyciwgcHJldikge1xcbiAgICAgIGlmIChwcmV2Lm10aW1lIDwgY3Vyci5tdGltZSkge1xcbiAgICAgICAgZm4oZmlsZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlZCBmaWxlcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBpZ25vcmVkIChwYXRoKSB7XFxuICByZXR1cm4gIX5pZ25vcmUuaW5kZXhPZihwYXRoKTtcXG59XFxuXFxuLyoqXFxuICogTG9va3VwIGZpbGVzIGluIHRoZSBnaXZlbiBgZGlyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJcXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbZXh0PVsnLmpzJ11dXFxuICogQHBhcmFtIHtBcnJheX0gW3JldD1bXV1cXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5leHBvcnRzLmZpbGVzID0gZnVuY3Rpb24gKGRpciwgZXh0LCByZXQpIHtcXG4gIHJldCA9IHJldCB8fCBbXTtcXG4gIGV4dCA9IGV4dCB8fCBbJ2pzJ107XFxuXFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXC4oJyArIGV4dC5qb2luKCd8JykgKyAnKSQnKTtcXG5cXG4gIGZzLnJlYWRkaXJTeW5jKGRpcilcXG4gICAgLmZpbHRlcihpZ25vcmVkKVxcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xcbiAgICAgIHBhdGggPSBqb2luKGRpciwgcGF0aCk7XFxuICAgICAgaWYgKGZzLmxzdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpKSB7XFxuICAgICAgICBleHBvcnRzLmZpbGVzKHBhdGgsIGV4dCwgcmV0KTtcXG4gICAgICB9IGVsc2UgaWYgKHBhdGgubWF0Y2gocmUpKSB7XFxuICAgICAgICByZXQucHVzaChwYXRoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbi8qKlxcbiAqIENvbXB1dGUgYSBzbHVnIGZyb20gdGhlIGdpdmVuIGBzdHJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnNsdWcgPSBmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gc3RyXFxuICAgIC50b0xvd2VyQ2FzZSgpXFxuICAgIC5yZXBsYWNlKC8gKy9nLCAnLScpXFxuICAgIC5yZXBsYWNlKC9bXi1cXFxcd10vZywgJycpO1xcbn07XFxuXFxuLyoqXFxuICogU3RyaXAgdGhlIGZ1bmN0aW9uIGRlZmluaXRpb24gZnJvbSBgc3RyYCwgYW5kIHJlLWluZGVudCBmb3IgcHJlIHdoaXRlc3BhY2UuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuY2xlYW4gPSBmdW5jdGlvbiAoc3RyKSB7XFxuICBzdHIgPSBzdHJcXG4gICAgLnJlcGxhY2UoL1xcXFxyXFxcXG4/fFtcXFxcblxcXFx1MjAyOFxcXFx1MjAyOV0vZywgJ1xcXFxuJykucmVwbGFjZSgvXlxcXFx1RkVGRi8sICcnKVxcbiAgICAvLyAodHJhZGl0aW9uYWwpLT4gIHNwYWNlL25hbWUgICAgIHBhcmFtZXRlcnMgICAgYm9keSAgICAgKGxhbWJkYSktPiBwYXJhbWV0ZXJzICAgICAgIGJvZHkgICBtdWx0aS1zdGF0ZW1lbnQvc2luZ2xlICAgICAgICAgIGtlZXAgYm9keSBjb250ZW50XFxuICAgIC5yZXBsYWNlKC9eZnVuY3Rpb24oPzpcXFxccyp8XFxcXHMrW14oXSopXFxcXChbXildKlxcXFwpXFxcXHMqXFxcXHsoKD86LnxcXFxcbikqPylcXFxccypcXFxcfSR8XlxcXFwoW14pXSpcXFxcKVxcXFxzKj0+XFxcXHMqKD86XFxcXHsoKD86LnxcXFxcbikqPylcXFxccypcXFxcfXwoKD86LnxcXFxcbikqKSkkLywgJyQxJDIkMycpO1xcblxcbiAgdmFyIHNwYWNlcyA9IHN0ci5tYXRjaCgvXlxcXFxuPyggKikvKVsxXS5sZW5ndGg7XFxuICB2YXIgdGFicyA9IHN0ci5tYXRjaCgvXlxcXFxuPyhcXFxcdCopLylbMV0ubGVuZ3RoO1xcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXlxcXFxuPycgKyAodGFicyA/ICdcXFxcdCcgOiAnICcpICsgJ3snICsgKHRhYnMgfHwgc3BhY2VzKSArICd9JywgJ2dtJyk7XFxuXFxuICBzdHIgPSBzdHIucmVwbGFjZShyZSwgJycpO1xcblxcbiAgcmV0dXJuIHN0ci50cmltKCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHFzYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBxc1xcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5leHBvcnRzLnBhcnNlUXVlcnkgPSBmdW5jdGlvbiAocXMpIHtcXG4gIHJldHVybiBxcy5yZXBsYWNlKCc/JywgJycpLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChvYmosIHBhaXIpIHtcXG4gICAgdmFyIGkgPSBwYWlyLmluZGV4T2YoJz0nKTtcXG4gICAgdmFyIGtleSA9IHBhaXIuc2xpY2UoMCwgaSk7XFxuICAgIHZhciB2YWwgPSBwYWlyLnNsaWNlKCsraSk7XFxuXFxuICAgIC8vIER1ZSB0byBob3cgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkgdHJlYXRzIHNwYWNlc1xcbiAgICBvYmpba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWwucmVwbGFjZSgvXFxcXCsvZywgJyUyMCcpKTtcXG5cXG4gICAgcmV0dXJuIG9iajtcXG4gIH0sIHt9KTtcXG59O1xcblxcbi8qKlxcbiAqIEhpZ2hsaWdodCB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBqc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30ganNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gaGlnaGxpZ2h0IChqcykge1xcbiAgcmV0dXJuIGpzXFxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxcbiAgICAucmVwbGFjZSgvXFxcXC9cXFxcLyguKikvZ20sICc8c3BhbiBjbGFzcz1cXFwiY29tbWVudFxcXCI+Ly8kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKCcuKj8nKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJzdHJpbmdcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oXFxcXGQrXFxcXC5cXFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XFxcIm51bWJlclxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLyhcXFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XFxcIm51bWJlclxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxibmV3WyBcXFxcdF0rKFxcXFx3KykvZ20sICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+bmV3PC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiaW5pdFxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxiKGZ1bmN0aW9ufG5ld3x0aHJvd3xyZXR1cm58dmFyfGlmfGVsc2UpXFxcXGIvZ20sICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+JDE8L3NwYW4+Jyk7XFxufVxcblxcbi8qKlxcbiAqIEhpZ2hsaWdodCB0aGUgY29udGVudHMgb2YgdGFnIGBuYW1lYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICovXFxuZXhwb3J0cy5oaWdobGlnaHRUYWdzID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIHZhciBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcbiAgICBjb2RlW2ldLmlubmVySFRNTCA9IGhpZ2hsaWdodChjb2RlW2ldLmlubmVySFRNTCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJZiBhIHZhbHVlIGNvdWxkIGhhdmUgcHJvcGVydGllcywgYW5kIGhhcyBub25lLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCxcXG4gKiB3aGljaCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbXB0eSB2YWx1ZS5cXG4gKlxcbiAqIEZ1bmN0aW9ucyB3LyBubyBwcm9wZXJ0aWVzIHJldHVybiBgJ1tGdW5jdGlvbl0nYFxcbiAqIEFycmF5cyB3LyBsZW5ndGggPT09IDAgcmV0dXJuIGAnW10nYFxcbiAqIE9iamVjdHMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCd7fSdgXFxuICogQWxsIGVsc2U6IHJldHVybiByZXN1bHQgb2YgYHZhbHVlLnRvU3RyaW5nKClgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlSGludCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVcXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGVtcHR5UmVwcmVzZW50YXRpb24gKHZhbHVlLCB0eXBlSGludCkge1xcbiAgc3dpdGNoICh0eXBlSGludCkge1xcbiAgICBjYXNlICdmdW5jdGlvbic6XFxuICAgICAgcmV0dXJuICdbRnVuY3Rpb25dJztcXG4gICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICByZXR1cm4gJ3t9JztcXG4gICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIHJldHVybiAnW10nO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBUYWtlcyBzb21lIHZhcmlhYmxlIGFuZCBhc2tzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClgIHdoYXQgaXQgdGhpbmtzIGl0XFxuICogaXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b1N0cmluZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXFxuICogQHJldHVybnMge3N0cmluZ30gQ29tcHV0ZWQgdHlwZVxcbiAqIEBleGFtcGxlXFxuICogdHlwZSh7fSkgLy8gJ29iamVjdCdcXG4gKiB0eXBlKFtdKSAvLyAnYXJyYXknXFxuICogdHlwZSgxKSAvLyAnbnVtYmVyJ1xcbiAqIHR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xcbiAqIHR5cGUoSW5maW5pdHkpIC8vICdudW1iZXInXFxuICogdHlwZShudWxsKSAvLyAnbnVsbCdcXG4gKiB0eXBlKG5ldyBEYXRlKCkpIC8vICdkYXRlJ1xcbiAqIHR5cGUoL2Zvby8pIC8vICdyZWdleHAnXFxuICogdHlwZSgndHlwZScpIC8vICdzdHJpbmcnXFxuICogdHlwZShnbG9iYWwpIC8vICdnbG9iYWwnXFxuICogdHlwZShuZXcgU3RyaW5nKCdmb28nKSAvLyAnb2JqZWN0J1xcbiAqL1xcbnZhciB0eXBlID0gZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSAodmFsdWUpIHtcXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiAndW5kZWZpbmVkJztcXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcXG4gICAgcmV0dXJuICdudWxsJztcXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xcbiAgICByZXR1cm4gJ2J1ZmZlcic7XFxuICB9XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxcbiAgICAucmVwbGFjZSgvXlxcXFxbLitcXFxccyguKz8pXSQvLCAnJDEnKVxcbiAgICAudG9Mb3dlckNhc2UoKTtcXG59O1xcblxcbi8qKlxcbiAqIFN0cmluZ2lmeSBgdmFsdWVgLiBEaWZmZXJlbnQgYmVoYXZpb3IgZGVwZW5kaW5nIG9uIHR5cGUgb2YgdmFsdWU6XFxuICpcXG4gKiAtIElmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybiBgJ1t1bmRlZmluZWRdJ2Agb3IgYCdbbnVsbF0nYCwgcmVzcGVjdGl2ZWx5LlxcbiAqIC0gSWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWAgd3JhcHBlZCBpbiBkb3VibGUtcXVvdGVzLlxcbiAqIC0gSWYgYHZhbHVlYCBpcyBhbiAqZW1wdHkqIG9iamVjdCwgZnVuY3Rpb24sIG9yIGFycmF5LCByZXR1cm4gcmVzdWx0IG9mIGZ1bmN0aW9uXFxuICogICB7QGxpbmsgZW1wdHlSZXByZXNlbnRhdGlvbn0uXFxuICogLSBJZiBgdmFsdWVgIGhhcyBwcm9wZXJ0aWVzLCBjYWxsIHtAbGluayBleHBvcnRzLmNhbm9uaWNhbGl6ZX0gb24gaXQsIHRoZW4gcmV0dXJuIHJlc3VsdCBvZlxcbiAqICAgSlNPTi5zdHJpbmdpZnkoKS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUgZXhwb3J0cy50eXBlXFxuICogQHBhcmFtIHsqfSB2YWx1ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgdmFyIHR5cGVIaW50ID0gdHlwZSh2YWx1ZSk7XFxuXFxuICBpZiAoIX5bJ29iamVjdCcsICdhcnJheScsICdmdW5jdGlvbiddLmluZGV4T2YodHlwZUhpbnQpKSB7XFxuICAgIGlmICh0eXBlSGludCA9PT0gJ2J1ZmZlcicpIHtcXG4gICAgICB2YXIganNvbiA9IEJ1ZmZlci5wcm90b3R5cGUudG9KU09OLmNhbGwodmFsdWUpO1xcbiAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XFxuICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnkoanNvbi5kYXRhICYmIGpzb24udHlwZSA/IGpzb24uZGF0YSA6IGpzb24sIDIpXFxuICAgICAgICAucmVwbGFjZSgvLChcXFxcbnwkKS9nLCAnJDEnKTtcXG4gICAgfVxcblxcbiAgICAvLyBJRTcvSUU4IGhhcyBhIGJpemFycmUgU3RyaW5nIGNvbnN0cnVjdG9yOyBuZWVkcyB0byBiZSBjb2VyY2VkXFxuICAgIC8vIGludG8gYW4gYXJyYXkgYW5kIGJhY2sgdG8gb2JqLlxcbiAgICBpZiAodHlwZUhpbnQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY2hhciwgaWR4KSB7XFxuICAgICAgICBhY2NbaWR4XSA9IGNoYXI7XFxuICAgICAgICByZXR1cm4gYWNjO1xcbiAgICAgIH0sIHt9KTtcXG4gICAgICB0eXBlSGludCA9ICdvYmplY3QnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBwcm9wKSkge1xcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCB0eXBlSGludCksIDIpLnJlcGxhY2UoLywoXFxcXG58JCkvZywgJyQxJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XFxufTtcXG5cXG4vKipcXG4gKiBsaWtlIEpTT04uc3RyaW5naWZ5IGJ1dCBtb3JlIHNlbnNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9ICBvYmplY3RcXG4gKiBAcGFyYW0ge251bWJlcj19IHNwYWNlc1xcbiAqIEBwYXJhbSB7bnVtYmVyPX0gZGVwdGhcXG4gKiBAcmV0dXJucyB7Kn1cXG4gKi9cXG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5IChvYmplY3QsIHNwYWNlcywgZGVwdGgpIHtcXG4gIGlmICh0eXBlb2Ygc3BhY2VzID09PSAndW5kZWZpbmVkJykge1xcbiAgICAvLyBwcmltaXRpdmUgdHlwZXNcXG4gICAgcmV0dXJuIF9zdHJpbmdpZnkob2JqZWN0KTtcXG4gIH1cXG5cXG4gIGRlcHRoID0gZGVwdGggfHwgMTtcXG4gIHZhciBzcGFjZSA9IHNwYWNlcyAqIGRlcHRoO1xcbiAgdmFyIHN0ciA9IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/ICdbJyA6ICd7JztcXG4gIHZhciBlbmQgPSBBcnJheS5pc0FycmF5KG9iamVjdCkgPyAnXScgOiAnfSc7XFxuICB2YXIgbGVuZ3RoID0gdHlwZW9mIG9iamVjdC5sZW5ndGggPT09ICdudW1iZXInID8gb2JqZWN0Lmxlbmd0aCA6IE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoO1xcbiAgLy8gYC5yZXBlYXQoKWAgcG9seWZpbGxcXG4gIGZ1bmN0aW9uIHJlcGVhdCAocywgbikge1xcbiAgICByZXR1cm4gbmV3IEFycmF5KG4pLmpvaW4ocyk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfc3RyaW5naWZ5ICh2YWwpIHtcXG4gICAgc3dpdGNoICh0eXBlKHZhbCkpIHtcXG4gICAgICBjYXNlICdudWxsJzpcXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxcbiAgICAgICAgdmFsID0gJ1snICsgdmFsICsgJ10nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgICB2YWwgPSBqc29uU3RyaW5naWZ5KHZhbCwgc3BhY2VzLCBkZXB0aCArIDEpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnYm9vbGVhbic6XFxuICAgICAgY2FzZSAncmVnZXhwJzpcXG4gICAgICBjYXNlICdzeW1ib2wnOlxcbiAgICAgIGNhc2UgJ251bWJlcic6XFxuICAgICAgICB2YWwgPSB2YWwgPT09IDAgJiYgKDEgLyB2YWwpID09PSAtSW5maW5pdHkgLy8gYC0wYFxcbiAgICAgICAgICA/ICctMCdcXG4gICAgICAgICAgOiB2YWwudG9TdHJpbmcoKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2RhdGUnOlxcbiAgICAgICAgdmFyIHNEYXRlID0gaXNOYU4odmFsLmdldFRpbWUoKSkgPyB2YWwudG9TdHJpbmcoKSA6IHZhbC50b0lTT1N0cmluZygpO1xcbiAgICAgICAgdmFsID0gJ1tEYXRlOiAnICsgc0RhdGUgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdidWZmZXInOlxcbiAgICAgICAgdmFyIGpzb24gPSB2YWwudG9KU09OKCk7XFxuICAgICAgICAvLyBCYXNlZCBvbiB0aGUgdG9KU09OIHJlc3VsdFxcbiAgICAgICAganNvbiA9IGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uO1xcbiAgICAgICAgdmFsID0gJ1tCdWZmZXI6ICcgKyBqc29uU3RyaW5naWZ5KGpzb24sIDIsIGRlcHRoICsgMSkgKyAnXSc7XFxuICAgICAgICBicmVhaztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgdmFsID0gKHZhbCA9PT0gJ1tGdW5jdGlvbl0nIHx8IHZhbCA9PT0gJ1tDaXJjdWxhcl0nKVxcbiAgICAgICAgICA/IHZhbFxcbiAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbCk7IC8vIHN0cmluZ1xcbiAgICB9XFxuICAgIHJldHVybiB2YWw7XFxuICB9XFxuXFxuICBmb3IgKHZhciBpIGluIG9iamVjdCkge1xcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGkpKSB7XFxuICAgICAgY29udGludWU7IC8vIG5vdCBteSBidXNpbmVzc1xcbiAgICB9XFxuICAgIC0tbGVuZ3RoO1xcbiAgICBzdHIgKz0gJ1xcXFxuICcgKyByZXBlYXQoJyAnLCBzcGFjZSkgK1xcbiAgICAgIChBcnJheS5pc0FycmF5KG9iamVjdCkgPyAnJyA6ICdcXFwiJyArIGkgKyAnXFxcIjogJykgKyAvLyBrZXlcXG4gICAgICBfc3RyaW5naWZ5KG9iamVjdFtpXSkgKyAvLyB2YWx1ZVxcbiAgICAgIChsZW5ndGggPyAnLCcgOiAnJyk7IC8vIGNvbW1hXFxuICB9XFxuXFxuICByZXR1cm4gc3RyICtcXG4gICAgLy8gW10sIHt9XFxuICAgIChzdHIubGVuZ3RoICE9PSAxID8gJ1xcXFxuJyArIHJlcGVhdCgnICcsIC0tc3BhY2UpICsgZW5kIDogZW5kKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IFRoaW5nIHRoYXQgaGFzIHRoZSBrZXlzIGluIHNvcnRlZCBvcmRlci4gUmVjdXJzaXZlLlxcbiAqXFxuICogSWYgdGhlIFRoaW5nLi4uXFxuICogLSBoYXMgYWxyZWFkeSBiZWVuIHNlZW4sIHJldHVybiBzdHJpbmcgYCdbQ2lyY3VsYXJdJ2BcXG4gKiAtIGlzIGB1bmRlZmluZWRgLCByZXR1cm4gc3RyaW5nIGAnW3VuZGVmaW5lZF0nYFxcbiAqIC0gaXMgYG51bGxgLCByZXR1cm4gdmFsdWUgYG51bGxgXFxuICogLSBpcyBzb21lIG90aGVyIHByaW1pdGl2ZSwgcmV0dXJuIHRoZSB2YWx1ZVxcbiAqIC0gaXMgbm90IGEgcHJpbWl0aXZlIG9yIGFuIGBBcnJheWAsIGBPYmplY3RgLCBvciBgRnVuY3Rpb25gLCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBUaGluZydzIGB0b1N0cmluZygpYCBtZXRob2RcXG4gKiAtIGlzIGEgbm9uLWVtcHR5IGBBcnJheWAsIGBPYmplY3RgLCBvciBgRnVuY3Rpb25gLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gYWdhaW4uXFxuICogLSBpcyBhbiBlbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZW1wdHlSZXByZXNlbnRhdGlvbigpYFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHNlZSB7QGxpbmsgZXhwb3J0cy5zdHJpbmdpZnl9XFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGluZyB0byBpbnNwZWN0LiAgTWF5IG9yIG1heSBub3QgaGF2ZSBwcm9wZXJ0aWVzLlxcbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFjaz1bXV0gU3RhY2sgb2Ygc2VlbiB2YWx1ZXNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVIaW50XSBUeXBlIGhpbnRcXG4gKiBAcmV0dXJuIHsoT2JqZWN0fEFycmF5fEZ1bmN0aW9ufHN0cmluZ3x1bmRlZmluZWQpfVxcbiAqL1xcbmV4cG9ydHMuY2Fub25pY2FsaXplID0gZnVuY3Rpb24gY2Fub25pY2FsaXplICh2YWx1ZSwgc3RhY2ssIHR5cGVIaW50KSB7XFxuICB2YXIgY2Fub25pY2FsaXplZE9iajtcXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXFxuICB2YXIgcHJvcDtcXG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cXG4gIHR5cGVIaW50ID0gdHlwZUhpbnQgfHwgdHlwZSh2YWx1ZSk7XFxuICBmdW5jdGlvbiB3aXRoU3RhY2sgKHZhbHVlLCBmbikge1xcbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcXG4gICAgZm4oKTtcXG4gICAgc3RhY2sucG9wKCk7XFxuICB9XFxuXFxuICBzdGFjayA9IHN0YWNrIHx8IFtdO1xcblxcbiAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xcbiAgfVxcblxcbiAgc3dpdGNoICh0eXBlSGludCkge1xcbiAgICBjYXNlICd1bmRlZmluZWQnOlxcbiAgICBjYXNlICdidWZmZXInOlxcbiAgICBjYXNlICdudWxsJzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWU7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMuY2Fub25pY2FsaXplKGl0ZW0sIHN0YWNrKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdmdW5jdGlvbic6XFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXFxuICAgICAgZm9yIChwcm9wIGluIHZhbHVlKSB7XFxuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0ge307XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBndWFyZC1mb3ItaW4gKi9cXG4gICAgICBpZiAoIWNhbm9uaWNhbGl6ZWRPYmopIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBlbXB0eVJlcHJlc2VudGF0aW9uKHZhbHVlLCB0eXBlSGludCk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cXG4gICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gY2Fub25pY2FsaXplZE9iaiB8fCB7fTtcXG4gICAgICB3aXRoU3RhY2sodmFsdWUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlW2tleV0sIHN0YWNrKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdkYXRlJzpcXG4gICAgY2FzZSAnbnVtYmVyJzpcXG4gICAgY2FzZSAncmVnZXhwJzpcXG4gICAgY2FzZSAnYm9vbGVhbic6XFxuICAgIGNhc2UgJ3N5bWJvbCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZSArICcnO1xcbiAgfVxcblxcbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxufTtcXG5cXG4vKipcXG4gKiBMb29rdXAgZmlsZSBuYW1lcyBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLnV0aWxzXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIEJhc2UgcGF0aCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleHRlbnNpb25zIEZpbGUgZXh0ZW5zaW9ucyB0byBsb29rIGZvci5cXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlY3Vyc2l2ZSBXaGV0aGVyIG9yIG5vdCB0byByZWN1cnNlIGludG8gc3ViZGlyZWN0b3JpZXMuXFxuICogQHJldHVybiB7c3RyaW5nW119IEFuIGFycmF5IG9mIHBhdGhzLlxcbiAqL1xcbmV4cG9ydHMubG9va3VwRmlsZXMgPSBmdW5jdGlvbiBsb29rdXBGaWxlcyAoZmlsZXBhdGgsIGV4dGVuc2lvbnMsIHJlY3Vyc2l2ZSkge1xcbiAgdmFyIGZpbGVzID0gW107XFxuXFxuICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XFxuICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVwYXRoICsgJy5qcycpKSB7XFxuICAgICAgZmlsZXBhdGggKz0gJy5qcyc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZmlsZXMgPSBnbG9iLnN5bmMoZmlsZXBhdGgpO1xcbiAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImNhbm5vdCByZXNvbHZlIHBhdGggKG9yIHBhdHRlcm4pICdcXFwiICsgZmlsZXBhdGggKyBcXFwiJ1xcXCIpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZmlsZXM7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRyeSB7XFxuICAgIHZhciBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZXBhdGgpO1xcbiAgICBpZiAoc3RhdC5pc0ZpbGUoKSkge1xcbiAgICAgIHJldHVybiBmaWxlcGF0aDtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIC8vIGlnbm9yZSBlcnJvclxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBmcy5yZWFkZGlyU3luYyhmaWxlcGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xcbiAgICBmaWxlID0gcGF0aC5qb2luKGZpbGVwYXRoLCBmaWxlKTtcXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGUpO1xcbiAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcXG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcXG4gICAgICAgICAgZmlsZXMgPSBmaWxlcy5jb25jYXQobG9va3VwRmlsZXMoZmlsZSwgZXh0ZW5zaW9ucywgcmVjdXJzaXZlKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFwuKD86JyArIGV4dGVuc2lvbnMuam9pbignfCcpICsgJykkJyk7XFxuICAgIGlmICghc3RhdC5pc0ZpbGUoKSB8fCAhcmUudGVzdChmaWxlKSB8fCBwYXRoLmJhc2VuYW1lKGZpbGUpWzBdID09PSAnLicpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZmlsZXMucHVzaChmaWxlKTtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIGZpbGVzO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYW4gdW5kZWZpbmVkIGVycm9yIHdpdGggYSBtZXNzYWdlIHdhcm5pbmcgdGhlIHVzZXIuXFxuICpcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKi9cXG5cXG5leHBvcnRzLnVuZGVmaW5lZEVycm9yID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIG5ldyBFcnJvcignQ2F1Z2h0IHVuZGVmaW5lZCBlcnJvciwgZGlkIHlvdSB0aHJvdyB3aXRob3V0IHNwZWNpZnlpbmcgd2hhdD8nKTtcXG59O1xcblxcbi8qKlxcbiAqIEdlbmVyYXRlIGFuIHVuZGVmaW5lZCBlcnJvciBpZiBgZXJyYCBpcyBub3QgZGVmaW5lZC5cXG4gKlxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqL1xcblxcbmV4cG9ydHMuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICByZXR1cm4gZXJyIHx8IGV4cG9ydHMudW5kZWZpbmVkRXJyb3IoKTtcXG59O1xcblxcbi8qKlxcbiAqIEBzdW1tYXJ5XFxuICogVGhpcyBGaWx0ZXIgYmFzZWQgb24gYG1vY2hhLWNsZWFuYCBtb2R1bGUuKHNlZTogYGdpdGh1Yi5jb20vcnN0YWNydXovbW9jaGEtY2xlYW5gKVxcbiAqIEBkZXNjcmlwdGlvblxcbiAqIFdoZW4gaW52b2tpbmcgdGhpcyBmdW5jdGlvbiB5b3UgZ2V0IGEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgZ2V0IHRoZSBFcnJvci5zdGFjayBhcyBhbiBpbnB1dCxcXG4gKiBhbmQgcmV0dXJuIGEgcHJldHRpZnkgb3V0cHV0LlxcbiAqIChpLmU6IHN0cmlwIE1vY2hhIGFuZCBpbnRlcm5hbCBub2RlIGZ1bmN0aW9ucyBmcm9tIHN0YWNrIHRyYWNlKS5cXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XFxuICovXFxuZXhwb3J0cy5zdGFja1RyYWNlRmlsdGVyID0gZnVuY3Rpb24gKCkge1xcbiAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIGBwcm9jZXNzLmJyb3dzZXJgXFxuICB2YXIgaXMgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8geyBub2RlOiB0cnVlIH0gOiB7IGJyb3dzZXI6IHRydWUgfTtcXG4gIHZhciBzbGFzaCA9IHBhdGguc2VwO1xcbiAgdmFyIGN3ZDtcXG4gIGlmIChpcy5ub2RlKSB7XFxuICAgIGN3ZCA9IHByb2Nlc3MuY3dkKCkgKyBzbGFzaDtcXG4gIH0gZWxzZSB7XFxuICAgIGN3ZCA9ICh0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnXFxuICAgICAgPyB3aW5kb3cubG9jYXRpb25cXG4gICAgICA6IGxvY2F0aW9uKS5ocmVmLnJlcGxhY2UoL1xcXFwvW14vXSokLywgJy8nKTtcXG4gICAgc2xhc2ggPSAnLyc7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc01vY2hhSW50ZXJuYWwgKGxpbmUpIHtcXG4gICAgcmV0dXJuICh+bGluZS5pbmRleE9mKCdub2RlX21vZHVsZXMnICsgc2xhc2ggKyAnbW9jaGEnICsgc2xhc2gpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCdub2RlX21vZHVsZXMnICsgc2xhc2ggKyAnbW9jaGEuanMnKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignYm93ZXJfY29tcG9uZW50cycgKyBzbGFzaCArICdtb2NoYS5qcycpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKHNsYXNoICsgJ21vY2hhLmpzJykpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNOb2RlSW50ZXJuYWwgKGxpbmUpIHtcXG4gICAgcmV0dXJuICh+bGluZS5pbmRleE9mKCcodGltZXJzLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCcoZXZlbnRzLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCcobm9kZS5qczonKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignKG1vZHVsZS5qczonKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUubmV4dCAobmF0aXZlKScpKSB8fFxcbiAgICAgIGZhbHNlO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFjaykge1xcbiAgICBzdGFjayA9IHN0YWNrLnNwbGl0KCdcXFxcbicpO1xcblxcbiAgICBzdGFjayA9IHN0YWNrLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgbGluZSkge1xcbiAgICAgIGlmIChpc01vY2hhSW50ZXJuYWwobGluZSkpIHtcXG4gICAgICAgIHJldHVybiBsaXN0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXMubm9kZSAmJiBpc05vZGVJbnRlcm5hbChsaW5lKSkge1xcbiAgICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIENsZWFuIHVwIGN3ZChhYnNvbHV0ZSlcXG4gICAgICBpZiAoL1xcXFwoPy4rOlxcXFxkKzpcXFxcZCtcXFxcKT8kLy50ZXN0KGxpbmUpKSB7XFxuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKCcoJyArIGN3ZCwgJygnKTtcXG4gICAgICB9XFxuXFxuICAgICAgbGlzdC5wdXNoKGxpbmUpO1xcbiAgICAgIHJldHVybiBsaXN0O1xcbiAgICB9LCBbXSk7XFxuXFxuICAgIHJldHVybiBzdGFjay5qb2luKCdcXFxcbicpO1xcbiAgfTtcXG59O1xcblxcbi8qKlxcbiAqIENydWRlLCBidXQgZWZmZWN0aXZlLlxcbiAqIEBhcGlcXG4gKiBAcGFyYW0geyp9IHZhbHVlXFxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IGB2YWx1ZWAgaXMgYSBQcm9taXNlXFxuICovXFxuZXhwb3J0cy5pc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UgKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcXG59O1xcblxcbi8qKlxcbiAqIEl0J3MgYSBub29wLlxcbiAqIEBhcGlcXG4gKi9cXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSxyZXF1aXJlKFxcXCJidWZmZXJcXFwiKS5CdWZmZXIpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiYnVmZmVyXFxcIjo0MSxcXFwiZGVidWdcXFwiOjQzLFxcXCJmc1xcXCI6NDAsXFxcImdsb2JcXFwiOjQwLFxcXCJoZVxcXCI6NDgsXFxcInBhdGhcXFwiOjQwLFxcXCJ1dGlsXFxcIjo3Nn1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCdcXG5cXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XFxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxcblxcbnZhciBsb29rdXAgPSBbXVxcbnZhciByZXZMb29rdXAgPSBbXVxcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcXG5cXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XFxuICBsb29rdXBbaV0gPSBjb2RlW2ldXFxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcXG59XFxuXFxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXFxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXFxuXFxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcXG4gIGlmIChsZW4gJSA0ID4gMCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxcbiAgfVxcblxcbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcXG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXFxuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXFxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxcbn1cXG5cXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcXG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxcbiAgcmV0dXJuIChiNjQubGVuZ3RoICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxcbn1cXG5cXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XFxuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcXG5cXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcXG5cXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxcblxcbiAgdmFyIEwgPSAwXFxuXFxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XFxuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXFxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxcbiAgfVxcblxcbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XFxuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXFxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIGFyclxcbn1cXG5cXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXFxufVxcblxcbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHRtcFxcbiAgdmFyIG91dHB1dCA9IFtdXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXFxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxcbiAgfVxcbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xcbiAgdmFyIHRtcFxcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXFxuICB2YXIgb3V0cHV0ID0gJydcXG4gIHZhciBwYXJ0cyA9IFtdXFxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcXG5cXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcXG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcXG4gIH1cXG5cXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XFxuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXFxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXFxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXFxuICAgIG91dHB1dCArPSAnPT0nXFxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcXG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cXG4gICAgb3V0cHV0ICs9ICc9J1xcbiAgfVxcblxcbiAgcGFydHMucHVzaChvdXRwdXQpXFxuXFxuICByZXR1cm4gcGFydHMuam9pbignJylcXG59XFxuXFxufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcblxcbn0se31dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbnZhciBXcml0YWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLldyaXRhYmxlXFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBCcm93c2VyU3Rkb3V0XFxuXFxuXFxuaW5oZXJpdHMoQnJvd3NlclN0ZG91dCwgV3JpdGFibGVTdHJlYW0pXFxuXFxuZnVuY3Rpb24gQnJvd3NlclN0ZG91dChvcHRzKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnJvd3NlclN0ZG91dCkpIHJldHVybiBuZXcgQnJvd3NlclN0ZG91dChvcHRzKVxcblxcbiAgb3B0cyA9IG9wdHMgfHwge31cXG4gIFdyaXRhYmxlU3RyZWFtLmNhbGwodGhpcywgb3B0cylcXG4gIHRoaXMubGFiZWwgPSAob3B0cy5sYWJlbCAhPT0gdW5kZWZpbmVkKSA/IG9wdHMubGFiZWwgOiAnc3Rkb3V0J1xcbn1cXG5cXG5Ccm93c2VyU3Rkb3V0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVua3MsIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIG91dHB1dCA9IGNodW5rcy50b1N0cmluZyA/IGNodW5rcy50b1N0cmluZygpIDogY2h1bmtzXFxuICBpZiAodGhpcy5sYWJlbCA9PT0gZmFsc2UpIHtcXG4gICAgY29uc29sZS5sb2cob3V0cHV0KVxcbiAgfSBlbHNlIHtcXG4gICAgY29uc29sZS5sb2codGhpcy5sYWJlbCsnOicsIG91dHB1dClcXG4gIH1cXG4gIHByb2Nlc3MubmV4dFRpY2soY2IpXFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcInN0cmVhbVxcXCI6NzEsXFxcInV0aWxcXFwiOjc2fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmFyZ3VtZW50c1s0XVszOF1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXFxufSx7XFxcImR1cFxcXCI6Mzh9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyohXFxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXFxuICpcXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cXG4gKiBAbGljZW5zZSAgTUlUXFxuICovXFxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cXG5cXG4ndXNlIHN0cmljdCdcXG5cXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxcblxcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXFxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxcblxcbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXFxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXFxuXFxuLyoqXFxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcXG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXFxuICpcXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxcbiAqXFxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXFxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcXG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cXG4gKi9cXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcXG5cXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgY29uc29sZS5lcnJvcihcXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xcbiAgKVxcbn1cXG5cXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XFxuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XFxuICB0cnkge1xcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XFxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXFxuICB9IGNhdGNoIChlKSB7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxcbiAgfVxcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXFxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG4vKipcXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXFxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cXG4gKlxcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cXG4gKi9cXG5cXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICAvLyBDb21tb24gY2FzZS5cXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xcbiAgICAgIClcXG4gICAgfVxcbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxcbiAgfVxcbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XFxuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXFxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcXG4gICAgdmFsdWU6IG51bGwsXFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXFxuICAgIHdyaXRhYmxlOiBmYWxzZVxcbiAgfSlcXG59XFxuXFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXFxuXFxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcInZhbHVlXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXFxuICB9XFxuXFxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXFxuICB9XFxuXFxuICByZXR1cm4gZnJvbU9iamVjdCh2YWx1ZSlcXG59XFxuXFxuLyoqXFxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXFxuICogQnVmZmVyLmZyb20oYXJyYXkpXFxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxcbiAqKi9cXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcXG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXFxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcXG5cXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJzaXplXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXCJzaXplXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgYXNzZXJ0U2l6ZShzaXplKVxcbiAgaWYgKHNpemUgPD0gMCkge1xcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXFxuICB9XFxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXFxuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxcbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXFxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxcbiAgfVxcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxcbn1cXG5cXG4vKipcXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXFxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxcbiAqKi9cXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcXG59XFxuXFxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcXG4gIGFzc2VydFNpemUoc2l6ZSlcXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXFxufVxcblxcbi8qKlxcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXFxuICogKi9cXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXFxufVxcbi8qKlxcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxcbiAqL1xcbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXFxufVxcblxcbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xcbiAgfVxcblxcbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImVuY29kaW5nXFxcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcXG4gIH1cXG5cXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXFxuXFxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXFxuXFxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcXG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXFxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XFxuICB9XFxuICByZXR1cm4gYnVmXFxufVxcblxcbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFxcJ29mZnNldFxcXFwnIGlzIG91dCBvZiBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcXCdsZW5ndGhcXFxcJyBpcyBvdXQgb2YgYm91bmRzJylcXG4gIH1cXG5cXG4gIHZhciBidWZcXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXFxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxcbiAgfSBlbHNlIHtcXG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcXG4gIH1cXG5cXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXFxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXFxuXFxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIGJ1ZlxcbiAgICB9XFxuXFxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxcbiAgICByZXR1cm4gYnVmXFxuICB9XFxuXFxuICBpZiAob2JqKSB7XFxuICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikge1xcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcXG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxcbiAgICB9XFxuXFxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcXG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXFxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxcbiAgfVxcbiAgcmV0dXJuIGxlbmd0aCB8IDBcXG59XFxuXFxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XFxuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcXG4gICAgbGVuZ3RoID0gMFxcbiAgfVxcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxcbn1cXG5cXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZVxcbn1cXG5cXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXFxuICB9XFxuXFxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcXG5cXG4gIHZhciB4ID0gYS5sZW5ndGhcXG4gIHZhciB5ID0gYi5sZW5ndGhcXG5cXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XFxuICAgICAgeCA9IGFbaV1cXG4gICAgICB5ID0gYltpXVxcbiAgICAgIGJyZWFrXFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXFxuICBpZiAoeSA8IHgpIHJldHVybiAxXFxuICByZXR1cm4gMFxcbn1cXG5cXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XFxuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xcbiAgICBjYXNlICdoZXgnOlxcbiAgICBjYXNlICd1dGY4JzpcXG4gICAgY2FzZSAndXRmLTgnOlxcbiAgICBjYXNlICdhc2NpaSc6XFxuICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgIGNhc2UgJ3VjczInOlxcbiAgICBjYXNlICd1Y3MtMic6XFxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG59XFxuXFxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XFxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImxpc3RcXFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXFxuICB9XFxuXFxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcXG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxcbiAgfVxcblxcbiAgdmFyIGlcXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBsZW5ndGggPSAwXFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxcbiAgdmFyIHBvcyA9IDBcXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBidWYgPSBsaXN0W2ldXFxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcXG4gICAgfVxcbiAgICBidWYuY29weShidWZmZXIsIHBvcylcXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcXG4gIH1cXG4gIHJldHVybiBidWZmZXJcXG59XFxuXFxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XFxuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXFxuICB9XFxuICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcXG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXFxuICB9XFxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcbiAgZm9yICg7Oykge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBsZW5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgY2FzZSB1bmRlZmluZWQ6XFxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXFxuXFxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG5cXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXFxcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcXFwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcXG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXFxuXFxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xcbiAgICBzdGFydCA9IDBcXG4gIH1cXG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXFxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gIH1cXG5cXG4gIGlmIChlbmQgPD0gMCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXFxuICBlbmQgPj4+PSAwXFxuICBzdGFydCA+Pj49IDBcXG5cXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xcblxcbiAgd2hpbGUgKHRydWUpIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXFxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXFxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxcblxcbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcXG4gIHZhciBpID0gYltuXVxcbiAgYltuXSA9IGJbbV1cXG4gIGJbbV0gPSBpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcXG4gIH1cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XFxuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXFxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XFxuICB2YXIgc3RyID0gJydcXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXFxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XFxuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXFxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcXG4gIH1cXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxcbiAgfVxcblxcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgc3RhcnQgPSAwXFxuICB9XFxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcXG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcXG4gIH1cXG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzU3RhcnQgPSAwXFxuICB9XFxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxcbiAgfVxcblxcbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxcbiAgfVxcblxcbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xcbiAgICByZXR1cm4gMFxcbiAgfVxcbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XFxuICAgIHJldHVybiAtMVxcbiAgfVxcbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xcbiAgICByZXR1cm4gMVxcbiAgfVxcblxcbiAgc3RhcnQgPj4+PSAwXFxuICBlbmQgPj4+PSAwXFxuICB0aGlzU3RhcnQgPj4+PSAwXFxuICB0aGlzRW5kID4+Pj0gMFxcblxcbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcXG5cXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXFxuXFxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xcbiAgICAgIHggPSB0aGlzQ29weVtpXVxcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcXG4gIHJldHVybiAwXFxufVxcblxcbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxcbi8vXFxuLy8gQXJndW1lbnRzOlxcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXFxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XFxuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcXG5cXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxcbiAgICBieXRlT2Zmc2V0ID0gMFxcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcXG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXFxuICB9XFxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXFxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcXG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXFxcImZvb1xcXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcXG4gIH1cXG5cXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXFxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcXG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcXG4gICAgZWxzZSByZXR1cm4gLTFcXG4gIH1cXG5cXG4gIC8vIE5vcm1hbGl6ZSB2YWxcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxcbiAgfVxcblxcbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXFxuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIC0xXFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXFxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIGlmIChkaXIpIHtcXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcXG4gIH1cXG5cXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXFxufVxcblxcbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcXG4gIHZhciBpbmRleFNpemUgPSAxXFxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcXG5cXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XFxuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XFxuICAgICAgICByZXR1cm4gLTFcXG4gICAgICB9XFxuICAgICAgaW5kZXhTaXplID0gMlxcbiAgICAgIGFyckxlbmd0aCAvPSAyXFxuICAgICAgdmFsTGVuZ3RoIC89IDJcXG4gICAgICBieXRlT2Zmc2V0IC89IDJcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XFxuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcXG4gICAgICByZXR1cm4gYnVmW2ldXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGlcXG4gIGlmIChkaXIpIHtcXG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XFxuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXFxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXFxuICAgICAgfVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XFxuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XFxuICAgICAgICAgIGZvdW5kID0gZmFsc2VcXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gLTFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXFxufVxcblxcbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XFxuICBpZiAoIWxlbmd0aCkge1xcbiAgICBsZW5ndGggPSByZW1haW5pbmdcXG4gIH0gZWxzZSB7XFxuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXFxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcXG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcXG5cXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XFxuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXFxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxcbiAgfVxcbiAgcmV0dXJuIGlcXG59XFxuXFxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxcbiAgICBvZmZzZXQgPSAwXFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcXG4gICAgb2Zmc2V0ID0gMFxcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcXG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xcbiAgICApXFxuICB9XFxuXFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xcblxcbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXFxuXFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcbiAgZm9yICg7Oykge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XFxuICByZXR1cm4ge1xcbiAgICB0eXBlOiAnQnVmZmVyJyxcXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuICB2YXIgcmVzID0gW11cXG5cXG4gIHZhciBpID0gc3RhcnRcXG4gIHdoaWxlIChpIDwgZW5kKSB7XFxuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXFxuICAgICAgOiAxXFxuXFxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcXG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XFxuXFxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XFxuICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XFxuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgMzpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXFxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcXG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXFxuICAgIH1cXG5cXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcXG4gIH1cXG5cXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxcbn1cXG5cXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXFxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxcblxcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XFxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxcbiAgfVxcblxcbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcXFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXFxcIi5cXG4gIHZhciByZXMgPSAnJ1xcbiAgdmFyIGkgPSAwXFxuICB3aGlsZSAoaSA8IGxlbikge1xcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcXG4gICAgICBTdHJpbmcsXFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxcbiAgICApXFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHJldCA9ICcnXFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgcmV0ID0gJydcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcXG4gIH1cXG4gIHJldHVybiByZXRcXG59XFxuXFxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcXG5cXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cXG5cXG4gIHZhciBvdXQgPSAnJ1xcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcXG4gIH1cXG4gIHJldHVybiBvdXRcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxcbiAgdmFyIHJlcyA9ICcnXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XFxuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBzdGFydCA9IH5+c3RhcnRcXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcXG5cXG4gIGlmIChzdGFydCA8IDApIHtcXG4gICAgc3RhcnQgKz0gbGVuXFxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xcbiAgICBzdGFydCA9IGxlblxcbiAgfVxcblxcbiAgaWYgKGVuZCA8IDApIHtcXG4gICAgZW5kICs9IGxlblxcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcXG4gICAgZW5kID0gbGVuXFxuICB9XFxuXFxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XFxuXFxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICByZXR1cm4gbmV3QnVmXFxufVxcblxcbi8qXFxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXFxuICovXFxuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcXG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxcbiAgfVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuICB9XFxuXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXFxuICB2YXIgbXVsID0gMVxcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcXG4gIH1cXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiB0aGlzW29mZnNldF1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcXG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxcbiAgICB0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXFxuICB9XFxuICBtdWwgKj0gMHg4MFxcblxcbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuXFxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXFxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxcbiAgfVxcbiAgbXVsICo9IDB4ODBcXG5cXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXFxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXFxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XFxuICAgICh0aGlzW29mZnNldCArIDNdKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImJ1ZmZlclxcXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXFxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFwidmFsdWVcXFwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxcbiAgfVxcblxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXFxuICB9XFxuXFxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXFxuICB2YXIgbXVsID0gMVxcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXFxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXFxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxcblxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcXG4gIH1cXG5cXG4gIHZhciBpID0gMFxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBzdWIgPSAwXFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XFxuICAgICAgc3ViID0gMVxcbiAgICB9XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxcblxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcXG4gIH1cXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgc3ViID0gMFxcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XFxuICAgICAgc3ViID0gMVxcbiAgICB9XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXFxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcXG4gIHJldHVybiBvZmZzZXQgKyA0XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXFxuICB9XFxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcXG4gIHJldHVybiBvZmZzZXQgKyA4XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxcbn1cXG5cXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXFxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXFxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxcblxcbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXFxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcXG5cXG4gIC8vIEFyZSB3ZSBvb2I/XFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxcbiAgdmFyIGlcXG5cXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDApIHtcXG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcXG4gICAgICB0YXJnZXQsXFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxcbiAgICAgIHRhcmdldFN0YXJ0XFxuICAgIClcXG4gIH1cXG5cXG4gIHJldHVybiBsZW5cXG59XFxuXFxuLy8gVXNhZ2U6XFxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXFxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXFxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXFxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcXG4gICAgICBzdGFydCA9IDBcXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgZW5jb2RpbmcgPSBlbmRcXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgICB9XFxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XFxuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XFxuICAgICAgICB2YWwgPSBjb2RlXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIHZhbCA9IHZhbCAmIDI1NVxcbiAgfVxcblxcbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXFxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXFxuICB9XFxuXFxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuXFxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXFxuXFxuICBpZiAoIXZhbCkgdmFsID0gMFxcblxcbiAgdmFyIGlcXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgICAgdGhpc1tpXSA9IHZhbFxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxcbiAgICAgID8gdmFsXFxuICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXFxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcXG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG4vLyBIRUxQRVIgRlVOQ1RJT05TXFxuLy8gPT09PT09PT09PT09PT09PVxcblxcbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcXG5cXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XFxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxcXG4gYW5kIFxcXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XFxuICAgIHN0ciA9IHN0ciArICc9J1xcbiAgfVxcbiAgcmV0dXJuIHN0clxcbn1cXG5cXG5mdW5jdGlvbiB0b0hleCAobikge1xcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXFxuICByZXR1cm4gbi50b1N0cmluZygxNilcXG59XFxuXFxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcXG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcXG4gIHZhciBjb2RlUG9pbnRcXG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcXG4gIHZhciBieXRlcyA9IFtdXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXFxuXFxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcXG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcXG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcXG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgICAgY29udGludWVcXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gdmFsaWQgbGVhZFxcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxcblxcbiAgICAgICAgY29udGludWVcXG4gICAgICB9XFxuXFxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcXG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxcbiAgICAgICAgY29udGludWVcXG4gICAgICB9XFxuXFxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgfVxcblxcbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxcblxcbiAgICAvLyBlbmNvZGUgdXRmOFxcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXFxuICAgICAgKVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXFxuICAgICAgKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ5dGVzXFxufVxcblxcbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XFxuICB2YXIgYnl0ZUFycmF5ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxcbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXFxuICB9XFxuICByZXR1cm4gYnl0ZUFycmF5XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XFxuICB2YXIgYywgaGksIGxvXFxuICB2YXIgYnl0ZUFycmF5ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xcblxcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcXG4gICAgaGkgPSBjID4+IDhcXG4gICAgbG8gPSBjICUgMjU2XFxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxcbiAgICBieXRlQXJyYXkucHVzaChoaSlcXG4gIH1cXG5cXG4gIHJldHVybiBieXRlQXJyYXlcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XFxuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXFxufVxcblxcbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXFxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxcbiAgfVxcbiAgcmV0dXJuIGlcXG59XFxuXFxuLy8gQXJyYXlCdWZmZXJzIGZyb20gYW5vdGhlciBjb250ZXh0IChpLmUuIGFuIGlmcmFtZSkgZG8gbm90IHBhc3MgdGhlIGBpbnN0YW5jZW9mYCBjaGVja1xcbi8vIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHtcXG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcXG4gICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKVxcbn1cXG5cXG4vLyBOb2RlIDAuMTAgc3VwcG9ydHMgYEFycmF5QnVmZmVyYCBidXQgbGFja3MgYEFycmF5QnVmZmVyLmlzVmlld2BcXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyAob2JqKSB7XFxuICByZXR1cm4gKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpICYmIEFycmF5QnVmZmVyLmlzVmlldyhvYmopXFxufVxcblxcbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcXG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxcbn1cXG5cXG59LHtcXFwiYmFzZTY0LWpzXFxcIjozNyxcXFwiaWVlZTc1NFxcXCI6NDl9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChCdWZmZXIpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxcblxcbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XFxuICBpZiAoQXJyYXkuaXNBcnJheSkge1xcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xcbiAgfVxcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufVxcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XFxuXFxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcXG59XFxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XFxuXFxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XFxuXFxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcXG59XFxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xcblxcbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xcbn1cXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XFxuXFxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XFxufVxcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcXG5cXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcXG59XFxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59XFxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xcblxcbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcXG59XFxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XFxuXFxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XFxuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XFxufVxcbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XFxuXFxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xcbn1cXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xcblxcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XFxuXFxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcXG5cXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMse1xcXCJpc0J1ZmZlclxcXCI6cmVxdWlyZShcXFwiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXFxcIil9KVxcbn0se1xcXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcXFwiOjUxfV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLyoqXFxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxcbiAqXFxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcXG5leHBvcnRzLmxvZyA9IGxvZztcXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XFxuZXhwb3J0cy5sb2FkID0gbG9hZDtcXG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcXG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXFxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXFxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XFxuXFxuLyoqXFxuICogQ29sb3JzLlxcbiAqL1xcblxcbmV4cG9ydHMuY29sb3JzID0gW1xcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xcbl07XFxuXFxuLyoqXFxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cXG4gKiB0byBzdXBwb3J0IFxcXCIlY1xcXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxcbiAqXFxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcXG4gKi9cXG5cXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XFxuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XFxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxcbiAgLy8gZXhwbGljaXRseVxcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXFxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFxcXC8oXFxcXGQrKS8pKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXFxuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcXG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXFxcLyhcXFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcXFwvKFxcXFxkKykvKSk7XFxufVxcblxcbi8qKlxcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cXG4gKi9cXG5cXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XFxuICB9XFxufTtcXG5cXG5cXG4vKipcXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xcblxcbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXFxuICAgICsgdGhpcy5uYW1lc3BhY2VcXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXFxuICAgICsgYXJnc1swXVxcbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XFxuXFxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xcblxcbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcXG5cXG4gIC8vIHRoZSBmaW5hbCBcXFwiJWNcXFwiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xcbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXFxuICB2YXIgaW5kZXggPSAwO1xcbiAgdmFyIGxhc3RDID0gMDtcXG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcXG4gICAgaW5kZXgrKztcXG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XFxuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXFxuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcXG4gICAgICBsYXN0QyA9IGluZGV4O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcXG59XFxuXFxuLyoqXFxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXFxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFxcXCJmdW5jdGlvblxcXCIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGxvZygpIHtcXG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXFxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxcbiAgICAmJiBjb25zb2xlLmxvZ1xcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcXG59XFxuXFxuLyoqXFxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xcbiAgdHJ5IHtcXG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XFxuICAgIH1cXG4gIH0gY2F0Y2goZSkge31cXG59XFxuXFxuLyoqXFxuICogTG9hZCBgbmFtZXNwYWNlc2AuXFxuICpcXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gbG9hZCgpIHtcXG4gIHZhciByO1xcbiAgdHJ5IHtcXG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcXG4gIH0gY2F0Y2goZSkge31cXG5cXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XFxuICB9XFxuXFxuICByZXR1cm4gcjtcXG59XFxuXFxuLyoqXFxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cXG4gKi9cXG5cXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xcblxcbi8qKlxcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cXG4gKlxcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXFxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cXG4gKlxcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcXG4gIH0gY2F0Y2ggKGUpIHt9XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL2RlYnVnXFxcIjo0NCxcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcblxcbi8qKlxcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxcbiAqXFxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XFxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XFxuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcXG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcXG5cXG4vKipcXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXFxuICovXFxuZXhwb3J0cy5pbnN0YW5jZXMgPSBbXTtcXG5cXG4vKipcXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cXG4gKi9cXG5cXG5leHBvcnRzLm5hbWVzID0gW107XFxuZXhwb3J0cy5za2lwcyA9IFtdO1xcblxcbi8qKlxcbiAqIE1hcCBvZiBzcGVjaWFsIFxcXCIlblxcXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFxcXCJmb3JtYXRcXFwiIGFyZ3VtZW50LlxcbiAqXFxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXFxcIm5cXFwiIGFuZCBcXFwiTlxcXCIuXFxuICovXFxuXFxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XFxuXFxuLyoqXFxuICogU2VsZWN0IGEgY29sb3IuXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxcbiAqIEByZXR1cm4ge051bWJlcn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcXG4gIHZhciBoYXNoID0gMCwgaTtcXG5cXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcXG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxcbiAgfVxcblxcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcXG59XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXFxuICogQHJldHVybiB7RnVuY3Rpb259XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcXG5cXG4gIHZhciBwcmV2VGltZTtcXG5cXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xcbiAgICAvLyBkaXNhYmxlZD9cXG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XFxuXFxuICAgIHZhciBzZWxmID0gZGVidWc7XFxuXFxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XFxuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XFxuICAgIHNlbGYuZGlmZiA9IG1zO1xcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcXG4gICAgc2VsZi5jdXJyID0gY3VycjtcXG4gICAgcHJldlRpbWUgPSBjdXJyO1xcblxcbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xcbiAgICB9XFxuXFxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcXG5cXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXFxuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xcbiAgICB9XFxuXFxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXFxuICAgIHZhciBpbmRleCA9IDA7XFxuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XFxuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xcbiAgICAgIGluZGV4Kys7XFxuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XFxuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XFxuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XFxuXFxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XFxuICAgICAgICBpbmRleC0tO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbWF0Y2g7XFxuICAgIH0pO1xcblxcbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcXG5cXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XFxuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xcbiAgfVxcblxcbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcXG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcXG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xcblxcbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XFxuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XFxuICB9XFxuXFxuICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcXG5cXG4gIHJldHVybiBkZWJ1ZztcXG59XFxuXFxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XFxuICB2YXIgaW5kZXggPSBleHBvcnRzLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcXG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcXG5cXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcXG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcXG5cXG4gIHZhciBpO1xcbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXFxccyxdKy8pO1xcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcXG5cXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcXFwqL2csICcuKj8nKTtcXG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XFxuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGRpc2FibGUoKSB7XFxuICBleHBvcnRzLmVuYWJsZSgnJyk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHJldHVybiB7Qm9vbGVhbn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xcbiAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbiAgdmFyIGksIGxlbjtcXG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogQ29lcmNlIGB2YWxgLlxcbiAqXFxuICogQHBhcmFtIHtNaXhlZH0gdmFsXFxuICogQHJldHVybiB7TWl4ZWR9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xcbiAgcmV0dXJuIHZhbDtcXG59XFxuXFxufSx7XFxcIm1zXFxcIjo1NH1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiFcXG5cXG4gZGlmZiB2My41LjBcXG5cXG5Tb2Z0d2FyZSBMaWNlbnNlIEFncmVlbWVudCAoQlNEIExpY2Vuc2UpXFxuXFxuQ29weXJpZ2h0IChjKSAyMDA5LTIwMTUsIEtldmluIERlY2tlciA8a3BkZWNrZXJAZ21haWwuY29tPlxcblxcbkFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBvZiB0aGlzIHNvZnR3YXJlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcXG4gIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGVcXG4gIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxcbiAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZVxcbiAgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyXFxuICBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiogTmVpdGhlciB0aGUgbmFtZSBvZiBLZXZpbiBEZWNrZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcXG4gIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcXG4gIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3JcXG4gIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCIgQU5EIEFOWSBFWFBSRVNTIE9SXFxuSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcXG5DT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXFxuREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxcbkRBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSXFxuSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVFxcbk9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG5AbGljZW5zZVxcbiovXFxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcXG5cXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XFxuXFx0ZWxzZSBpZihmYWxzZSlcXG5cXHRcXHRkZWZpbmUoW10sIGZhY3RvcnkpO1xcblxcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxcblxcdFxcdGV4cG9ydHNbXFxcIkpzRGlmZlxcXCJdID0gZmFjdG9yeSgpO1xcblxcdGVsc2VcXG5cXHRcXHRyb290W1xcXCJKc0RpZmZcXFwiXSA9IGZhY3RvcnkoKTtcXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxcbi8qKioqKiovIFxcdC8vIFRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xcblxcbi8qKioqKiovIFxcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xcblxcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxcbi8qKioqKiovIFxcdFxcdFxcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xcblxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9LFxcbi8qKioqKiovIFxcdFxcdFxcdGlkOiBtb2R1bGVJZCxcXG4vKioqKioqLyBcXHRcXHRcXHRsb2FkZWQ6IGZhbHNlXFxuLyoqKioqKi8gXFx0XFx0fTtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRcXHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcXG4vKioqKioqLyBcXHRcXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0fVxcblxcblxcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcXG5cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XFxuXFxuLyoqKioqKi8gXFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcXFwiXFxcIjtcXG5cXG4vKioqKioqLyBcXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcXG4vKioqKioqLyBcXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcXG4vKioqKioqLyB9KVxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqKi8gKFtcXG4vKiAwICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb1hNTCA9IGV4cG9ydHMuY29udmVydENoYW5nZXNUb0RNUCA9IGV4cG9ydHMubWVyZ2UgPSBleHBvcnRzLnBhcnNlUGF0Y2ggPSBleHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGV4cG9ydHMuYXBwbHlQYXRjaCA9IGV4cG9ydHMuY3JlYXRlUGF0Y2ggPSBleHBvcnRzLmNyZWF0ZVR3b0ZpbGVzUGF0Y2ggPSBleHBvcnRzLnN0cnVjdHVyZWRQYXRjaCA9IGV4cG9ydHMuZGlmZkFycmF5cyA9IGV4cG9ydHMuZGlmZkpzb24gPSBleHBvcnRzLmRpZmZDc3MgPSBleHBvcnRzLmRpZmZTZW50ZW5jZXMgPSBleHBvcnRzLmRpZmZUcmltbWVkTGluZXMgPSBleHBvcnRzLmRpZmZMaW5lcyA9IGV4cG9ydHMuZGlmZldvcmRzV2l0aFNwYWNlID0gZXhwb3J0cy5kaWZmV29yZHMgPSBleHBvcnRzLmRpZmZDaGFycyA9IGV4cG9ydHMuRGlmZiA9IHVuZGVmaW5lZDtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jaGFyYWN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3dvcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3NlbnRlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2pzb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19hcHBseSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbWVyZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19kbXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL194bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qIFNlZSBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zIG9mIHVzZSAqL1xcblxcblxcdC8qXFxuXFx0ICogVGV4dCBkaWZmIGltcGxlbWVudGF0aW9uLlxcblxcdCAqXFxuXFx0ICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgQVBJUzpcXG5cXHQgKiBKc0RpZmYuZGlmZkNoYXJzOiBDaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIGRpZmZcXG5cXHQgKiBKc0RpZmYuZGlmZldvcmRzOiBXb3JkIChhcyBkZWZpbmVkIGJ5IFxcXFxiIHJlZ2V4KSBkaWZmIHdoaWNoIGlnbm9yZXMgd2hpdGVzcGFjZVxcblxcdCAqIEpzRGlmZi5kaWZmTGluZXM6IExpbmUgYmFzZWQgZGlmZlxcblxcdCAqXFxuXFx0ICogSnNEaWZmLmRpZmZDc3M6IERpZmYgdGFyZ2V0ZWQgYXQgQ1NTIGNvbnRlbnRcXG5cXHQgKlxcblxcdCAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxcblxcdCAqIFxcXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcXFwiIChNeWVycywgMTk4NikuXFxuXFx0ICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcXG5cXHQgKi9cXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL0RpZmYgPSBfYmFzZTJbJ2RlZmF1bHQnXTtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ2hhcnMgPSBfY2hhcmFjdGVyLmRpZmZDaGFycztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHMgPSBfd29yZC5kaWZmV29yZHM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzV2l0aFNwYWNlID0gX3dvcmQuZGlmZldvcmRzV2l0aFNwYWNlO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZMaW5lcyA9IF9saW5lLmRpZmZMaW5lcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmVHJpbW1lZExpbmVzID0gX2xpbmUuZGlmZlRyaW1tZWRMaW5lcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmU2VudGVuY2VzID0gX3NlbnRlbmNlLmRpZmZTZW50ZW5jZXM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNzcyA9IF9jc3MuZGlmZkNzcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmSnNvbiA9IF9qc29uLmRpZmZKc29uO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZBcnJheXMgPSBfYXJyYXkuZGlmZkFycmF5cztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9zdHJ1Y3R1cmVkUGF0Y2ggPSBfY3JlYXRlLnN0cnVjdHVyZWRQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVUd29GaWxlc1BhdGNoID0gX2NyZWF0ZS5jcmVhdGVUd29GaWxlc1BhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NyZWF0ZVBhdGNoID0gX2NyZWF0ZS5jcmVhdGVQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcHBseVBhdGNoID0gX2FwcGx5LmFwcGx5UGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaGVzID0gX2FwcGx5LmFwcGx5UGF0Y2hlcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9wYXJzZVBhdGNoID0gX3BhcnNlLnBhcnNlUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbWVyZ2UgPSBfbWVyZ2UubWVyZ2U7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udmVydENoYW5nZXNUb0RNUCA9IF9kbXAuY29udmVydENoYW5nZXNUb0RNUDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb252ZXJ0Q2hhbmdlc1RvWE1MID0gX3htbC5jb252ZXJ0Q2hhbmdlc1RvWE1MO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nhbm9uaWNhbGl6ZSA9IF9qc29uLmNhbm9uaWNhbGl6ZTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzWydkZWZhdWx0J10gPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL0RpZmY7XFxuXFx0ZnVuY3Rpb24gRGlmZigpIHt9XFxuXFxuXFx0RGlmZi5wcm90b3R5cGUgPSB7XFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZjogZnVuY3Rpb24gZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZykge1xcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XFxuXFxuXFx0ICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XFxuXFx0ICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdCAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcXG5cXHQgICAgICBvcHRpb25zID0ge307XFxuXFx0ICAgIH1cXG5cXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXG5cXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcblxcdCAgICBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XFxuXFx0ICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB2YWx1ZSk7XFxuXFx0ICAgICAgICB9LCAwKTtcXG5cXHQgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICByZXR1cm4gdmFsdWU7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIEFsbG93IHN1YmNsYXNzZXMgdG8gbWFzc2FnZSB0aGUgaW5wdXQgcHJpb3IgdG8gcnVubmluZ1xcblxcdCAgICBvbGRTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChvbGRTdHJpbmcpO1xcblxcdCAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xcblxcblxcdCAgICBvbGRTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUob2xkU3RyaW5nKSk7XFxuXFx0ICAgIG5ld1N0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShuZXdTdHJpbmcpKTtcXG5cXG5cXHQgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXFxuXFx0ICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoO1xcblxcdCAgICB2YXIgZWRpdExlbmd0aCA9IDE7XFxuXFx0ICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xcblxcdCAgICB2YXIgYmVzdFBhdGggPSBbeyBuZXdQb3M6IC0xLCBjb21wb25lbnRzOiBbXSB9XTtcXG5cXG5cXHQgICAgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcXG5cXHQgICAgdmFyIG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xcblxcdCAgICBpZiAoYmVzdFBhdGhbMF0ubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcXG5cXHQgICAgICAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcXG5cXHQgICAgICByZXR1cm4gZG9uZShbeyB2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RoIH1dKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXFxuXFx0ICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xcblxcdCAgICAgIGZvciAodmFyIGRpYWdvbmFsUGF0aCA9IC0xICogZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoIDw9IGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCArPSAyKSB7XFxuXFx0ICAgICAgICB2YXIgYmFzZVBhdGggPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcdCAgICAgICAgdmFyIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSxcXG5cXHQgICAgICAgICAgICByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV0sXFxuXFx0ICAgICAgICAgICAgX29sZFBvcyA9IChyZW1vdmVQYXRoID8gcmVtb3ZlUGF0aC5uZXdQb3MgOiAwKSAtIGRpYWdvbmFsUGF0aDtcXG5cXHQgICAgICAgIGlmIChhZGRQYXRoKSB7XFxuXFx0ICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XFxuXFx0ICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGNhbkFkZCA9IGFkZFBhdGggJiYgYWRkUGF0aC5uZXdQb3MgKyAxIDwgbmV3TGVuLFxcblxcdCAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBfb2xkUG9zICYmIF9vbGRQb3MgPCBvbGRMZW47XFxuXFx0ICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XFxuXFx0ICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcXG5cXHQgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IHVuZGVmaW5lZDtcXG5cXHQgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxcblxcdCAgICAgICAgLy8gcGF0aCB3aG9zZSBwb3NpdGlvbiBpbiB0aGUgbmV3IHN0cmluZyBpcyB0aGUgZmFydGhlc3QgZnJvbSB0aGUgb3JpZ2luXFxuXFx0ICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXFxuXFx0ICAgICAgICBpZiAoIWNhbkFkZCB8fCBjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1Bvcykge1xcblxcdCAgICAgICAgICBiYXNlUGF0aCA9IGNsb25lUGF0aChyZW1vdmVQYXRoKTtcXG5cXHQgICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICBiYXNlUGF0aCA9IGFkZFBhdGg7IC8vIE5vIG5lZWQgdG8gY2xvbmUsIHdlJ3ZlIHB1bGxlZCBpdCBmcm9tIHRoZSBsaXN0XFxuXFx0ICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xcblxcdCAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdHJ1ZSwgdW5kZWZpbmVkKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIF9vbGRQb3MgPSBzZWxmLmV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpO1xcblxcblxcdCAgICAgICAgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcXG5cXHQgICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBfb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIGRvbmUoYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHNlbGYudXNlTG9uZ2VzdFRva2VuKSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAvLyBPdGhlcndpc2UgdHJhY2sgdGhpcyBwYXRoIGFzIGEgcG90ZW50aWFsIGNhbmRpZGF0ZSBhbmQgY29udGludWUuXFxuXFx0ICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSBiYXNlUGF0aDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgZWRpdExlbmd0aCsrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFBlcmZvcm1zIHRoZSBsZW5ndGggb2YgZWRpdCBpdGVyYXRpb24uIElzIGEgYml0IGZ1Z2x5IGFzIHRoaXMgaGFzIHRvIHN1cHBvcnQgdGhlXFxuXFx0ICAgIC8vIHN5bmMgYW5kIGFzeW5jIG1vZGUgd2hpY2ggaXMgbmV2ZXIgZnVuLiBMb29wcyBvdmVyIGV4ZWNFZGl0TGVuZ3RoIHVudGlsIGEgdmFsdWVcXG5cXHQgICAgLy8gaXMgcHJvZHVjZWQuXFxuXFx0ICAgIGlmIChjYWxsYmFjaykge1xcblxcdCAgICAgIChmdW5jdGlvbiBleGVjKCkge1xcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCB3ZSB3YW50IHRvIGJlIHNhZmUuXFxuXFx0ICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXFxuXFx0ICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xcblxcdCAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xcblxcdCAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgIGlmICghZXhlY0VkaXRMZW5ndGgoKSkge1xcblxcdCAgICAgICAgICAgIGV4ZWMoKTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfSwgMCk7XFxuXFx0ICAgICAgfSkoKTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICB3aGlsZSAoZWRpdExlbmd0aCA8PSBtYXhFZGl0TGVuZ3RoKSB7XFxuXFx0ICAgICAgICB2YXIgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcXG5cXHQgICAgICAgIGlmIChyZXQpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIHJldDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcHVzaENvbXBvbmVudDogZnVuY3Rpb24gcHVzaENvbXBvbmVudChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xcblxcdCAgICB2YXIgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcXG5cXHQgICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XFxuXFx0ICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcXG5cXHQgICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXFxuXFx0ICAgICAgY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdID0geyBjb3VudDogbGFzdC5jb3VudCArIDEsIGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGNvbXBvbmVudHMucHVzaCh7IGNvdW50OiAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfSk7XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZXh0cmFjdENvbW1vbjogZnVuY3Rpb24gZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCkge1xcblxcdCAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcXG5cXHQgICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXFxuXFx0ICAgICAgICBuZXdQb3MgPSBiYXNlUGF0aC5uZXdQb3MsXFxuXFx0ICAgICAgICBvbGRQb3MgPSBuZXdQb3MgLSBkaWFnb25hbFBhdGgsXFxuXFx0ICAgICAgICBjb21tb25Db3VudCA9IDA7XFxuXFx0ICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3U3RyaW5nW25ld1BvcyArIDFdLCBvbGRTdHJpbmdbb2xkUG9zICsgMV0pKSB7XFxuXFx0ICAgICAgbmV3UG9zKys7XFxuXFx0ICAgICAgb2xkUG9zKys7XFxuXFx0ICAgICAgY29tbW9uQ291bnQrKztcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAoY29tbW9uQ291bnQpIHtcXG5cXHQgICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goeyBjb3VudDogY29tbW9uQ291bnQgfSk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgYmFzZVBhdGgubmV3UG9zID0gbmV3UG9zO1xcblxcdCAgICByZXR1cm4gb2xkUG9zO1xcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9lcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhsZWZ0LCByaWdodCkge1xcblxcdCAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhcmF0b3IpIHtcXG5cXHQgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbXBhcmF0b3IobGVmdCwgcmlnaHQpO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XFxuXFx0ICAgIH1cXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcmVtb3ZlRW1wdHk6IGZ1bmN0aW9uIHJlbW92ZUVtcHR5KGFycmF5KSB7XFxuXFx0ICAgIHZhciByZXQgPSBbXTtcXG5cXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgIGlmIChhcnJheVtpXSkge1xcblxcdCAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICByZXR1cm4gcmV0O1xcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYXN0SW5wdXQ6IGZ1bmN0aW9uIGNhc3RJbnB1dCh2YWx1ZSkge1xcblxcdCAgICByZXR1cm4gdmFsdWU7XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3Rva2VuaXplOiBmdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSkge1xcblxcdCAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpO1xcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9qb2luOiBmdW5jdGlvbiBqb2luKGNoYXJzKSB7XFxuXFx0ICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcXG5cXHQgIHZhciBjb21wb25lbnRQb3MgPSAwLFxcblxcdCAgICAgIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxcblxcdCAgICAgIG5ld1BvcyA9IDAsXFxuXFx0ICAgICAgb2xkUG9zID0gMDtcXG5cXG5cXHQgIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XFxuXFx0ICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XFxuXFx0ICAgIGlmICghY29tcG9uZW50LnJlbW92ZWQpIHtcXG5cXHQgICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcXG5cXHQgICAgICAgIHZhciB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XFxuXFx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcXG5cXHQgICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xcblxcdCAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcXG5cXHQgICAgICAgIH0pO1xcblxcblxcdCAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcblxcdCAgICAgIC8vIENvbW1vbiBjYXNlXFxuXFx0ICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcXG5cXHQgICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihvbGRTdHJpbmcuc2xpY2Uob2xkUG9zLCBvbGRQb3MgKyBjb21wb25lbnQuY291bnQpKTtcXG5cXHQgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcblxcdCAgICAgIC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXFxuXFx0ICAgICAgLy8gVGhlIGRpZmZpbmcgYWxnb3JpdGhtIGlzIHRpZWQgdG8gYWRkIHRoZW4gcmVtb3ZlIG91dHB1dCBhbmQgdGhpcyBpcyB0aGUgc2ltcGxlc3RcXG5cXHQgICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cXG5cXHQgICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcXG5cXHQgICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xcblxcdCAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXSA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcXG5cXHQgICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFNwZWNpYWwgY2FzZSBoYW5kbGUgZm9yIHdoZW4gb25lIHRlcm1pbmFsIGlzIGlnbm9yZWQgKGkuZS4gd2hpdGVzcGFjZSkuXFxuXFx0ICAvLyBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZSB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cXG5cXHQgIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIHN0cmluZyBtb2RlLlxcblxcdCAgdmFyIGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xcblxcdCAgaWYgKGNvbXBvbmVudExlbiA+IDEgJiYgdHlwZW9mIGxhc3RDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnICYmIChsYXN0Q29tcG9uZW50LmFkZGVkIHx8IGxhc3RDb21wb25lbnQucmVtb3ZlZCkgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XFxuXFx0ICAgIGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMl0udmFsdWUgKz0gbGFzdENvbXBvbmVudC52YWx1ZTtcXG5cXHQgICAgY29tcG9uZW50cy5wb3AoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBjb21wb25lbnRzO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xcblxcdCAgcmV0dXJuIHsgbmV3UG9zOiBwYXRoLm5ld1BvcywgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApIH07XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDIgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuY2hhcmFjdGVyRGlmZiA9IHVuZGVmaW5lZDtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDaGFycyA9IGRpZmZDaGFycztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBjaGFyYWN0ZXJEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2hhcmFjdGVyRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHRmdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcXG5cXHQgIHJldHVybiBjaGFyYWN0ZXJEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAzICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLndvcmREaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzID0gZGlmZldvcmRzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3Jkc1dpdGhTcGFjZSA9IGRpZmZXb3Jkc1dpdGhTcGFjZTtcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyYW1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXFxuXFx0Ly9cXG5cXHQvLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XFxuXFx0Ly8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxcblxcdC8vICAtIFUrMDBENyAgw5cgTXVsdGlwbGljYXRpb24gc2lnblxcblxcdC8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxcblxcdC8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXFxuXFx0Ly8gTGF0aW4gRXh0ZW5kZWQtQiwgMDE4MOKAkzAyNEZcXG5cXHQvLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcXG5cXHQvLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXFxuXFx0Ly8gIC0gVSswMkM3ICDLhyAmIzcxMTsgIENhcm9uXFxuXFx0Ly8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXFxuXFx0Ly8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxcblxcdC8vICAtIFUrMDJEQSAgy5ogJiM3MzA7ICBSaW5nIEFib3ZlXFxuXFx0Ly8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xcblxcdC8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxcblxcdC8vICAtIFUrMDJERCAgy50gJiM3MzM7ICBEb3VibGUgQWN1dGUgQWNjZW50XFxuXFx0Ly8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcXG5cXHR2YXIgZXh0ZW5kZWRXb3JkQ2hhcnMgPSAvXltBLVphLXpcXFxceEMwLVxcXFx1MDJDNlxcXFx1MDJDOC1cXFxcdTAyRDdcXFxcdTAyREUtXFxcXHUwMkZGXFxcXHUxRTAwLVxcXFx1MUVGRl0rJC87XFxuXFxuXFx0dmFyIHJlV2hpdGVzcGFjZSA9IC9cXFxcUy87XFxuXFxuXFx0dmFyIHdvcmREaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovd29yZERpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0d29yZERpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XFxuXFx0ICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UpIHtcXG5cXHQgICAgbGVmdCA9IGxlZnQudG9Mb3dlckNhc2UoKTtcXG5cXHQgICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlICYmICFyZVdoaXRlc3BhY2UudGVzdChsZWZ0KSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QocmlnaHQpO1xcblxcdH07XFxuXFx0d29yZERpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIHZhciB0b2tlbnMgPSB2YWx1ZS5zcGxpdCgvKFxcXFxzK3xcXFxcYikvKTtcXG5cXG5cXHQgIC8vIEpvaW4gdGhlIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzLiBUaGlzIGlzIHByaW1hcmlseSB0aGUgZXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldC5cXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xcblxcdCAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcXG5cXHQgICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcXG5cXHQgICAgICB0b2tlbnNbaV0gKz0gdG9rZW5zW2kgKyAyXTtcXG5cXHQgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcXG5cXHQgICAgICBpLS07XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiB0b2tlbnM7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmV29yZHMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcXG5cXHQgIG9wdGlvbnMgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJhbXMuZ2VuZXJhdGVPcHRpb25zKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhvcHRpb25zLCB7IGlnbm9yZVdoaXRlc3BhY2U6IHRydWUgfSk7XFxuXFx0ICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xcblxcdCAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA0ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2dlbmVyYXRlT3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucztcXG5cXHRmdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcXG5cXHQgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdCAgICBkZWZhdWx0cy5jYWxsYmFjayA9IG9wdGlvbnM7XFxuXFx0ICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcXG5cXHQgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XFxuXFx0ICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG5cXHQgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xcblxcdCAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdCAgcmV0dXJuIGRlZmF1bHRzO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA1ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmxpbmVEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkxpbmVzID0gZGlmZkxpbmVzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZUcmltbWVkTGluZXMgPSBkaWZmVHJpbW1lZExpbmVzO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJhbXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgbGluZURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9saW5lRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHRsaW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgdmFyIHJldExpbmVzID0gW10sXFxuXFx0ICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxcXG58XFxcXHJcXFxcbikvKTtcXG5cXG5cXHQgIC8vIElnbm9yZSB0aGUgZmluYWwgZW1wdHkgdG9rZW4gdGhhdCBvY2N1cnMgaWYgdGhlIHN0cmluZyBlbmRzIHdpdGggYSBuZXcgbGluZVxcblxcdCAgaWYgKCFsaW5lc0FuZE5ld2xpbmVzW2xpbmVzQW5kTmV3bGluZXMubGVuZ3RoIC0gMV0pIHtcXG5cXHQgICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzQW5kTmV3bGluZXMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgdmFyIGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xcblxcblxcdCAgICBpZiAoaSAlIDIgJiYgIXRoaXMub3B0aW9ucy5uZXdsaW5lSXNUb2tlbikge1xcblxcdCAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlKSB7XFxuXFx0ICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIHJldExpbmVzLnB1c2gobGluZSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiByZXRMaW5lcztcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG5cXHQgIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XFxuXFx0fVxcblxcdGZ1bmN0aW9uIGRpZmZUcmltbWVkTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuXFx0ICB2YXIgb3B0aW9ucyA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcmFtcy5nZW5lcmF0ZU9wdGlvbnMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKGNhbGxiYWNrLCB7IGlnbm9yZVdoaXRlc3BhY2U6IHRydWUgfSk7XFxuXFx0ICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDYgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuc2VudGVuY2VEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZlNlbnRlbmNlcyA9IGRpZmZTZW50ZW5jZXM7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgc2VudGVuY2VEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovc2VudGVuY2VEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdHNlbnRlbmNlRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxcXFMuKz9bLiE/XSkoPz1cXFxccyt8JCkvKTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGRpZmZTZW50ZW5jZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuXFx0ICByZXR1cm4gc2VudGVuY2VEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5jc3NEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNzcyA9IGRpZmZDc3M7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgY3NzRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nzc0RpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0Y3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oW3t9OjssXXxcXFxccyspLyk7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcblxcdCAgcmV0dXJuIGNzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA4ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmpzb25EaWZmID0gdW5kZWZpbmVkO1xcblxcblxcdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmSnNvbiA9IGRpZmZKc29uO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nhbm9uaWNhbGl6ZSA9IGNhbm9uaWNhbGl6ZTtcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuXFx0dmFyIGpzb25EaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovanNvbkRpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0Ly8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcXG5cXHQvLyBkYW5nbGluZyBjb21tYSBhbmQgdGhlIG90aGVyIGRvZXNuJ3QuIFR1cm5zIG91dCBpbmNsdWRpbmcgdGhlIGRhbmdsaW5nIGNvbW1hIHlpZWxkcyB0aGUgbmljZXN0IG91dHB1dDpcXG5cXHRqc29uRGlmZi51c2VMb25nZXN0VG9rZW4gPSB0cnVlO1xcblxcblxcdGpzb25EaWZmLnRva2VuaXplID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lLmxpbmVEaWZmIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLnRva2VuaXplO1xcblxcdGpzb25EaWZmLmNhc3RJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfb3B0aW9ucyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovdGhpcy5vcHRpb25zLFxcblxcdCAgICAgIHVuZGVmaW5lZFJlcGxhY2VtZW50ID0gX29wdGlvbnMudW5kZWZpbmVkUmVwbGFjZW1lbnQsXFxuXFx0ICAgICAgX29wdGlvbnMkc3RyaW5naWZ5UmVwID0gX29wdGlvbnMuc3RyaW5naWZ5UmVwbGFjZXIsXFxuXFx0ICAgICAgc3RyaW5naWZ5UmVwbGFjZXIgPSBfb3B0aW9ucyRzdHJpbmdpZnlSZXAgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChrLCB2KSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCove1xcblxcdCAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIGVuZCovdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2XFxuXFx0ICAgICk7XFxuXFx0ICB9IDogX29wdGlvbnMkc3RyaW5naWZ5UmVwO1xcblxcblxcblxcdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgc3RyaW5naWZ5UmVwbGFjZXIpLCBzdHJpbmdpZnlSZXBsYWNlciwgJyAgJyk7XFxuXFx0fTtcXG5cXHRqc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcXG5cXHQgIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLnByb3RvdHlwZS5lcXVhbHMuY2FsbChqc29uRGlmZiwgbGVmdC5yZXBsYWNlKC8sKFtcXFxcclxcXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcXFxyXFxcXG5dKS9nLCAnJDEnKSlcXG5cXHQgICk7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykge1xcblxcdCAgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXHQvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cXG5cXHQvLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcXFwic3RhY2tcXFwiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC4gQWNjZXB0cyBhbiBvcHRpb25hbCByZXBsYWNlclxcblxcdGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShvYmosIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KSB7XFxuXFx0ICBzdGFjayA9IHN0YWNrIHx8IFtdO1xcblxcdCAgcmVwbGFjZW1lbnRTdGFjayA9IHJlcGxhY2VtZW50U3RhY2sgfHwgW107XFxuXFxuXFx0ICBpZiAocmVwbGFjZXIpIHtcXG5cXHQgICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xcblxcdCAgfVxcblxcblxcdCAgdmFyIGkgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdCAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XFxuXFx0ICAgIGlmIChzdGFja1tpXSA9PT0gb2JqKSB7XFxuXFx0ICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBjYW5vbmljYWxpemVkT2JqID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQgIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcXG5cXHQgICAgc3RhY2sucHVzaChvYmopO1xcblxcdCAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xcblxcdCAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XFxuXFx0ICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHQgICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xcblxcdCAgICB9XFxuXFx0ICAgIHN0YWNrLnBvcCgpO1xcblxcdCAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xcblxcdCAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xcblxcdCAgICBvYmogPSBvYmoudG9KU09OKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8odHlwZW9mIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XFxuXFx0ICAgIHN0YWNrLnB1c2gob2JqKTtcXG5cXHQgICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xcblxcdCAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XFxuXFx0ICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXFxuXFx0ICAgICAgICBfa2V5ID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXHQgICAgZm9yIChfa2V5IGluIG9iaikge1xcblxcdCAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuXFx0ICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xcblxcdCAgICAgICAgc29ydGVkS2V5cy5wdXNoKF9rZXkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcXG5cXHQgICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZEtleXMubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHQgICAgICBfa2V5ID0gc29ydGVkS2V5c1tpXTtcXG5cXHQgICAgICBjYW5vbmljYWxpemVkT2JqW19rZXldID0gY2Fub25pY2FsaXplKG9ialtfa2V5XSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBfa2V5KTtcXG5cXHQgICAgfVxcblxcdCAgICBzdGFjay5wb3AoKTtcXG5cXHQgICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcXG5cXHQgIH0gZWxzZSB7XFxuXFx0ICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogOSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5hcnJheURpZmYgPSB1bmRlZmluZWQ7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQXJyYXlzID0gZGlmZkFycmF5cztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBhcnJheURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcnJheURpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0YXJyYXlEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcXG5cXHR9O1xcblxcdGFycmF5RGlmZi5qb2luID0gYXJyYXlEaWZmLnJlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICByZXR1cm4gdmFsdWU7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykge1xcblxcdCAgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDEwICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Rpc3RhbmNlSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9kaXN0YW5jZUl0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3RhbmNlSXRlcmF0b3IpO1xcblxcblxcdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Z1bmN0aW9uIGFwcGx5UGF0Y2goc291cmNlLCB1bmlEaWZmKSB7XFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XFxuXFxuXFx0ICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XFxuXFx0ICAgIHVuaURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJzZS5wYXJzZVBhdGNoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh1bmlEaWZmKTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XFxuXFx0ICAgIGlmICh1bmlEaWZmLmxlbmd0aCA+IDEpIHtcXG5cXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwcGx5UGF0Y2ggb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGlucHV0LicpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHVuaURpZmYgPSB1bmlEaWZmWzBdO1xcblxcdCAgfVxcblxcblxcdCAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XFxuXFx0ICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vKSxcXG5cXHQgICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdL2cpIHx8IFtdLFxcblxcdCAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcXG5cXHQgICAgICBjb21wYXJlTGluZSA9IG9wdGlvbnMuY29tcGFyZUxpbmUgfHwgZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmUsIG9wZXJhdGlvbiwgcGF0Y2hDb250ZW50KSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCove1xcblxcdCAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIGVuZCovbGluZSA9PT0gcGF0Y2hDb250ZW50XFxuXFx0ICAgICk7XFxuXFx0ICB9LFxcblxcdCAgICAgIGVycm9yQ291bnQgPSAwLFxcblxcdCAgICAgIGZ1enpGYWN0b3IgPSBvcHRpb25zLmZ1enpGYWN0b3IgfHwgMCxcXG5cXHQgICAgICBtaW5MaW5lID0gMCxcXG5cXHQgICAgICBvZmZzZXQgPSAwLFxcblxcdCAgICAgIHJlbW92ZUVPRk5MID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyxcXG5cXHQgICAgICBhZGRFT0ZOTCA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0ICAvKipcXG5cXHQgICAqIENoZWNrcyBpZiB0aGUgaHVuayBleGFjdGx5IGZpdHMgb24gdGhlIHByb3ZpZGVkIGxvY2F0aW9uXFxuXFx0ICAgKi9cXG5cXHQgIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XFxuXFx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xcblxcdCAgICAgIHZhciBsaW5lID0gaHVuay5saW5lc1tqXSxcXG5cXHQgICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcXG5cXHQgICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZTtcXG5cXG5cXHQgICAgICBpZiAob3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnLScpIHtcXG5cXHQgICAgICAgIC8vIENvbnRleHQgc2FuaXR5IGNoZWNrXFxuXFx0ICAgICAgICBpZiAoIWNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XFxuXFx0ICAgICAgICAgIGVycm9yQ291bnQrKztcXG5cXG5cXHQgICAgICAgICAgaWYgKGVycm9yQ291bnQgPiBmdXp6RmFjdG9yKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0b1BvcysrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFNlYXJjaCBiZXN0IGZpdCBvZmZzZXRzIGZvciBlYWNoIGh1bmsgYmFzZWQgb24gdGhlIHByZXZpb3VzIG9uZXNcXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgaHVua3MubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgdmFyIGh1bmsgPSBodW5rc1tpXSxcXG5cXHQgICAgICAgIG1heExpbmUgPSBsaW5lcy5sZW5ndGggLSBodW5rLm9sZExpbmVzLFxcblxcdCAgICAgICAgbG9jYWxPZmZzZXQgPSAwLFxcblxcdCAgICAgICAgdG9Qb3MgPSBvZmZzZXQgKyBodW5rLm9sZFN0YXJ0IC0gMTtcXG5cXG5cXHQgICAgdmFyIGl0ZXJhdG9yID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfZGlzdGFuY2VJdGVyYXRvcjJbJ2RlZmF1bHQnXSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8odG9Qb3MsIG1pbkxpbmUsIG1heExpbmUpO1xcblxcblxcdCAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XFxuXFx0ICAgICAgaWYgKGh1bmtGaXRzKGh1bmssIHRvUG9zICsgbG9jYWxPZmZzZXQpKSB7XFxuXFx0ICAgICAgICBodW5rLm9mZnNldCA9IG9mZnNldCArPSBsb2NhbE9mZnNldDtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAobG9jYWxPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBTZXQgbG93ZXIgdGV4dCBsaW1pdCB0byBlbmQgb2YgdGhlIGN1cnJlbnQgaHVuaywgc28gbmV4dCBvbmVzIGRvbid0IHRyeVxcblxcdCAgICAvLyB0byBmaXQgb3ZlciBhbHJlYWR5IHBhdGNoZWQgdGV4dFxcblxcdCAgICBtaW5MaW5lID0gaHVuay5vZmZzZXQgKyBodW5rLm9sZFN0YXJ0ICsgaHVuay5vbGRMaW5lcztcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIEFwcGx5IHBhdGNoIGh1bmtzXFxuXFx0ICB2YXIgZGlmZk9mZnNldCA9IDA7XFxuXFx0ICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaHVua3MubGVuZ3RoOyBfaSsrKSB7XFxuXFx0ICAgIHZhciBfaHVuayA9IGh1bmtzW19pXSxcXG5cXHQgICAgICAgIF90b1BvcyA9IF9odW5rLm9sZFN0YXJ0ICsgX2h1bmsub2Zmc2V0ICsgZGlmZk9mZnNldCAtIDE7XFxuXFx0ICAgIGRpZmZPZmZzZXQgKz0gX2h1bmsubmV3TGluZXMgLSBfaHVuay5vbGRMaW5lcztcXG5cXG5cXHQgICAgaWYgKF90b1BvcyA8IDApIHtcXG5cXHQgICAgICAvLyBDcmVhdGluZyBhIG5ldyBmaWxlXFxuXFx0ICAgICAgX3RvUG9zID0gMDtcXG5cXHQgICAgfVxcblxcblxcdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9odW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XFxuXFx0ICAgICAgdmFyIGxpbmUgPSBfaHVuay5saW5lc1tqXSxcXG5cXHQgICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcXG5cXHQgICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZSxcXG5cXHQgICAgICAgICAgZGVsaW1pdGVyID0gX2h1bmsubGluZWRlbGltaXRlcnNbal07XFxuXFxuXFx0ICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XFxuXFx0ICAgICAgICBfdG9Qb3MrKztcXG5cXHQgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XFxuXFx0ICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAxKTtcXG5cXHQgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMSk7XFxuXFx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcblxcdCAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcXG5cXHQgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDAsIGNvbnRlbnQpO1xcblxcdCAgICAgICAgZGVsaW1pdGVycy5zcGxpY2UoX3RvUG9zLCAwLCBkZWxpbWl0ZXIpO1xcblxcdCAgICAgICAgX3RvUG9zKys7XFxuXFx0ICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcXFxcXCcpIHtcXG5cXHQgICAgICAgIHZhciBwcmV2aW91c09wZXJhdGlvbiA9IF9odW5rLmxpbmVzW2ogLSAxXSA/IF9odW5rLmxpbmVzW2ogLSAxXVswXSA6IG51bGw7XFxuXFx0ICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xcblxcdCAgICAgICAgICByZW1vdmVFT0ZOTCA9IHRydWU7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnLScpIHtcXG5cXHQgICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gSGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsXFxuXFx0ICBpZiAocmVtb3ZlRU9GTkwpIHtcXG5cXHQgICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xcblxcdCAgICAgIGxpbmVzLnBvcCgpO1xcblxcdCAgICAgIGRlbGltaXRlcnMucG9wKCk7XFxuXFx0ICAgIH1cXG5cXHQgIH0gZWxzZSBpZiAoYWRkRU9GTkwpIHtcXG5cXHQgICAgbGluZXMucHVzaCgnJyk7XFxuXFx0ICAgIGRlbGltaXRlcnMucHVzaCgnXFxcXG4nKTtcXG5cXHQgIH1cXG5cXHQgIGZvciAodmFyIF9rID0gMDsgX2sgPCBsaW5lcy5sZW5ndGggLSAxOyBfaysrKSB7XFxuXFx0ICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIGxpbmVzLmpvaW4oJycpO1xcblxcdH1cXG5cXG5cXHQvLyBXcmFwcGVyIHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZmlsZSBwYXRjaGVzIHZpYSBjYWxsYmFja3MuXFxuXFx0ZnVuY3Rpb24gYXBwbHlQYXRjaGVzKHVuaURpZmYsIG9wdGlvbnMpIHtcXG5cXHQgIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcXG5cXHQgICAgdW5pRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcnNlLnBhcnNlUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHVuaURpZmYpO1xcblxcdCAgfVxcblxcblxcdCAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XFxuXFx0ICBmdW5jdGlvbiBwcm9jZXNzSW5kZXgoKSB7XFxuXFx0ICAgIHZhciBpbmRleCA9IHVuaURpZmZbY3VycmVudEluZGV4KytdO1xcblxcdCAgICBpZiAoIWluZGV4KSB7XFxuXFx0ICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBvcHRpb25zLmxvYWRGaWxlKGluZGV4LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XFxuXFx0ICAgICAgaWYgKGVycikge1xcblxcdCAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgdmFyIHVwZGF0ZWRDb250ZW50ID0gYXBwbHlQYXRjaChkYXRhLCBpbmRleCwgb3B0aW9ucyk7XFxuXFx0ICAgICAgb3B0aW9ucy5wYXRjaGVkKGluZGV4LCB1cGRhdGVkQ29udGVudCwgZnVuY3Rpb24gKGVycikge1xcblxcdCAgICAgICAgaWYgKGVycikge1xcblxcdCAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jb21wbGV0ZShlcnIpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcHJvY2Vzc0luZGV4KCk7XFxuXFx0ICAgICAgfSk7XFxuXFx0ICAgIH0pO1xcblxcdCAgfVxcblxcdCAgcHJvY2Vzc0luZGV4KCk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDExICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3BhcnNlUGF0Y2ggPSBwYXJzZVBhdGNoO1xcblxcdGZ1bmN0aW9uIHBhcnNlUGF0Y2godW5pRGlmZikge1xcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xcblxcblxcdCAgdmFyIGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdLyksXFxuXFx0ICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vZykgfHwgW10sXFxuXFx0ICAgICAgbGlzdCA9IFtdLFxcblxcdCAgICAgIGkgPSAwO1xcblxcblxcdCAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcXG5cXHQgICAgdmFyIGluZGV4ID0ge307XFxuXFx0ICAgIGxpc3QucHVzaChpbmRleCk7XFxuXFxuXFx0ICAgIC8vIFBhcnNlIGRpZmYgbWV0YWRhdGFcXG5cXHQgICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xcblxcdCAgICAgIHZhciBsaW5lID0gZGlmZnN0cltpXTtcXG5cXG5cXHQgICAgICAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxcblxcdCAgICAgIGlmICgvXihcXFxcLVxcXFwtXFxcXC18XFxcXCtcXFxcK1xcXFwrfEBAKVxcXFxzLy50ZXN0KGxpbmUpKSB7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gRGlmZiBpbmRleFxcblxcdCAgICAgIHZhciBoZWFkZXIgPSAvXig/OkluZGV4OnxkaWZmKD86IC1yIFxcXFx3KykrKVxcXFxzKyguKz8pXFxcXHMqJC8uZXhlYyhsaW5lKTtcXG5cXHQgICAgICBpZiAoaGVhZGVyKSB7XFxuXFx0ICAgICAgICBpbmRleC5pbmRleCA9IGhlYWRlclsxXTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgaSsrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFBhcnNlIGZpbGUgaGVhZGVycyBpZiB0aGV5IGFyZSBkZWZpbmVkLiBVbmlmaWVkIGRpZmYgcmVxdWlyZXMgdGhlbSwgYnV0XFxuXFx0ICAgIC8vIHRoZXJlJ3Mgbm8gdGVjaG5pY2FsIGlzc3VlcyB0byBoYXZlIGFuIGlzb2xhdGVkIGh1bmsgd2l0aG91dCBmaWxlIGhlYWRlclxcblxcdCAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xcblxcdCAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xcblxcblxcdCAgICAvLyBQYXJzZSBodW5rc1xcblxcdCAgICBpbmRleC5odW5rcyA9IFtdO1xcblxcblxcdCAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XFxuXFx0ICAgICAgdmFyIF9saW5lID0gZGlmZnN0cltpXTtcXG5cXG5cXHQgICAgICBpZiAoL14oSW5kZXg6fGRpZmZ8XFxcXC1cXFxcLVxcXFwtfFxcXFwrXFxcXCtcXFxcKylcXFxccy8udGVzdChfbGluZSkpIHtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChfbGluZSkpIHtcXG5cXHQgICAgICAgIGluZGV4Lmh1bmtzLnB1c2gocGFyc2VIdW5rKCkpO1xcblxcdCAgICAgIH0gZWxzZSBpZiAoX2xpbmUgJiYgb3B0aW9ucy5zdHJpY3QpIHtcXG5cXHQgICAgICAgIC8vIElnbm9yZSB1bmV4cGVjdGVkIGNvbnRlbnQgdW5sZXNzIGluIHN0cmljdCBtb2RlXFxuXFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KF9saW5lKSk7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIGkrKztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFBhcnNlcyB0aGUgLS0tIGFuZCArKysgaGVhZGVycywgaWYgbm9uZSBhcmUgZm91bmQsIG5vIGxpbmVzXFxuXFx0ICAvLyBhcmUgY29uc3VtZWQuXFxuXFx0ICBmdW5jdGlvbiBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpIHtcXG5cXHQgICAgdmFyIGZpbGVIZWFkZXIgPSAvXigtLS18XFxcXCtcXFxcK1xcXFwrKVxcXFxzKyguKikkLy5leGVjKGRpZmZzdHJbaV0pO1xcblxcdCAgICBpZiAoZmlsZUhlYWRlcikge1xcblxcdCAgICAgIHZhciBrZXlQcmVmaXggPSBmaWxlSGVhZGVyWzFdID09PSAnLS0tJyA/ICdvbGQnIDogJ25ldyc7XFxuXFx0ICAgICAgdmFyIGRhdGEgPSBmaWxlSGVhZGVyWzJdLnNwbGl0KCdcXFxcdCcsIDIpO1xcblxcdCAgICAgIHZhciBmaWxlTmFtZSA9IGRhdGFbMF0ucmVwbGFjZSgvXFxcXFxcXFxcXFxcXFxcXC9nLCAnXFxcXFxcXFwnKTtcXG5cXHQgICAgICBpZiAoL15cXFwiLipcXFwiJC8udGVzdChmaWxlTmFtZSkpIHtcXG5cXHQgICAgICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyKDEsIGZpbGVOYW1lLmxlbmd0aCAtIDIpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBpbmRleFtrZXlQcmVmaXggKyAnRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xcblxcdCAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IChkYXRhWzFdIHx8ICcnKS50cmltKCk7XFxuXFxuXFx0ICAgICAgaSsrO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBQYXJzZXMgYSBodW5rXFxuXFx0ICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgaHVuay5cXG5cXHQgIGZ1bmN0aW9uIHBhcnNlSHVuaygpIHtcXG5cXHQgICAgdmFyIGNodW5rSGVhZGVySW5kZXggPSBpLFxcblxcdCAgICAgICAgY2h1bmtIZWFkZXJMaW5lID0gZGlmZnN0cltpKytdLFxcblxcdCAgICAgICAgY2h1bmtIZWFkZXIgPSBjaHVua0hlYWRlckxpbmUuc3BsaXQoL0BAIC0oXFxcXGQrKSg/OiwoXFxcXGQrKSk/IFxcXFwrKFxcXFxkKykoPzosKFxcXFxkKykpPyBAQC8pO1xcblxcblxcdCAgICB2YXIgaHVuayA9IHtcXG5cXHQgICAgICBvbGRTdGFydDogK2NodW5rSGVhZGVyWzFdLFxcblxcdCAgICAgIG9sZExpbmVzOiArY2h1bmtIZWFkZXJbMl0gfHwgMSxcXG5cXHQgICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxcblxcdCAgICAgIG5ld0xpbmVzOiArY2h1bmtIZWFkZXJbNF0gfHwgMSxcXG5cXHQgICAgICBsaW5lczogW10sXFxuXFx0ICAgICAgbGluZWRlbGltaXRlcnM6IFtdXFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHZhciBhZGRDb3VudCA9IDAsXFxuXFx0ICAgICAgICByZW1vdmVDb3VudCA9IDA7XFxuXFx0ICAgIGZvciAoOyBpIDwgZGlmZnN0ci5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcXFwicmVtb3ZlIGxpbmVcXFwiIG9wZXJhdGlvblxcblxcdCAgICAgIC8vIEJ1dCB0aGV5IGNvdWxkIGJlIHRoZSBoZWFkZXIgZm9yIHRoZSBuZXh0IGZpbGUuIFRoZXJlZm9yZSBwcnVuZSBzdWNoIGNhc2VzIG91dC5cXG5cXHQgICAgICBpZiAoZGlmZnN0cltpXS5pbmRleE9mKCctLS0gJykgPT09IDAgJiYgaSArIDIgPCBkaWZmc3RyLmxlbmd0aCAmJiBkaWZmc3RyW2kgKyAxXS5pbmRleE9mKCcrKysgJykgPT09IDAgJiYgZGlmZnN0cltpICsgMl0uaW5kZXhPZignQEAnKSA9PT0gMCkge1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIHZhciBvcGVyYXRpb24gPSBkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gZGlmZnN0ci5sZW5ndGggLSAxID8gJyAnIDogZGlmZnN0cltpXVswXTtcXG5cXG5cXHQgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXFxcXFwnKSB7XFxuXFx0ICAgICAgICBodW5rLmxpbmVzLnB1c2goZGlmZnN0cltpXSk7XFxuXFx0ICAgICAgICBodW5rLmxpbmVkZWxpbWl0ZXJzLnB1c2goZGVsaW1pdGVyc1tpXSB8fCAnXFxcXG4nKTtcXG5cXG5cXHQgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xcblxcdCAgICAgICAgICBhZGRDb3VudCsrO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xcblxcdCAgICAgICAgICByZW1vdmVDb3VudCsrO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xcblxcdCAgICAgICAgICBhZGRDb3VudCsrO1xcblxcdCAgICAgICAgICByZW1vdmVDb3VudCsrO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXFxuXFx0ICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xcblxcdCAgICAgIGh1bmsubmV3TGluZXMgPSAwO1xcblxcdCAgICB9XFxuXFx0ICAgIGlmICghcmVtb3ZlQ291bnQgJiYgaHVuay5vbGRMaW5lcyA9PT0gMSkge1xcblxcdCAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXFxuXFx0ICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xcblxcdCAgICAgIGlmIChhZGRDb3VudCAhPT0gaHVuay5uZXdMaW5lcykge1xcblxcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xcblxcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgcmV0dXJuIGh1bms7XFxuXFx0ICB9XFxuXFxuXFx0ICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XFxuXFx0ICAgIHBhcnNlSW5kZXgoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBsaXN0O1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxMiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFxuXFx0ZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiAoc3RhcnQsIG1pbkxpbmUsIG1heExpbmUpIHtcXG5cXHQgIHZhciB3YW50Rm9yd2FyZCA9IHRydWUsXFxuXFx0ICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcXG5cXHQgICAgICBmb3J3YXJkRXhoYXVzdGVkID0gZmFsc2UsXFxuXFx0ICAgICAgbG9jYWxPZmZzZXQgPSAxO1xcblxcblxcdCAgcmV0dXJuIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xcblxcdCAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICBpZiAoYmFja3dhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICAgIGxvY2FsT2Zmc2V0Kys7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHdhbnRGb3J3YXJkID0gZmFsc2U7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmV5b25kIHRleHQgbGVuZ3RoLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXFxuXFx0ICAgICAgLy8gYWZ0ZXIgb2Zmc2V0IGxvY2F0aW9uIChvciBkZXNpcmVkIGxvY2F0aW9uIG9uIGZpcnN0IGl0ZXJhdGlvbilcXG5cXHQgICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XFxuXFx0ICAgICAgICByZXR1cm4gbG9jYWxPZmZzZXQ7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmICghYmFja3dhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICBpZiAoIWZvcndhcmRFeGhhdXN0ZWQpIHtcXG5cXHQgICAgICAgIHdhbnRGb3J3YXJkID0gdHJ1ZTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcXG5cXHQgICAgICAvLyBiZWZvcmUgb2Zmc2V0IGxvY2F0aW9uXFxuXFx0ICAgICAgaWYgKG1pbkxpbmUgPD0gc3RhcnQgLSBsb2NhbE9mZnNldCkge1xcblxcdCAgICAgICAgcmV0dXJuIC1sb2NhbE9mZnNldCsrO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XFxuXFx0ICAgICAgcmV0dXJuIGl0ZXJhdG9yKCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gV2UgdHJpZWQgdG8gZml0IGh1bmsgYmVmb3JlIHRleHQgYmVnaW5uaW5nIGFuZCBiZXlvbmQgdGV4dCBsZW5ndGgsIHRoZW5cXG5cXHQgICAgLy8gaHVuayBjYW4ndCBmaXQgb24gdGhlIHRleHQuIFJldHVybiB1bmRlZmluZWRcXG5cXHQgIH07XFxuXFx0fTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxMyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYWxjTGluZUNvdW50ID0gY2FsY0xpbmVDb3VudDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9tZXJnZSA9IG1lcmdlO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiBjYWxjTGluZUNvdW50KGh1bmspIHtcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2NhbGNPbGROZXdMaW5lQ291bnQgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NhbGNPbGROZXdMaW5lQ291bnQoaHVuay5saW5lcyksXFxuXFx0ICAgICAgb2xkTGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5vbGRMaW5lcyxcXG5cXHQgICAgICBuZXdMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm5ld0xpbmVzO1xcblxcblxcdCAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgaHVuay5vbGRMaW5lcyA9IG9sZExpbmVzO1xcblxcdCAgfSBlbHNlIHtcXG5cXHQgICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xcblxcdCAgICBodW5rLm5ld0xpbmVzID0gbmV3TGluZXM7XFxuXFx0ICB9IGVsc2Uge1xcblxcdCAgICBkZWxldGUgaHVuay5uZXdMaW5lcztcXG5cXHQgIH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gbWVyZ2UobWluZSwgdGhlaXJzLCBiYXNlKSB7XFxuXFx0ICBtaW5lID0gbG9hZFBhdGNoKG1pbmUsIGJhc2UpO1xcblxcdCAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XFxuXFxuXFx0ICB2YXIgcmV0ID0ge307XFxuXFxuXFx0ICAvLyBGb3IgaW5kZXggd2UganVzdCBsZXQgaXQgcGFzcyB0aHJvdWdoIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgbmVjZXNzYXJ5IG1lYW5pbmcuXFxuXFx0ICAvLyBMZWF2aW5nIHNhbml0eSBjaGVja3Mgb24gdGhpcyB0byB0aGUgQVBJIGNvbnN1bWVyIHRoYXQgbWF5IGtub3cgbW9yZSBhYm91dCB0aGVcXG5cXHQgIC8vIG1lYW5pbmcgaW4gdGhlaXIgb3duIGNvbnRleHQuXFxuXFx0ICBpZiAobWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXgpIHtcXG5cXHQgICAgcmV0LmluZGV4ID0gbWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXg7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAobWluZS5uZXdGaWxlTmFtZSB8fCB0aGVpcnMubmV3RmlsZU5hbWUpIHtcXG5cXHQgICAgaWYgKCFmaWxlTmFtZUNoYW5nZWQobWluZSkpIHtcXG5cXHQgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcXG5cXHQgICAgICByZXQub2xkRmlsZU5hbWUgPSB0aGVpcnMub2xkRmlsZU5hbWUgfHwgbWluZS5vbGRGaWxlTmFtZTtcXG5cXHQgICAgICByZXQubmV3RmlsZU5hbWUgPSB0aGVpcnMubmV3RmlsZU5hbWUgfHwgbWluZS5uZXdGaWxlTmFtZTtcXG5cXHQgICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcXG5cXHQgICAgICByZXQubmV3SGVhZGVyID0gdGhlaXJzLm5ld0hlYWRlciB8fCBtaW5lLm5ld0hlYWRlcjtcXG5cXHQgICAgfSBlbHNlIGlmICghZmlsZU5hbWVDaGFuZ2VkKHRoZWlycykpIHtcXG5cXHQgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcXG5cXHQgICAgICByZXQub2xkRmlsZU5hbWUgPSBtaW5lLm9sZEZpbGVOYW1lO1xcblxcdCAgICAgIHJldC5uZXdGaWxlTmFtZSA9IG1pbmUubmV3RmlsZU5hbWU7XFxuXFx0ICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xcblxcdCAgICAgIHJldC5uZXdIZWFkZXIgPSBtaW5lLm5ld0hlYWRlcjtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxcblxcdCAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRGaWxlTmFtZSwgdGhlaXJzLm9sZEZpbGVOYW1lKTtcXG5cXHQgICAgICByZXQubmV3RmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3RmlsZU5hbWUsIHRoZWlycy5uZXdGaWxlTmFtZSk7XFxuXFx0ICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xcblxcdCAgICAgIHJldC5uZXdIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3SGVhZGVyLCB0aGVpcnMubmV3SGVhZGVyKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0Lmh1bmtzID0gW107XFxuXFxuXFx0ICB2YXIgbWluZUluZGV4ID0gMCxcXG5cXHQgICAgICB0aGVpcnNJbmRleCA9IDAsXFxuXFx0ICAgICAgbWluZU9mZnNldCA9IDAsXFxuXFx0ICAgICAgdGhlaXJzT2Zmc2V0ID0gMDtcXG5cXG5cXHQgIHdoaWxlIChtaW5lSW5kZXggPCBtaW5lLmh1bmtzLmxlbmd0aCB8fCB0aGVpcnNJbmRleCA8IHRoZWlycy5odW5rcy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5odW5rc1ttaW5lSW5kZXhdIHx8IHsgb2xkU3RhcnQ6IEluZmluaXR5IH0sXFxuXFx0ICAgICAgICB0aGVpcnNDdXJyZW50ID0gdGhlaXJzLmh1bmtzW3RoZWlyc0luZGV4XSB8fCB7IG9sZFN0YXJ0OiBJbmZpbml0eSB9O1xcblxcblxcdCAgICBpZiAoaHVua0JlZm9yZShtaW5lQ3VycmVudCwgdGhlaXJzQ3VycmVudCkpIHtcXG5cXHQgICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxcblxcdCAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayhtaW5lQ3VycmVudCwgbWluZU9mZnNldCkpO1xcblxcdCAgICAgIG1pbmVJbmRleCsrO1xcblxcdCAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xcblxcdCAgICB9IGVsc2UgaWYgKGh1bmtCZWZvcmUodGhlaXJzQ3VycmVudCwgbWluZUN1cnJlbnQpKSB7XFxuXFx0ICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cXG5cXHQgICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XFxuXFx0ICAgICAgdGhlaXJzSW5kZXgrKztcXG5cXHQgICAgICBtaW5lT2Zmc2V0ICs9IHRoZWlyc0N1cnJlbnQubmV3TGluZXMgLSB0aGVpcnNDdXJyZW50Lm9sZExpbmVzO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIC8vIE92ZXJsYXAsIG1lcmdlIGFzIGJlc3Qgd2UgY2FuXFxuXFx0ICAgICAgdmFyIG1lcmdlZEh1bmsgPSB7XFxuXFx0ICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxcblxcdCAgICAgICAgb2xkTGluZXM6IDAsXFxuXFx0ICAgICAgICBuZXdTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQubmV3U3RhcnQgKyBtaW5lT2Zmc2V0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0ICsgdGhlaXJzT2Zmc2V0KSxcXG5cXHQgICAgICAgIG5ld0xpbmVzOiAwLFxcblxcdCAgICAgICAgbGluZXM6IFtdXFxuXFx0ICAgICAgfTtcXG5cXHQgICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XFxuXFx0ICAgICAgdGhlaXJzSW5kZXgrKztcXG5cXHQgICAgICBtaW5lSW5kZXgrKztcXG5cXG5cXHQgICAgICByZXQuaHVua3MucHVzaChtZXJnZWRIdW5rKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHJldDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gbG9hZFBhdGNoKHBhcmFtLCBiYXNlKSB7XFxuXFx0ICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xcblxcdCAgICBpZiAoL15AQC9tLnRlc3QocGFyYW0pIHx8IC9eSW5kZXg6L20udGVzdChwYXJhbSkpIHtcXG5cXHQgICAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcnNlLnBhcnNlUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHBhcmFtKVswXVxcblxcdCAgICAgICk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKCFiYXNlKSB7XFxuXFx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBiYXNlIHJlZmVyZW5jZSBvciBwYXNzIGluIGEgcGF0Y2gnKTtcXG5cXHQgICAgfVxcblxcdCAgICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2NyZWF0ZS5zdHJ1Y3R1cmVkUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlLCBwYXJhbSlcXG5cXHQgICAgKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBwYXJhbTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZmlsZU5hbWVDaGFuZ2VkKHBhdGNoKSB7XFxuXFx0ICByZXR1cm4gcGF0Y2gubmV3RmlsZU5hbWUgJiYgcGF0Y2gubmV3RmlsZU5hbWUgIT09IHBhdGNoLm9sZEZpbGVOYW1lO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZWxlY3RGaWVsZChpbmRleCwgbWluZSwgdGhlaXJzKSB7XFxuXFx0ICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XFxuXFx0ICAgIHJldHVybiBtaW5lO1xcblxcdCAgfSBlbHNlIHtcXG5cXHQgICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xcblxcdCAgICByZXR1cm4geyBtaW5lOiBtaW5lLCB0aGVpcnM6IHRoZWlycyB9O1xcblxcdCAgfVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBodW5rQmVmb3JlKHRlc3QsIGNoZWNrKSB7XFxuXFx0ICByZXR1cm4gdGVzdC5vbGRTdGFydCA8IGNoZWNrLm9sZFN0YXJ0ICYmIHRlc3Qub2xkU3RhcnQgKyB0ZXN0Lm9sZExpbmVzIDwgY2hlY2sub2xkU3RhcnQ7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcXG5cXHQgIHJldHVybiB7XFxuXFx0ICAgIG9sZFN0YXJ0OiBodW5rLm9sZFN0YXJ0LCBvbGRMaW5lczogaHVuay5vbGRMaW5lcyxcXG5cXHQgICAgbmV3U3RhcnQ6IGh1bmsubmV3U3RhcnQgKyBvZmZzZXQsIG5ld0xpbmVzOiBodW5rLm5ld0xpbmVzLFxcblxcdCAgICBsaW5lczogaHVuay5saW5lc1xcblxcdCAgfTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gbWVyZ2VMaW5lcyhodW5rLCBtaW5lT2Zmc2V0LCBtaW5lTGluZXMsIHRoZWlyT2Zmc2V0LCB0aGVpckxpbmVzKSB7XFxuXFx0ICAvLyBUaGlzIHdpbGwgZ2VuZXJhbGx5IHJlc3VsdCBpbiBhIGNvbmZsaWN0ZWQgaHVuaywgYnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgY29udGV4dFxcblxcdCAgLy8gaXMgdGhlIG9ubHkgb3ZlcmxhcCB3aGVyZSB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG1lcmdlIHRoZSBjb250ZW50IGhlcmUuXFxuXFx0ICB2YXIgbWluZSA9IHsgb2Zmc2V0OiBtaW5lT2Zmc2V0LCBsaW5lczogbWluZUxpbmVzLCBpbmRleDogMCB9LFxcblxcdCAgICAgIHRoZWlyID0geyBvZmZzZXQ6IHRoZWlyT2Zmc2V0LCBsaW5lczogdGhlaXJMaW5lcywgaW5kZXg6IDAgfTtcXG5cXG5cXHQgIC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XFxuXFx0ICBpbnNlcnRMZWFkaW5nKGh1bmssIG1pbmUsIHRoZWlyKTtcXG5cXHQgIGluc2VydExlYWRpbmcoaHVuaywgdGhlaXIsIG1pbmUpO1xcblxcblxcdCAgLy8gTm93IGluIHRoZSBvdmVybGFwIGNvbnRlbnQuIFNjYW4gdGhyb3VnaCBhbmQgc2VsZWN0IHRoZSBiZXN0IGNoYW5nZXMgZnJvbSBlYWNoLlxcblxcdCAgd2hpbGUgKG1pbmUuaW5kZXggPCBtaW5lLmxpbmVzLmxlbmd0aCAmJiB0aGVpci5pbmRleCA8IHRoZWlyLmxpbmVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmxpbmVzW21pbmUuaW5kZXhdLFxcblxcdCAgICAgICAgdGhlaXJDdXJyZW50ID0gdGhlaXIubGluZXNbdGhlaXIuaW5kZXhdO1xcblxcblxcdCAgICBpZiAoKG1pbmVDdXJyZW50WzBdID09PSAnLScgfHwgbWluZUN1cnJlbnRbMF0gPT09ICcrJykgJiYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nIHx8IHRoZWlyQ3VycmVudFswXSA9PT0gJysnKSkge1xcblxcdCAgICAgIC8vIEJvdGggbW9kaWZpZWQgLi4uXFxuXFx0ICAgICAgbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKTtcXG5cXHQgICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJysnICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lcztcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBNaW5lIGluc2VydGVkXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lcyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXMgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29sbGVjdENoYW5nZShtaW5lKSkpO1xcblxcdCAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJysnICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzMjtcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBUaGVpcnMgaW5zZXJ0ZWRcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzMiA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXMyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbGxlY3RDaGFuZ2UodGhlaXIpKSk7XFxuXFx0ICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICctJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xcblxcdCAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcXG5cXHQgICAgICByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyKTtcXG5cXHQgICAgfSBlbHNlIGlmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyAmJiBtaW5lQ3VycmVudFswXSA9PT0gJyAnKSB7XFxuXFx0ICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcXG5cXHQgICAgICByZW1vdmFsKGh1bmssIHRoZWlyLCBtaW5lLCB0cnVlKTtcXG5cXHQgICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudCA9PT0gdGhlaXJDdXJyZW50KSB7XFxuXFx0ICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxcblxcdCAgICAgIGh1bmsubGluZXMucHVzaChtaW5lQ3VycmVudCk7XFxuXFx0ICAgICAgbWluZS5pbmRleCsrO1xcblxcdCAgICAgIHRoZWlyLmluZGV4Kys7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgLy8gQ29udGV4dCBtaXNtYXRjaFxcblxcdCAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gTm93IHB1c2ggYW55dGhpbmcgdGhhdCBtYXkgYmUgcmVtYWluaW5nXFxuXFx0ICBpbnNlcnRUcmFpbGluZyhodW5rLCBtaW5lKTtcXG5cXHQgIGluc2VydFRyYWlsaW5nKGh1bmssIHRoZWlyKTtcXG5cXG5cXHQgIGNhbGNMaW5lQ291bnQoaHVuayk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcikge1xcblxcdCAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXFxuXFx0ICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENoYW5nZSh0aGVpcik7XFxuXFxuXFx0ICBpZiAoYWxsUmVtb3ZlcyhteUNoYW5nZXMpICYmIGFsbFJlbW92ZXModGhlaXJDaGFuZ2VzKSkge1xcblxcdCAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJlbW92ZSBjaGFuZ2VzIHRoYXQgYXJlIHN1cGVyc2V0cyBvZiBvbmUgYW5vdGhlclxcblxcdCAgICBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2FycmF5LmFycmF5U3RhcnRzV2l0aCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8obXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpICYmIHNraXBSZW1vdmVTdXBlcnNldCh0aGVpciwgbXlDaGFuZ2VzLCBteUNoYW5nZXMubGVuZ3RoIC0gdGhlaXJDaGFuZ2VzLmxlbmd0aCkpIHtcXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzMztcXG5cXG5cXHQgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzMyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXMzIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL215Q2hhbmdlcykpO1xcblxcdCAgICAgIHJldHVybjtcXG5cXHQgICAgfSBlbHNlIGlmICggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfYXJyYXkuYXJyYXlTdGFydHNXaXRoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh0aGVpckNoYW5nZXMsIG15Q2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KG1pbmUsIHRoZWlyQ2hhbmdlcywgdGhlaXJDaGFuZ2VzLmxlbmd0aCAtIG15Q2hhbmdlcy5sZW5ndGgpKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lczQ7XFxuXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lczQgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzNCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi90aGVpckNoYW5nZXMpKTtcXG5cXHQgICAgICByZXR1cm47XFxuXFx0ICAgIH1cXG5cXHQgIH0gZWxzZSBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2FycmF5LmFycmF5RXF1YWwpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzNTtcXG5cXG5cXHQgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lczUgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzNSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9teUNoYW5nZXMpKTtcXG5cXHQgICAgcmV0dXJuO1xcblxcdCAgfVxcblxcblxcdCAgY29uZmxpY3QoaHVuaywgbXlDaGFuZ2VzLCB0aGVpckNoYW5nZXMpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XFxuXFx0ICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcXG5cXHQgICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q29udGV4dCh0aGVpciwgbXlDaGFuZ2VzKTtcXG5cXHQgIGlmICh0aGVpckNoYW5nZXMubWVyZ2VkKSB7XFxuXFx0ICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2h1bmskbGluZXM2O1xcblxcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9odW5rJGxpbmVzNiA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovaHVuay5saW5lcykucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2h1bmskbGluZXM2IC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3RoZWlyQ2hhbmdlcy5tZXJnZWQpKTtcXG5cXHQgIH0gZWxzZSB7XFxuXFx0ICAgIGNvbmZsaWN0KGh1bmssIHN3YXAgPyB0aGVpckNoYW5nZXMgOiBteUNoYW5nZXMsIHN3YXAgPyBteUNoYW5nZXMgOiB0aGVpckNoYW5nZXMpO1xcblxcdCAgfVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjb25mbGljdChodW5rLCBtaW5lLCB0aGVpcikge1xcblxcdCAgaHVuay5jb25mbGljdCA9IHRydWU7XFxuXFx0ICBodW5rLmxpbmVzLnB1c2goe1xcblxcdCAgICBjb25mbGljdDogdHJ1ZSxcXG5cXHQgICAgbWluZTogbWluZSxcXG5cXHQgICAgdGhlaXJzOiB0aGVpclxcblxcdCAgfSk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xcblxcdCAgd2hpbGUgKGluc2VydC5vZmZzZXQgPCB0aGVpci5vZmZzZXQgJiYgaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XFxuXFx0ICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcXG5cXHQgICAgaW5zZXJ0Lm9mZnNldCsrO1xcblxcdCAgfVxcblxcdH1cXG5cXHRmdW5jdGlvbiBpbnNlcnRUcmFpbGluZyhodW5rLCBpbnNlcnQpIHtcXG5cXHQgIHdoaWxlIChpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcXG5cXHQgICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xcblxcdCAgfVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjb2xsZWN0Q2hhbmdlKHN0YXRlKSB7XFxuXFx0ICB2YXIgcmV0ID0gW10sXFxuXFx0ICAgICAgb3BlcmF0aW9uID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdWzBdO1xcblxcdCAgd2hpbGUgKHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBsaW5lID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdO1xcblxcblxcdCAgICAvLyBHcm91cCBhZGRpdGlvbnMgdGhhdCBhcmUgaW1tZWRpYXRlbHkgYWZ0ZXIgc3VidHJhY3Rpb25zIGFuZCB0cmVhdCB0aGVtIGFzIG9uZSBcXFwiYXRvbWljXFxcIiBtb2RpZnkgY2hhbmdlLlxcblxcdCAgICBpZiAob3BlcmF0aW9uID09PSAnLScgJiYgbGluZVswXSA9PT0gJysnKSB7XFxuXFx0ICAgICAgb3BlcmF0aW9uID0gJysnO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChvcGVyYXRpb24gPT09IGxpbmVbMF0pIHtcXG5cXHQgICAgICByZXQucHVzaChsaW5lKTtcXG5cXHQgICAgICBzdGF0ZS5pbmRleCsrO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGJyZWFrO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gcmV0O1xcblxcdH1cXG5cXHRmdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XFxuXFx0ICB2YXIgY2hhbmdlcyA9IFtdLFxcblxcdCAgICAgIG1lcmdlZCA9IFtdLFxcblxcdCAgICAgIG1hdGNoSW5kZXggPSAwLFxcblxcdCAgICAgIGNvbnRleHRDaGFuZ2VzID0gZmFsc2UsXFxuXFx0ICAgICAgY29uZmxpY3RlZCA9IGZhbHNlO1xcblxcdCAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBjaGFuZ2UgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF0sXFxuXFx0ICAgICAgICBtYXRjaCA9IG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4XTtcXG5cXG5cXHQgICAgLy8gT25jZSB3ZSd2ZSBoaXQgb3VyIGFkZCwgdGhlbiB3ZSBhcmUgZG9uZVxcblxcdCAgICBpZiAobWF0Y2hbMF0gPT09ICcrJykge1xcblxcdCAgICAgIGJyZWFrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XFxuXFxuXFx0ICAgIG1lcmdlZC5wdXNoKG1hdGNoKTtcXG5cXHQgICAgbWF0Y2hJbmRleCsrO1xcblxcblxcdCAgICAvLyBDb25zdW1lIGFueSBhZGRpdGlvbnMgaW4gdGhlIG90aGVyIGJsb2NrIGFzIGEgY29uZmxpY3QgdG8gYXR0ZW1wdFxcblxcdCAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXFxuXFx0ICAgIGlmIChjaGFuZ2VbMF0gPT09ICcrJykge1xcblxcdCAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xcblxcblxcdCAgICAgIHdoaWxlIChjaGFuZ2VbMF0gPT09ICcrJykge1xcblxcdCAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XFxuXFx0ICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKG1hdGNoLnN1YnN0cigxKSA9PT0gY2hhbmdlLnN1YnN0cigxKSkge1xcblxcdCAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xcblxcdCAgICAgIHN0YXRlLmluZGV4Kys7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgY29uZmxpY3RlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnICYmIGNvbnRleHRDaGFuZ2VzKSB7XFxuXFx0ICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKGNvbmZsaWN0ZWQpIHtcXG5cXHQgICAgcmV0dXJuIGNoYW5nZXM7XFxuXFx0ICB9XFxuXFxuXFx0ICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcXG5cXHQgICAgbWVyZ2VkLnB1c2gobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXgrK10pO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHtcXG5cXHQgICAgbWVyZ2VkOiBtZXJnZWQsXFxuXFx0ICAgIGNoYW5nZXM6IGNoYW5nZXNcXG5cXHQgIH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xcblxcdCAgcmV0dXJuIGNoYW5nZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjaGFuZ2UpIHtcXG5cXHQgICAgcmV0dXJuIHByZXYgJiYgY2hhbmdlWzBdID09PSAnLSc7XFxuXFx0ICB9LCB0cnVlKTtcXG5cXHR9XFxuXFx0ZnVuY3Rpb24gc2tpcFJlbW92ZVN1cGVyc2V0KHN0YXRlLCByZW1vdmVDaGFuZ2VzLCBkZWx0YSkge1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YTsgaSsrKSB7XFxuXFx0ICAgIHZhciBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xcblxcdCAgICBpZiAoc3RhdGUubGluZXNbc3RhdGUuaW5kZXggKyBpXSAhPT0gJyAnICsgY2hhbmdlQ29udGVudCkge1xcblxcdCAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XFxuXFx0ICByZXR1cm4gdHJ1ZTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lcykge1xcblxcdCAgdmFyIG9sZExpbmVzID0gMDtcXG5cXHQgIHZhciBuZXdMaW5lcyA9IDA7XFxuXFxuXFx0ICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XFxuXFx0ICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcXG5cXHQgICAgICB2YXIgbXlDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS5taW5lKTtcXG5cXHQgICAgICB2YXIgdGhlaXJDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS50aGVpcnMpO1xcblxcblxcdCAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICBpZiAobXlDb3VudC5vbGRMaW5lcyA9PT0gdGhlaXJDb3VudC5vbGRMaW5lcykge1xcblxcdCAgICAgICAgICBvbGRMaW5lcyArPSBteUNvdW50Lm9sZExpbmVzO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgb2xkTGluZXMgPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICBpZiAobXlDb3VudC5uZXdMaW5lcyA9PT0gdGhlaXJDb3VudC5uZXdMaW5lcykge1xcblxcdCAgICAgICAgICBuZXdMaW5lcyArPSBteUNvdW50Lm5ld0xpbmVzO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgbmV3TGluZXMgPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnKycgfHwgbGluZVswXSA9PT0gJyAnKSkge1xcblxcdCAgICAgICAgbmV3TGluZXMrKztcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XFxuXFx0ICAgICAgICBvbGRMaW5lcysrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfSk7XFxuXFxuXFx0ICByZXR1cm4geyBvbGRMaW5lczogb2xkTGluZXMsIG5ld0xpbmVzOiBuZXdMaW5lcyB9O1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxNCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9zdHJ1Y3R1cmVkUGF0Y2ggPSBzdHJ1Y3R1cmVkUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlVHdvRmlsZXNQYXRjaCA9IGNyZWF0ZVR3b0ZpbGVzUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlUGF0Y2ggPSBjcmVhdGVQYXRjaDtcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcXG5cXHQgIGlmICghb3B0aW9ucykge1xcblxcdCAgICBvcHRpb25zID0ge307XFxuXFx0ICB9XFxuXFx0ICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG5cXHQgICAgb3B0aW9ucy5jb250ZXh0ID0gNDtcXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBkaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfbGluZS5kaWZmTGluZXMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG5cXHQgIGRpZmYucHVzaCh7IHZhbHVlOiAnJywgbGluZXM6IFtdIH0pOyAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxcblxcblxcdCAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XFxuXFx0ICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XFxuXFx0ICAgICAgcmV0dXJuICcgJyArIGVudHJ5O1xcblxcdCAgICB9KTtcXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBodW5rcyA9IFtdO1xcblxcdCAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLFxcblxcdCAgICAgIG5ld1JhbmdlU3RhcnQgPSAwLFxcblxcdCAgICAgIGN1clJhbmdlID0gW10sXFxuXFx0ICAgICAgb2xkTGluZSA9IDEsXFxuXFx0ICAgICAgbmV3TGluZSA9IDE7XFxuXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovaSkge1xcblxcdCAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXFxuXFx0ICAgICAgICBsaW5lcyA9IGN1cnJlbnQubGluZXMgfHwgY3VycmVudC52YWx1ZS5yZXBsYWNlKC9cXFxcbiQvLCAnJykuc3BsaXQoJ1xcXFxuJyk7XFxuXFx0ICAgIGN1cnJlbnQubGluZXMgPSBsaW5lcztcXG5cXG5cXHQgICAgaWYgKGN1cnJlbnQuYWRkZWQgfHwgY3VycmVudC5yZW1vdmVkKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfY3VyUmFuZ2U7XFxuXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcXG5cXHQgICAgICBpZiAoIW9sZFJhbmdlU3RhcnQpIHtcXG5cXHQgICAgICAgIHZhciBwcmV2ID0gZGlmZltpIC0gMV07XFxuXFx0ICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcXG5cXHQgICAgICAgIG5ld1JhbmdlU3RhcnQgPSBuZXdMaW5lO1xcblxcblxcdCAgICAgICAgaWYgKHByZXYpIHtcXG5cXHQgICAgICAgICAgY3VyUmFuZ2UgPSBvcHRpb25zLmNvbnRleHQgPiAwID8gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLW9wdGlvbnMuY29udGV4dCkpIDogW107XFxuXFx0ICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xcblxcdCAgICAgICAgICBuZXdSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gT3V0cHV0IG91ciBjaGFuZ2VzXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfY3VyUmFuZ2UgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2N1clJhbmdlKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3VyUmFuZ2UgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xcblxcdCAgICAgICAgcmV0dXJuIChjdXJyZW50LmFkZGVkID8gJysnIDogJy0nKSArIGVudHJ5O1xcblxcdCAgICAgIH0pKSk7XFxuXFxuXFx0ICAgICAgLy8gVHJhY2sgdGhlIHVwZGF0ZWQgZmlsZSBwb3NpdGlvblxcblxcdCAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XFxuXFx0ICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcXG5cXHQgICAgICBpZiAob2xkUmFuZ2VTdGFydCkge1xcblxcdCAgICAgICAgLy8gQ2xvc2Ugb3V0IGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBiZWVuIG91dHB1dCAob3Igam9pbiBvdmVybGFwcGluZylcXG5cXHQgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2N1clJhbmdlMjtcXG5cXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gT3ZlcmxhcHBpbmdcXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfY3VyUmFuZ2UyID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jdXJSYW5nZSkucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2N1clJhbmdlMiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb250ZXh0TGluZXMobGluZXMpKSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9jdXJSYW5nZTM7XFxuXFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxcblxcdCAgICAgICAgICB2YXIgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2N1clJhbmdlMyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3VyUmFuZ2UpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jdXJSYW5nZTMgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpKTtcXG5cXG5cXHQgICAgICAgICAgdmFyIGh1bmsgPSB7XFxuXFx0ICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXFxuXFx0ICAgICAgICAgICAgb2xkTGluZXM6IG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXFxuXFx0ICAgICAgICAgICAgbmV3U3RhcnQ6IG5ld1JhbmdlU3RhcnQsXFxuXFx0ICAgICAgICAgICAgbmV3TGluZXM6IG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXFxuXFx0ICAgICAgICAgICAgbGluZXM6IGN1clJhbmdlXFxuXFx0ICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgIGlmIChpID49IGRpZmYubGVuZ3RoIC0gMiAmJiBsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0KSB7XFxuXFx0ICAgICAgICAgICAgLy8gRU9GIGlzIGluc2lkZSB0aGlzIGh1bmtcXG5cXHQgICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXFxcbiQvLnRlc3Qob2xkU3RyKTtcXG5cXHQgICAgICAgICAgICB2YXIgbmV3RU9GTmV3bGluZSA9IC9cXFxcbiQvLnRlc3QobmV3U3RyKTtcXG5cXHQgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IDAgJiYgIW9sZEVPRk5ld2xpbmUpIHtcXG5cXHQgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogb2xkIGhhcyBubyBlb2wgYW5kIG5vIHRyYWlsaW5nIGNvbnRleHQ7IG5vLW5sIGNhbiBlbmQgdXAgYmVmb3JlIGFkZHNcXG5cXHQgICAgICAgICAgICAgIGN1clJhbmdlLnNwbGljZShodW5rLm9sZExpbmVzLCAwLCAnXFxcXFxcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9sZEVPRk5ld2xpbmUgfHwgIW5ld0VPRk5ld2xpbmUpIHtcXG5cXHQgICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFxcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgaHVua3MucHVzaChodW5rKTtcXG5cXG5cXHQgICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XFxuXFx0ICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xcblxcdCAgICAgICAgICBjdXJSYW5nZSA9IFtdO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG5cXHQgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xvb3AoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovaSk7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4ge1xcblxcdCAgICBvbGRGaWxlTmFtZTogb2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lOiBuZXdGaWxlTmFtZSxcXG5cXHQgICAgb2xkSGVhZGVyOiBvbGRIZWFkZXIsIG5ld0hlYWRlcjogbmV3SGVhZGVyLFxcblxcdCAgICBodW5rczogaHVua3NcXG5cXHQgIH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcXG5cXHQgIHZhciBkaWZmID0gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcXG5cXG5cXHQgIHZhciByZXQgPSBbXTtcXG5cXHQgIGlmIChvbGRGaWxlTmFtZSA9PSBuZXdGaWxlTmFtZSkge1xcblxcdCAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBvbGRGaWxlTmFtZSk7XFxuXFx0ICB9XFxuXFx0ICByZXQucHVzaCgnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xcblxcdCAgcmV0LnB1c2goJy0tLSAnICsgZGlmZi5vbGRGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5vbGRIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFxcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcXG5cXHQgIHJldC5wdXNoKCcrKysgJyArIGRpZmYubmV3RmlsZU5hbWUgKyAodHlwZW9mIGRpZmYubmV3SGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XFxuXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYuaHVua3MubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgdmFyIGh1bmsgPSBkaWZmLmh1bmtzW2ldO1xcblxcdCAgICByZXQucHVzaCgnQEAgLScgKyBodW5rLm9sZFN0YXJ0ICsgJywnICsgaHVuay5vbGRMaW5lcyArICcgKycgKyBodW5rLm5ld1N0YXJ0ICsgJywnICsgaHVuay5uZXdMaW5lcyArICcgQEAnKTtcXG5cXHQgICAgcmV0LnB1c2guYXBwbHkocmV0LCBodW5rLmxpbmVzKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiByZXQuam9pbignXFxcXG4nKSArICdcXFxcbic7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcXG5cXHQgIHJldHVybiBjcmVhdGVUd29GaWxlc1BhdGNoKGZpbGVOYW1lLCBmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTUgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXJyYXlFcXVhbCA9IGFycmF5RXF1YWw7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXJyYXlTdGFydHNXaXRoID0gYXJyYXlTdGFydHNXaXRoO1xcblxcdGZ1bmN0aW9uIGFycmF5RXF1YWwoYSwgYikge1xcblxcdCAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xcblxcdCAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gYXJyYXlTdGFydHNXaXRoKGEsIGIpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBhcnJheVN0YXJ0c1dpdGgoYXJyYXksIHN0YXJ0KSB7XFxuXFx0ICBpZiAoc3RhcnQubGVuZ3RoID4gYXJyYXkubGVuZ3RoKSB7XFxuXFx0ICAgIHJldHVybiBmYWxzZTtcXG5cXHQgIH1cXG5cXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgaWYgKHN0YXJ0W2ldICE9PSBhcnJheVtpXSkge1xcblxcdCAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHRydWU7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE2ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9ETVAgPSBjb252ZXJ0Q2hhbmdlc1RvRE1QO1xcblxcdC8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXFxuXFx0ZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XFxuXFx0ICB2YXIgcmV0ID0gW10sXFxuXFx0ICAgICAgY2hhbmdlID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyxcXG5cXHQgICAgICBvcGVyYXRpb24gPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIGNoYW5nZSA9IGNoYW5nZXNbaV07XFxuXFx0ICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcXG5cXHQgICAgICBvcGVyYXRpb24gPSAxO1xcblxcdCAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuXFx0ICAgICAgb3BlcmF0aW9uID0gLTE7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgb3BlcmF0aW9uID0gMDtcXG5cXHQgICAgfVxcblxcblxcdCAgICByZXQucHVzaChbb3BlcmF0aW9uLCBjaGFuZ2UudmFsdWVdKTtcXG5cXHQgIH1cXG5cXHQgIHJldHVybiByZXQ7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE3ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9YTUwgPSBjb252ZXJ0Q2hhbmdlc1RvWE1MO1xcblxcdGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xcblxcdCAgdmFyIHJldCA9IFtdO1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xcblxcdCAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuXFx0ICAgICAgcmV0LnB1c2goJzxpbnM+Jyk7XFxuXFx0ICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG5cXHQgICAgICByZXQucHVzaCgnPGRlbD4nKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xcblxcblxcdCAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuXFx0ICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xcblxcdCAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuXFx0ICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gcmV0LmpvaW4oJycpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcXG5cXHQgIHZhciBuID0gcztcXG5cXHQgIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XFxuXFx0ICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XFxuXFx0ICBuID0gbi5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XFxuXFx0ICBuID0gbi5yZXBsYWNlKC9cXFwiL2csICcmcXVvdDsnKTtcXG5cXG5cXHQgIHJldHVybiBuO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KVxcbi8qKioqKiovIF0pXFxufSk7XFxuO1xcbn0se31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxcXFxcXHt9KClbXFxcXF1eJCsqPy5dL2c7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XFxuXFx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICdcXFxcXFxcXCQmJyk7XFxufTtcXG5cXG59LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcXG59XFxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XFxuXFxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xcblxcbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXFxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcXG5cXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcXG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XFxuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMpXFxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcblxcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxcbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcXG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcXG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XFxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFxcXCJlcnJvclxcXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcXG4gICAgICAgIHRocm93IGVycjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXFxuICAgIHJldHVybiBmYWxzZTtcXG5cXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XFxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICAgIC8vIGZhc3QgY2FzZXNcXG4gICAgICBjYXNlIDE6XFxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDI6XFxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMzpcXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICAvLyBzbG93ZXJcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XFxuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XFxuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xcbiAgdmFyIG07XFxuXFxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMpXFxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcblxcbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXFxcIm5ld0xpc3RlbmVyXFxcIiEgQmVmb3JlXFxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcXFwibmV3TGlzdGVuZXJcXFwiLlxcbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XFxuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XFxuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcXG4gIGVsc2VcXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcXG5cXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXFxuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcXG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcXG4gICAgfVxcblxcbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXFxuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xcblxcbiAgZnVuY3Rpb24gZygpIHtcXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcXG5cXG4gICAgaWYgKCFmaXJlZCkge1xcbiAgICAgIGZpcmVkID0gdHJ1ZTtcXG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9XFxuICB9XFxuXFxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XFxuICB0aGlzLm9uKHR5cGUsIGcpO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XFxuXFxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcblxcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XFxuICBwb3NpdGlvbiA9IC0xO1xcblxcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XFxuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXFxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcXG5cXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcXG4gICAgICAgIHBvc2l0aW9uID0gaTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocG9zaXRpb24gPCAwKVxcbiAgICAgIHJldHVybiB0aGlzO1xcblxcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcXG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XFxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcXG4gIHZhciBrZXksIGxpc3RlbmVycztcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzKVxcbiAgICByZXR1cm4gdGhpcztcXG5cXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcXG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XFxuICAgIH1cXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XFxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcXG4gICAgLy8gTElGTyBvcmRlclxcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xcbiAgfVxcbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XFxuICB2YXIgcmV0O1xcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgcmV0ID0gW107XFxuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXFxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xcbiAgZWxzZVxcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XFxuICBpZiAodGhpcy5fZXZlbnRzKSB7XFxuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcXG4gICAgICByZXR1cm4gMTtcXG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XFxuICB9XFxuICByZXR1cm4gMDtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcXG59O1xcblxcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcXG59XFxuXFxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XFxufVxcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XFxufVxcblxcbn0se31dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuLyohIGh0dHBzOi8vbXRocy5iZS9oZSB2MS4xLjEgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xcbjsoZnVuY3Rpb24ocm9vdCkge1xcblxcblxcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2AuXFxuXFx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcXG5cXG5cXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC5cXG5cXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xcblxcblxcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXFxuXFx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGAuXFxuXFx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcXG5cXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcXG5cXHRcXHRyb290ID0gZnJlZUdsb2JhbDtcXG5cXHR9XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0Ly8gQWxsIGFzdHJhbCBzeW1ib2xzLlxcblxcdHZhciByZWdleEFzdHJhbFN5bWJvbHMgPSAvW1xcXFx1RDgwMC1cXFxcdURCRkZdW1xcXFx1REMwMC1cXFxcdURGRkZdL2c7XFxuXFx0Ly8gQWxsIEFTQ0lJIHN5bWJvbHMgKG5vdCBqdXN0IHByaW50YWJsZSBBU0NJSSkgZXhjZXB0IHRob3NlIGxpc3RlZCBpbiB0aGVcXG5cXHQvLyBmaXJzdCBjb2x1bW4gb2YgdGhlIG92ZXJyaWRlcyB0YWJsZS5cXG5cXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCN0YWJsZS1jaGFycmVmLW92ZXJyaWRlc1xcblxcdHZhciByZWdleEFzY2lpV2hpdGVsaXN0ID0gL1tcXFxceDAxLVxcXFx4N0ZdL2c7XFxuXFx0Ly8gQWxsIEJNUCBzeW1ib2xzIHRoYXQgYXJlIG5vdCBBU0NJSSBuZXdsaW5lcywgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHMsIG9yXFxuXFx0Ly8gY29kZSBwb2ludHMgbGlzdGVkIGluIHRoZSBmaXJzdCBjb2x1bW4gb2YgdGhlIG92ZXJyaWRlcyB0YWJsZSBvblxcblxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3RhYmxlLWNoYXJyZWYtb3ZlcnJpZGVzLlxcblxcdHZhciByZWdleEJtcFdoaXRlbGlzdCA9IC9bXFxcXHgwMS1cXFxcdFxcXFx4MEJcXFxcZlxcXFx4MEUtXFxcXHgxRlxcXFx4N0ZcXFxceDgxXFxcXHg4RFxcXFx4OEZcXFxceDkwXFxcXHg5RFxcXFx4QTAtXFxcXHVGRkZGXS9nO1xcblxcblxcdHZhciByZWdleEVuY29kZU5vbkFzY2lpID0gLzxcXFxcdTIwRDJ8PVxcXFx1MjBFNXw+XFxcXHUyMEQyfFxcXFx1MjA1RlxcXFx1MjAwQXxcXFxcdTIxOURcXFxcdTAzMzh8XFxcXHUyMjAyXFxcXHUwMzM4fFxcXFx1MjIyMFxcXFx1MjBEMnxcXFxcdTIyMjlcXFxcdUZFMDB8XFxcXHUyMjJBXFxcXHVGRTAwfFxcXFx1MjIzQ1xcXFx1MjBEMnxcXFxcdTIyM0RcXFxcdTAzMzF8XFxcXHUyMjNFXFxcXHUwMzMzfFxcXFx1MjI0MlxcXFx1MDMzOHxcXFxcdTIyNEJcXFxcdTAzMzh8XFxcXHUyMjREXFxcXHUyMEQyfFxcXFx1MjI0RVxcXFx1MDMzOHxcXFxcdTIyNEZcXFxcdTAzMzh8XFxcXHUyMjUwXFxcXHUwMzM4fFxcXFx1MjI2MVxcXFx1MjBFNXxcXFxcdTIyNjRcXFxcdTIwRDJ8XFxcXHUyMjY1XFxcXHUyMEQyfFxcXFx1MjI2NlxcXFx1MDMzOHxcXFxcdTIyNjdcXFxcdTAzMzh8XFxcXHUyMjY4XFxcXHVGRTAwfFxcXFx1MjI2OVxcXFx1RkUwMHxcXFxcdTIyNkFcXFxcdTAzMzh8XFxcXHUyMjZBXFxcXHUyMEQyfFxcXFx1MjI2QlxcXFx1MDMzOHxcXFxcdTIyNkJcXFxcdTIwRDJ8XFxcXHUyMjdGXFxcXHUwMzM4fFxcXFx1MjI4MlxcXFx1MjBEMnxcXFxcdTIyODNcXFxcdTIwRDJ8XFxcXHUyMjhBXFxcXHVGRTAwfFxcXFx1MjI4QlxcXFx1RkUwMHxcXFxcdTIyOEZcXFxcdTAzMzh8XFxcXHUyMjkwXFxcXHUwMzM4fFxcXFx1MjI5M1xcXFx1RkUwMHxcXFxcdTIyOTRcXFxcdUZFMDB8XFxcXHUyMkI0XFxcXHUyMEQyfFxcXFx1MjJCNVxcXFx1MjBEMnxcXFxcdTIyRDhcXFxcdTAzMzh8XFxcXHUyMkQ5XFxcXHUwMzM4fFxcXFx1MjJEQVxcXFx1RkUwMHxcXFxcdTIyREJcXFxcdUZFMDB8XFxcXHUyMkY1XFxcXHUwMzM4fFxcXFx1MjJGOVxcXFx1MDMzOHxcXFxcdTI5MzNcXFxcdTAzMzh8XFxcXHUyOUNGXFxcXHUwMzM4fFxcXFx1MjlEMFxcXFx1MDMzOHxcXFxcdTJBNkRcXFxcdTAzMzh8XFxcXHUyQTcwXFxcXHUwMzM4fFxcXFx1MkE3RFxcXFx1MDMzOHxcXFxcdTJBN0VcXFxcdTAzMzh8XFxcXHUyQUExXFxcXHUwMzM4fFxcXFx1MkFBMlxcXFx1MDMzOHxcXFxcdTJBQUNcXFxcdUZFMDB8XFxcXHUyQUFEXFxcXHVGRTAwfFxcXFx1MkFBRlxcXFx1MDMzOHxcXFxcdTJBQjBcXFxcdTAzMzh8XFxcXHUyQUM1XFxcXHUwMzM4fFxcXFx1MkFDNlxcXFx1MDMzOHxcXFxcdTJBQ0JcXFxcdUZFMDB8XFxcXHUyQUNDXFxcXHVGRTAwfFxcXFx1MkFGRFxcXFx1MjBFNXxbXFxcXHhBMC1cXFxcdTAxMTNcXFxcdTAxMTYtXFxcXHUwMTIyXFxcXHUwMTI0LVxcXFx1MDEyQlxcXFx1MDEyRS1cXFxcdTAxNERcXFxcdTAxNTAtXFxcXHUwMTdFXFxcXHUwMTkyXFxcXHUwMUI1XFxcXHUwMUY1XFxcXHUwMjM3XFxcXHUwMkM2XFxcXHUwMkM3XFxcXHUwMkQ4LVxcXFx1MDJERFxcXFx1MDMxMVxcXFx1MDM5MS1cXFxcdTAzQTFcXFxcdTAzQTMtXFxcXHUwM0E5XFxcXHUwM0IxLVxcXFx1MDNDOVxcXFx1MDNEMVxcXFx1MDNEMlxcXFx1MDNENVxcXFx1MDNENlxcXFx1MDNEQ1xcXFx1MDNERFxcXFx1MDNGMFxcXFx1MDNGMVxcXFx1MDNGNVxcXFx1MDNGNlxcXFx1MDQwMS1cXFxcdTA0MENcXFxcdTA0MEUtXFxcXHUwNDRGXFxcXHUwNDUxLVxcXFx1MDQ1Q1xcXFx1MDQ1RVxcXFx1MDQ1RlxcXFx1MjAwMi1cXFxcdTIwMDVcXFxcdTIwMDctXFxcXHUyMDEwXFxcXHUyMDEzLVxcXFx1MjAxNlxcXFx1MjAxOC1cXFxcdTIwMUFcXFxcdTIwMUMtXFxcXHUyMDFFXFxcXHUyMDIwLVxcXFx1MjAyMlxcXFx1MjAyNVxcXFx1MjAyNlxcXFx1MjAzMC1cXFxcdTIwMzVcXFxcdTIwMzlcXFxcdTIwM0FcXFxcdTIwM0VcXFxcdTIwNDFcXFxcdTIwNDNcXFxcdTIwNDRcXFxcdTIwNEZcXFxcdTIwNTdcXFxcdTIwNUYtXFxcXHUyMDYzXFxcXHUyMEFDXFxcXHUyMERCXFxcXHUyMERDXFxcXHUyMTAyXFxcXHUyMTA1XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNS1cXFxcdTIxMUVcXFxcdTIxMjJcXFxcdTIxMjRcXFxcdTIxMjctXFxcXHUyMTI5XFxcXHUyMTJDXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzMVxcXFx1MjEzMy1cXFxcdTIxMzhcXFxcdTIxNDUtXFxcXHUyMTQ4XFxcXHUyMTUzLVxcXFx1MjE1RVxcXFx1MjE5MC1cXFxcdTIxOUJcXFxcdTIxOUQtXFxcXHUyMUE3XFxcXHUyMUE5LVxcXFx1MjFBRVxcXFx1MjFCMC1cXFxcdTIxQjNcXFxcdTIxQjUtXFxcXHUyMUI3XFxcXHUyMUJBLVxcXFx1MjFEQlxcXFx1MjFERFxcXFx1MjFFNFxcXFx1MjFFNVxcXFx1MjFGNVxcXFx1MjFGRC1cXFxcdTIyMDVcXFxcdTIyMDctXFxcXHUyMjA5XFxcXHUyMjBCXFxcXHUyMjBDXFxcXHUyMjBGLVxcXFx1MjIxNFxcXFx1MjIxNi1cXFxcdTIyMThcXFxcdTIyMUFcXFxcdTIyMUQtXFxcXHUyMjM4XFxcXHUyMjNBLVxcXFx1MjI1N1xcXFx1MjI1OVxcXFx1MjI1QVxcXFx1MjI1Q1xcXFx1MjI1Ri1cXFxcdTIyNjJcXFxcdTIyNjQtXFxcXHUyMjhCXFxcXHUyMjhELVxcXFx1MjI5QlxcXFx1MjI5RC1cXFxcdTIyQTVcXFxcdTIyQTctXFxcXHUyMkIwXFxcXHUyMkIyLVxcXFx1MjJCQlxcXFx1MjJCRC1cXFxcdTIyREJcXFxcdTIyREUtXFxcXHUyMkUzXFxcXHUyMkU2LVxcXFx1MjJGN1xcXFx1MjJGOS1cXFxcdTIyRkVcXFxcdTIzMDVcXFxcdTIzMDZcXFxcdTIzMDgtXFxcXHUyMzEwXFxcXHUyMzEyXFxcXHUyMzEzXFxcXHUyMzE1XFxcXHUyMzE2XFxcXHUyMzFDLVxcXFx1MjMxRlxcXFx1MjMyMlxcXFx1MjMyM1xcXFx1MjMyRFxcXFx1MjMyRVxcXFx1MjMzNlxcXFx1MjMzRFxcXFx1MjMzRlxcXFx1MjM3Q1xcXFx1MjNCMFxcXFx1MjNCMVxcXFx1MjNCNC1cXFxcdTIzQjZcXFxcdTIzREMtXFxcXHUyM0RGXFxcXHUyM0UyXFxcXHUyM0U3XFxcXHUyNDIzXFxcXHUyNEM4XFxcXHUyNTAwXFxcXHUyNTAyXFxcXHUyNTBDXFxcXHUyNTEwXFxcXHUyNTE0XFxcXHUyNTE4XFxcXHUyNTFDXFxcXHUyNTI0XFxcXHUyNTJDXFxcXHUyNTM0XFxcXHUyNTNDXFxcXHUyNTUwLVxcXFx1MjU2Q1xcXFx1MjU4MFxcXFx1MjU4NFxcXFx1MjU4OFxcXFx1MjU5MS1cXFxcdTI1OTNcXFxcdTI1QTFcXFxcdTI1QUFcXFxcdTI1QUJcXFxcdTI1QURcXFxcdTI1QUVcXFxcdTI1QjFcXFxcdTI1QjMtXFxcXHUyNUI1XFxcXHUyNUI4XFxcXHUyNUI5XFxcXHUyNUJELVxcXFx1MjVCRlxcXFx1MjVDMlxcXFx1MjVDM1xcXFx1MjVDQVxcXFx1MjVDQlxcXFx1MjVFQ1xcXFx1MjVFRlxcXFx1MjVGOC1cXFxcdTI1RkNcXFxcdTI2MDVcXFxcdTI2MDZcXFxcdTI2MEVcXFxcdTI2NDBcXFxcdTI2NDJcXFxcdTI2NjBcXFxcdTI2NjNcXFxcdTI2NjVcXFxcdTI2NjZcXFxcdTI2NkFcXFxcdTI2NkQtXFxcXHUyNjZGXFxcXHUyNzEzXFxcXHUyNzE3XFxcXHUyNzIwXFxcXHUyNzM2XFxcXHUyNzU4XFxcXHUyNzcyXFxcXHUyNzczXFxcXHUyN0M4XFxcXHUyN0M5XFxcXHUyN0U2LVxcXFx1MjdFRFxcXFx1MjdGNS1cXFxcdTI3RkFcXFxcdTI3RkNcXFxcdTI3RkZcXFxcdTI5MDItXFxcXHUyOTA1XFxcXHUyOTBDLVxcXFx1MjkxM1xcXFx1MjkxNlxcXFx1MjkxOS1cXFxcdTI5MjBcXFxcdTI5MjMtXFxcXHUyOTJBXFxcXHUyOTMzXFxcXHUyOTM1LVxcXFx1MjkzOVxcXFx1MjkzQ1xcXFx1MjkzRFxcXFx1Mjk0NVxcXFx1Mjk0OC1cXFxcdTI5NEJcXFxcdTI5NEUtXFxcXHUyOTc2XFxcXHUyOTc4XFxcXHUyOTc5XFxcXHUyOTdCLVxcXFx1Mjk3RlxcXFx1Mjk4NVxcXFx1Mjk4NlxcXFx1Mjk4Qi1cXFxcdTI5OTZcXFxcdTI5OUFcXFxcdTI5OUNcXFxcdTI5OURcXFxcdTI5QTQtXFxcXHUyOUI3XFxcXHUyOUI5XFxcXHUyOUJCXFxcXHUyOUJDXFxcXHUyOUJFLVxcXFx1MjlDNVxcXFx1MjlDOVxcXFx1MjlDRC1cXFxcdTI5RDBcXFxcdTI5REMtXFxcXHUyOURFXFxcXHUyOUUzLVxcXFx1MjlFNVxcXFx1MjlFQlxcXFx1MjlGNFxcXFx1MjlGNlxcXFx1MkEwMC1cXFxcdTJBMDJcXFxcdTJBMDRcXFxcdTJBMDZcXFxcdTJBMENcXFxcdTJBMERcXFxcdTJBMTAtXFxcXHUyQTE3XFxcXHUyQTIyLVxcXFx1MkEyN1xcXFx1MkEyOVxcXFx1MkEyQVxcXFx1MkEyRC1cXFxcdTJBMzFcXFxcdTJBMzMtXFxcXHUyQTNDXFxcXHUyQTNGXFxcXHUyQTQwXFxcXHUyQTQyLVxcXFx1MkE0RFxcXFx1MkE1MFxcXFx1MkE1My1cXFxcdTJBNThcXFxcdTJBNUEtXFxcXHUyQTVEXFxcXHUyQTVGXFxcXHUyQTY2XFxcXHUyQTZBXFxcXHUyQTZELVxcXFx1MkE3NVxcXFx1MkE3Ny1cXFxcdTJBOUFcXFxcdTJBOUQtXFxcXHUyQUEyXFxcXHUyQUE0LVxcXFx1MkFCMFxcXFx1MkFCMy1cXFxcdTJBQzhcXFxcdTJBQ0JcXFxcdTJBQ0NcXFxcdTJBQ0YtXFxcXHUyQURCXFxcXHUyQUU0XFxcXHUyQUU2LVxcXFx1MkFFOVxcXFx1MkFFQi1cXFxcdTJBRjNcXFxcdTJBRkRcXFxcdUZCMDAtXFxcXHVGQjA0XXxcXFxcdUQ4MzVbXFxcXHVEQzlDXFxcXHVEQzlFXFxcXHVEQzlGXFxcXHVEQ0EyXFxcXHVEQ0E1XFxcXHVEQ0E2XFxcXHVEQ0E5LVxcXFx1RENBQ1xcXFx1RENBRS1cXFxcdURDQjlcXFxcdURDQkJcXFxcdURDQkQtXFxcXHVEQ0MzXFxcXHVEQ0M1LVxcXFx1RENDRlxcXFx1REQwNFxcXFx1REQwNVxcXFx1REQwNy1cXFxcdUREMEFcXFxcdUREMEQtXFxcXHVERDE0XFxcXHVERDE2LVxcXFx1REQxQ1xcXFx1REQxRS1cXFxcdUREMzlcXFxcdUREM0ItXFxcXHVERDNFXFxcXHVERDQwLVxcXFx1REQ0NFxcXFx1REQ0NlxcXFx1REQ0QS1cXFxcdURENTBcXFxcdURENTItXFxcXHVERDZCXS9nO1xcblxcdHZhciBlbmNvZGVNYXAgPSB7J1xcXFx4QUQnOidzaHknLCdcXFxcdTIwMEMnOid6d25qJywnXFxcXHUyMDBEJzonendqJywnXFxcXHUyMDBFJzonbHJtJywnXFxcXHUyMDYzJzonaWMnLCdcXFxcdTIwNjInOidpdCcsJ1xcXFx1MjA2MSc6J2FmJywnXFxcXHUyMDBGJzoncmxtJywnXFxcXHUyMDBCJzonWmVyb1dpZHRoU3BhY2UnLCdcXFxcdTIwNjAnOidOb0JyZWFrJywnXFxcXHUwMzExJzonRG93bkJyZXZlJywnXFxcXHUyMERCJzondGRvdCcsJ1xcXFx1MjBEQyc6J0RvdERvdCcsJ1xcXFx0JzonVGFiJywnXFxcXG4nOidOZXdMaW5lJywnXFxcXHUyMDA4JzoncHVuY3NwJywnXFxcXHUyMDVGJzonTWVkaXVtU3BhY2UnLCdcXFxcdTIwMDknOid0aGluc3AnLCdcXFxcdTIwMEEnOidoYWlyc3AnLCdcXFxcdTIwMDQnOidlbXNwMTMnLCdcXFxcdTIwMDInOidlbnNwJywnXFxcXHUyMDA1JzonZW1zcDE0JywnXFxcXHUyMDAzJzonZW1zcCcsJ1xcXFx1MjAwNyc6J251bXNwJywnXFxcXHhBMCc6J25ic3AnLCdcXFxcdTIwNUZcXFxcdTIwMEEnOidUaGlja1NwYWNlJywnXFxcXHUyMDNFJzonb2xpbmUnLCdfJzonbG93YmFyJywnXFxcXHUyMDEwJzonZGFzaCcsJ1xcXFx1MjAxMyc6J25kYXNoJywnXFxcXHUyMDE0JzonbWRhc2gnLCdcXFxcdTIwMTUnOidob3JiYXInLCcsJzonY29tbWEnLCc7Jzonc2VtaScsJ1xcXFx1MjA0Ric6J2JzZW1pJywnOic6J2NvbG9uJywnXFxcXHUyQTc0JzonQ29sb25lJywnISc6J2V4Y2wnLCdcXFxceEExJzonaWV4Y2wnLCc/JzoncXVlc3QnLCdcXFxceEJGJzonaXF1ZXN0JywnLic6J3BlcmlvZCcsJ1xcXFx1MjAyNSc6J25sZHInLCdcXFxcdTIwMjYnOidtbGRyJywnXFxcXHhCNyc6J21pZGRvdCcsJ1xcXFwnJzonYXBvcycsJ1xcXFx1MjAxOCc6J2xzcXVvJywnXFxcXHUyMDE5JzoncnNxdW8nLCdcXFxcdTIwMUEnOidzYnF1bycsJ1xcXFx1MjAzOSc6J2xzYXF1bycsJ1xcXFx1MjAzQSc6J3JzYXF1bycsJ1xcXCInOidxdW90JywnXFxcXHUyMDFDJzonbGRxdW8nLCdcXFxcdTIwMUQnOidyZHF1bycsJ1xcXFx1MjAxRSc6J2JkcXVvJywnXFxcXHhBQic6J2xhcXVvJywnXFxcXHhCQic6J3JhcXVvJywnKCc6J2xwYXInLCcpJzoncnBhcicsJ1snOidsc3FiJywnXSc6J3JzcWInLCd7JzonbGN1YicsJ30nOidyY3ViJywnXFxcXHUyMzA4JzonbGNlaWwnLCdcXFxcdTIzMDknOidyY2VpbCcsJ1xcXFx1MjMwQSc6J2xmbG9vcicsJ1xcXFx1MjMwQic6J3JmbG9vcicsJ1xcXFx1Mjk4NSc6J2xvcGFyJywnXFxcXHUyOTg2Jzoncm9wYXInLCdcXFxcdTI5OEInOidsYnJrZScsJ1xcXFx1Mjk4Qyc6J3JicmtlJywnXFxcXHUyOThEJzonbGJya3NsdScsJ1xcXFx1Mjk4RSc6J3JicmtzbGQnLCdcXFxcdTI5OEYnOidsYnJrc2xkJywnXFxcXHUyOTkwJzoncmJya3NsdScsJ1xcXFx1Mjk5MSc6J2xhbmdkJywnXFxcXHUyOTkyJzoncmFuZ2QnLCdcXFxcdTI5OTMnOidscGFybHQnLCdcXFxcdTI5OTQnOidycGFyZ3QnLCdcXFxcdTI5OTUnOidndGxQYXInLCdcXFxcdTI5OTYnOidsdHJQYXInLCdcXFxcdTI3RTYnOidsb2JyaycsJ1xcXFx1MjdFNyc6J3JvYnJrJywnXFxcXHUyN0U4JzonbGFuZycsJ1xcXFx1MjdFOSc6J3JhbmcnLCdcXFxcdTI3RUEnOidMYW5nJywnXFxcXHUyN0VCJzonUmFuZycsJ1xcXFx1MjdFQyc6J2xvYW5nJywnXFxcXHUyN0VEJzoncm9hbmcnLCdcXFxcdTI3NzInOidsYmJyaycsJ1xcXFx1Mjc3Myc6J3JiYnJrJywnXFxcXHUyMDE2JzonVmVydCcsJ1xcXFx4QTcnOidzZWN0JywnXFxcXHhCNic6J3BhcmEnLCdAJzonY29tbWF0JywnKic6J2FzdCcsJy8nOidzb2wnLCd1bmRlZmluZWQnOm51bGwsJyYnOidhbXAnLCcjJzonbnVtJywnJSc6J3BlcmNudCcsJ1xcXFx1MjAzMCc6J3Blcm1pbCcsJ1xcXFx1MjAzMSc6J3BlcnRlbmsnLCdcXFxcdTIwMjAnOidkYWdnZXInLCdcXFxcdTIwMjEnOidEYWdnZXInLCdcXFxcdTIwMjInOididWxsJywnXFxcXHUyMDQzJzonaHlidWxsJywnXFxcXHUyMDMyJzoncHJpbWUnLCdcXFxcdTIwMzMnOidQcmltZScsJ1xcXFx1MjAzNCc6J3RwcmltZScsJ1xcXFx1MjA1Nyc6J3FwcmltZScsJ1xcXFx1MjAzNSc6J2JwcmltZScsJ1xcXFx1MjA0MSc6J2NhcmV0JywnYCc6J2dyYXZlJywnXFxcXHhCNCc6J2FjdXRlJywnXFxcXHUwMkRDJzondGlsZGUnLCdeJzonSGF0JywnXFxcXHhBRic6J21hY3InLCdcXFxcdTAyRDgnOidicmV2ZScsJ1xcXFx1MDJEOSc6J2RvdCcsJ1xcXFx4QTgnOidkaWUnLCdcXFxcdTAyREEnOidyaW5nJywnXFxcXHUwMkREJzonZGJsYWMnLCdcXFxceEI4JzonY2VkaWwnLCdcXFxcdTAyREInOidvZ29uJywnXFxcXHUwMkM2JzonY2lyYycsJ1xcXFx1MDJDNyc6J2Nhcm9uJywnXFxcXHhCMCc6J2RlZycsJ1xcXFx4QTknOidjb3B5JywnXFxcXHhBRSc6J3JlZycsJ1xcXFx1MjExNyc6J2NvcHlzcicsJ1xcXFx1MjExOCc6J3dwJywnXFxcXHUyMTFFJzoncngnLCdcXFxcdTIxMjcnOidtaG8nLCdcXFxcdTIxMjknOidpaW90YScsJ1xcXFx1MjE5MCc6J2xhcnInLCdcXFxcdTIxOUEnOidubGFycicsJ1xcXFx1MjE5Mic6J3JhcnInLCdcXFxcdTIxOUInOiducmFycicsJ1xcXFx1MjE5MSc6J3VhcnInLCdcXFxcdTIxOTMnOidkYXJyJywnXFxcXHUyMTk0JzonaGFycicsJ1xcXFx1MjFBRSc6J25oYXJyJywnXFxcXHUyMTk1JzondmFycicsJ1xcXFx1MjE5Nic6J253YXJyJywnXFxcXHUyMTk3JzonbmVhcnInLCdcXFxcdTIxOTgnOidzZWFycicsJ1xcXFx1MjE5OSc6J3N3YXJyJywnXFxcXHUyMTlEJzoncmFycncnLCdcXFxcdTIxOURcXFxcdTAzMzgnOiducmFycncnLCdcXFxcdTIxOUUnOidMYXJyJywnXFxcXHUyMTlGJzonVWFycicsJ1xcXFx1MjFBMCc6J1JhcnInLCdcXFxcdTIxQTEnOidEYXJyJywnXFxcXHUyMUEyJzonbGFycnRsJywnXFxcXHUyMUEzJzoncmFycnRsJywnXFxcXHUyMUE0JzonbWFwc3RvbGVmdCcsJ1xcXFx1MjFBNSc6J21hcHN0b3VwJywnXFxcXHUyMUE2JzonbWFwJywnXFxcXHUyMUE3JzonbWFwc3RvZG93bicsJ1xcXFx1MjFBOSc6J2xhcnJoaycsJ1xcXFx1MjFBQSc6J3JhcnJoaycsJ1xcXFx1MjFBQic6J2xhcnJscCcsJ1xcXFx1MjFBQyc6J3JhcnJscCcsJ1xcXFx1MjFBRCc6J2hhcnJ3JywnXFxcXHUyMUIwJzonbHNoJywnXFxcXHUyMUIxJzoncnNoJywnXFxcXHUyMUIyJzonbGRzaCcsJ1xcXFx1MjFCMyc6J3Jkc2gnLCdcXFxcdTIxQjUnOidjcmFycicsJ1xcXFx1MjFCNic6J2N1bGFycicsJ1xcXFx1MjFCNyc6J2N1cmFycicsJ1xcXFx1MjFCQSc6J29sYXJyJywnXFxcXHUyMUJCJzonb3JhcnInLCdcXFxcdTIxQkMnOidsaGFydScsJ1xcXFx1MjFCRCc6J2xoYXJkJywnXFxcXHUyMUJFJzondWhhcnInLCdcXFxcdTIxQkYnOid1aGFybCcsJ1xcXFx1MjFDMCc6J3JoYXJ1JywnXFxcXHUyMUMxJzoncmhhcmQnLCdcXFxcdTIxQzInOidkaGFycicsJ1xcXFx1MjFDMyc6J2RoYXJsJywnXFxcXHUyMUM0JzoncmxhcnInLCdcXFxcdTIxQzUnOid1ZGFycicsJ1xcXFx1MjFDNic6J2xyYXJyJywnXFxcXHUyMUM3JzonbGxhcnInLCdcXFxcdTIxQzgnOid1dWFycicsJ1xcXFx1MjFDOSc6J3JyYXJyJywnXFxcXHUyMUNBJzonZGRhcnInLCdcXFxcdTIxQ0InOidscmhhcicsJ1xcXFx1MjFDQyc6J3JsaGFyJywnXFxcXHUyMUQwJzonbEFycicsJ1xcXFx1MjFDRCc6J25sQXJyJywnXFxcXHUyMUQxJzondUFycicsJ1xcXFx1MjFEMic6J3JBcnInLCdcXFxcdTIxQ0YnOiduckFycicsJ1xcXFx1MjFEMyc6J2RBcnInLCdcXFxcdTIxRDQnOidpZmYnLCdcXFxcdTIxQ0UnOiduaEFycicsJ1xcXFx1MjFENSc6J3ZBcnInLCdcXFxcdTIxRDYnOidud0FycicsJ1xcXFx1MjFENyc6J25lQXJyJywnXFxcXHUyMUQ4Jzonc2VBcnInLCdcXFxcdTIxRDknOidzd0FycicsJ1xcXFx1MjFEQSc6J2xBYXJyJywnXFxcXHUyMURCJzonckFhcnInLCdcXFxcdTIxREQnOid6aWdyYXJyJywnXFxcXHUyMUU0JzonbGFycmInLCdcXFxcdTIxRTUnOidyYXJyYicsJ1xcXFx1MjFGNSc6J2R1YXJyJywnXFxcXHUyMUZEJzonbG9hcnInLCdcXFxcdTIxRkUnOidyb2FycicsJ1xcXFx1MjFGRic6J2hvYXJyJywnXFxcXHUyMjAwJzonZm9yYWxsJywnXFxcXHUyMjAxJzonY29tcCcsJ1xcXFx1MjIwMic6J3BhcnQnLCdcXFxcdTIyMDJcXFxcdTAzMzgnOiducGFydCcsJ1xcXFx1MjIwMyc6J2V4aXN0JywnXFxcXHUyMjA0JzonbmV4aXN0JywnXFxcXHUyMjA1JzonZW1wdHknLCdcXFxcdTIyMDcnOidEZWwnLCdcXFxcdTIyMDgnOidpbicsJ1xcXFx1MjIwOSc6J25vdGluJywnXFxcXHUyMjBCJzonbmknLCdcXFxcdTIyMEMnOidub3RuaScsJ1xcXFx1MDNGNic6J2JlcHNpJywnXFxcXHUyMjBGJzoncHJvZCcsJ1xcXFx1MjIxMCc6J2NvcHJvZCcsJ1xcXFx1MjIxMSc6J3N1bScsJysnOidwbHVzJywnXFxcXHhCMSc6J3BtJywnXFxcXHhGNyc6J2RpdicsJ1xcXFx4RDcnOid0aW1lcycsJzwnOidsdCcsJ1xcXFx1MjI2RSc6J25sdCcsJzxcXFxcdTIwRDInOidudmx0JywnPSc6J2VxdWFscycsJ1xcXFx1MjI2MCc6J25lJywnPVxcXFx1MjBFNSc6J2JuZScsJ1xcXFx1MkE3NSc6J0VxdWFsJywnPic6J2d0JywnXFxcXHUyMjZGJzonbmd0JywnPlxcXFx1MjBEMic6J252Z3QnLCdcXFxceEFDJzonbm90JywnfCc6J3ZlcnQnLCdcXFxceEE2JzonYnJ2YmFyJywnXFxcXHUyMjEyJzonbWludXMnLCdcXFxcdTIyMTMnOidtcCcsJ1xcXFx1MjIxNCc6J3BsdXNkbycsJ1xcXFx1MjA0NCc6J2ZyYXNsJywnXFxcXHUyMjE2Jzonc2V0bW4nLCdcXFxcdTIyMTcnOidsb3dhc3QnLCdcXFxcdTIyMTgnOidjb21wZm4nLCdcXFxcdTIyMUEnOidTcXJ0JywnXFxcXHUyMjFEJzoncHJvcCcsJ1xcXFx1MjIxRSc6J2luZmluJywnXFxcXHUyMjFGJzonYW5ncnQnLCdcXFxcdTIyMjAnOidhbmcnLCdcXFxcdTIyMjBcXFxcdTIwRDInOiduYW5nJywnXFxcXHUyMjIxJzonYW5nbXNkJywnXFxcXHUyMjIyJzonYW5nc3BoJywnXFxcXHUyMjIzJzonbWlkJywnXFxcXHUyMjI0Jzonbm1pZCcsJ1xcXFx1MjIyNSc6J3BhcicsJ1xcXFx1MjIyNic6J25wYXInLCdcXFxcdTIyMjcnOidhbmQnLCdcXFxcdTIyMjgnOidvcicsJ1xcXFx1MjIyOSc6J2NhcCcsJ1xcXFx1MjIyOVxcXFx1RkUwMCc6J2NhcHMnLCdcXFxcdTIyMkEnOidjdXAnLCdcXFxcdTIyMkFcXFxcdUZFMDAnOidjdXBzJywnXFxcXHUyMjJCJzonaW50JywnXFxcXHUyMjJDJzonSW50JywnXFxcXHUyMjJEJzondGludCcsJ1xcXFx1MkEwQyc6J3FpbnQnLCdcXFxcdTIyMkUnOidvaW50JywnXFxcXHUyMjJGJzonQ29uaW50JywnXFxcXHUyMjMwJzonQ2NvbmludCcsJ1xcXFx1MjIzMSc6J2N3aW50JywnXFxcXHUyMjMyJzonY3djb25pbnQnLCdcXFxcdTIyMzMnOidhd2NvbmludCcsJ1xcXFx1MjIzNCc6J3RoZXJlNCcsJ1xcXFx1MjIzNSc6J2JlY2F1cycsJ1xcXFx1MjIzNic6J3JhdGlvJywnXFxcXHUyMjM3JzonQ29sb24nLCdcXFxcdTIyMzgnOidtaW51c2QnLCdcXFxcdTIyM0EnOidtRERvdCcsJ1xcXFx1MjIzQic6J2hvbXRodCcsJ1xcXFx1MjIzQyc6J3NpbScsJ1xcXFx1MjI0MSc6J25zaW0nLCdcXFxcdTIyM0NcXFxcdTIwRDInOidudnNpbScsJ1xcXFx1MjIzRCc6J2JzaW0nLCdcXFxcdTIyM0RcXFxcdTAzMzEnOidyYWNlJywnXFxcXHUyMjNFJzonYWMnLCdcXFxcdTIyM0VcXFxcdTAzMzMnOidhY0UnLCdcXFxcdTIyM0YnOidhY2QnLCdcXFxcdTIyNDAnOid3cicsJ1xcXFx1MjI0Mic6J2VzaW0nLCdcXFxcdTIyNDJcXFxcdTAzMzgnOiduZXNpbScsJ1xcXFx1MjI0Myc6J3NpbWUnLCdcXFxcdTIyNDQnOiduc2ltZScsJ1xcXFx1MjI0NSc6J2NvbmcnLCdcXFxcdTIyNDcnOiduY29uZycsJ1xcXFx1MjI0Nic6J3NpbW5lJywnXFxcXHUyMjQ4JzonYXAnLCdcXFxcdTIyNDknOiduYXAnLCdcXFxcdTIyNEEnOidhcGUnLCdcXFxcdTIyNEInOidhcGlkJywnXFxcXHUyMjRCXFxcXHUwMzM4JzonbmFwaWQnLCdcXFxcdTIyNEMnOidiY29uZycsJ1xcXFx1MjI0RCc6J0N1cENhcCcsJ1xcXFx1MjI2RCc6J05vdEN1cENhcCcsJ1xcXFx1MjI0RFxcXFx1MjBEMic6J252YXAnLCdcXFxcdTIyNEUnOididW1wJywnXFxcXHUyMjRFXFxcXHUwMzM4JzonbmJ1bXAnLCdcXFxcdTIyNEYnOididW1wZScsJ1xcXFx1MjI0RlxcXFx1MDMzOCc6J25idW1wZScsJ1xcXFx1MjI1MCc6J2RvdGVxJywnXFxcXHUyMjUwXFxcXHUwMzM4JzonbmVkb3QnLCdcXFxcdTIyNTEnOidlRG90JywnXFxcXHUyMjUyJzonZWZEb3QnLCdcXFxcdTIyNTMnOidlckRvdCcsJ1xcXFx1MjI1NCc6J2NvbG9uZScsJ1xcXFx1MjI1NSc6J2Vjb2xvbicsJ1xcXFx1MjI1Nic6J2VjaXInLCdcXFxcdTIyNTcnOidjaXJlJywnXFxcXHUyMjU5Jzond2VkZ2VxJywnXFxcXHUyMjVBJzondmVlZXEnLCdcXFxcdTIyNUMnOid0cmllJywnXFxcXHUyMjVGJzonZXF1ZXN0JywnXFxcXHUyMjYxJzonZXF1aXYnLCdcXFxcdTIyNjInOiduZXF1aXYnLCdcXFxcdTIyNjFcXFxcdTIwRTUnOidibmVxdWl2JywnXFxcXHUyMjY0JzonbGUnLCdcXFxcdTIyNzAnOidubGUnLCdcXFxcdTIyNjRcXFxcdTIwRDInOidudmxlJywnXFxcXHUyMjY1JzonZ2UnLCdcXFxcdTIyNzEnOiduZ2UnLCdcXFxcdTIyNjVcXFxcdTIwRDInOidudmdlJywnXFxcXHUyMjY2JzonbEUnLCdcXFxcdTIyNjZcXFxcdTAzMzgnOidubEUnLCdcXFxcdTIyNjcnOidnRScsJ1xcXFx1MjI2N1xcXFx1MDMzOCc6J25nRScsJ1xcXFx1MjI2OFxcXFx1RkUwMCc6J2x2bkUnLCdcXFxcdTIyNjgnOidsbkUnLCdcXFxcdTIyNjknOidnbkUnLCdcXFxcdTIyNjlcXFxcdUZFMDAnOidndm5FJywnXFxcXHUyMjZBJzonbGwnLCdcXFxcdTIyNkFcXFxcdTAzMzgnOiduTHR2JywnXFxcXHUyMjZBXFxcXHUyMEQyJzonbkx0JywnXFxcXHUyMjZCJzonZ2cnLCdcXFxcdTIyNkJcXFxcdTAzMzgnOiduR3R2JywnXFxcXHUyMjZCXFxcXHUyMEQyJzonbkd0JywnXFxcXHUyMjZDJzondHdpeHQnLCdcXFxcdTIyNzInOidsc2ltJywnXFxcXHUyMjc0JzonbmxzaW0nLCdcXFxcdTIyNzMnOidnc2ltJywnXFxcXHUyMjc1JzonbmdzaW0nLCdcXFxcdTIyNzYnOidsZycsJ1xcXFx1MjI3OCc6J250bGcnLCdcXFxcdTIyNzcnOidnbCcsJ1xcXFx1MjI3OSc6J250Z2wnLCdcXFxcdTIyN0EnOidwcicsJ1xcXFx1MjI4MCc6J25wcicsJ1xcXFx1MjI3Qic6J3NjJywnXFxcXHUyMjgxJzonbnNjJywnXFxcXHUyMjdDJzoncHJjdWUnLCdcXFxcdTIyRTAnOiducHJjdWUnLCdcXFxcdTIyN0QnOidzY2N1ZScsJ1xcXFx1MjJFMSc6J25zY2N1ZScsJ1xcXFx1MjI3RSc6J3Byc2ltJywnXFxcXHUyMjdGJzonc2NzaW0nLCdcXFxcdTIyN0ZcXFxcdTAzMzgnOidOb3RTdWNjZWVkc1RpbGRlJywnXFxcXHUyMjgyJzonc3ViJywnXFxcXHUyMjg0JzonbnN1YicsJ1xcXFx1MjI4MlxcXFx1MjBEMic6J3Zuc3ViJywnXFxcXHUyMjgzJzonc3VwJywnXFxcXHUyMjg1JzonbnN1cCcsJ1xcXFx1MjI4M1xcXFx1MjBEMic6J3Zuc3VwJywnXFxcXHUyMjg2Jzonc3ViZScsJ1xcXFx1MjI4OCc6J25zdWJlJywnXFxcXHUyMjg3Jzonc3VwZScsJ1xcXFx1MjI4OSc6J25zdXBlJywnXFxcXHUyMjhBXFxcXHVGRTAwJzondnN1Ym5lJywnXFxcXHUyMjhBJzonc3VibmUnLCdcXFxcdTIyOEJcXFxcdUZFMDAnOid2c3VwbmUnLCdcXFxcdTIyOEInOidzdXBuZScsJ1xcXFx1MjI4RCc6J2N1cGRvdCcsJ1xcXFx1MjI4RSc6J3VwbHVzJywnXFxcXHUyMjhGJzonc3FzdWInLCdcXFxcdTIyOEZcXFxcdTAzMzgnOidOb3RTcXVhcmVTdWJzZXQnLCdcXFxcdTIyOTAnOidzcXN1cCcsJ1xcXFx1MjI5MFxcXFx1MDMzOCc6J05vdFNxdWFyZVN1cGVyc2V0JywnXFxcXHUyMjkxJzonc3FzdWJlJywnXFxcXHUyMkUyJzonbnNxc3ViZScsJ1xcXFx1MjI5Mic6J3Nxc3VwZScsJ1xcXFx1MjJFMyc6J25zcXN1cGUnLCdcXFxcdTIyOTMnOidzcWNhcCcsJ1xcXFx1MjI5M1xcXFx1RkUwMCc6J3NxY2FwcycsJ1xcXFx1MjI5NCc6J3NxY3VwJywnXFxcXHUyMjk0XFxcXHVGRTAwJzonc3FjdXBzJywnXFxcXHUyMjk1Jzonb3BsdXMnLCdcXFxcdTIyOTYnOidvbWludXMnLCdcXFxcdTIyOTcnOidvdGltZXMnLCdcXFxcdTIyOTgnOidvc29sJywnXFxcXHUyMjk5Jzonb2RvdCcsJ1xcXFx1MjI5QSc6J29jaXInLCdcXFxcdTIyOUInOidvYXN0JywnXFxcXHUyMjlEJzonb2Rhc2gnLCdcXFxcdTIyOUUnOidwbHVzYicsJ1xcXFx1MjI5Ric6J21pbnVzYicsJ1xcXFx1MjJBMCc6J3RpbWVzYicsJ1xcXFx1MjJBMSc6J3Nkb3RiJywnXFxcXHUyMkEyJzondmRhc2gnLCdcXFxcdTIyQUMnOidudmRhc2gnLCdcXFxcdTIyQTMnOidkYXNodicsJ1xcXFx1MjJBNCc6J3RvcCcsJ1xcXFx1MjJBNSc6J2JvdCcsJ1xcXFx1MjJBNyc6J21vZGVscycsJ1xcXFx1MjJBOCc6J3ZEYXNoJywnXFxcXHUyMkFEJzonbnZEYXNoJywnXFxcXHUyMkE5JzonVmRhc2gnLCdcXFxcdTIyQUUnOiduVmRhc2gnLCdcXFxcdTIyQUEnOidWdmRhc2gnLCdcXFxcdTIyQUInOidWRGFzaCcsJ1xcXFx1MjJBRic6J25WRGFzaCcsJ1xcXFx1MjJCMCc6J3BydXJlbCcsJ1xcXFx1MjJCMic6J3ZsdHJpJywnXFxcXHUyMkVBJzonbmx0cmknLCdcXFxcdTIyQjMnOid2cnRyaScsJ1xcXFx1MjJFQic6J25ydHJpJywnXFxcXHUyMkI0JzonbHRyaWUnLCdcXFxcdTIyRUMnOidubHRyaWUnLCdcXFxcdTIyQjRcXFxcdTIwRDInOidudmx0cmllJywnXFxcXHUyMkI1JzoncnRyaWUnLCdcXFxcdTIyRUQnOiducnRyaWUnLCdcXFxcdTIyQjVcXFxcdTIwRDInOidudnJ0cmllJywnXFxcXHUyMkI2Jzonb3JpZ29mJywnXFxcXHUyMkI3JzonaW1vZicsJ1xcXFx1MjJCOCc6J211bWFwJywnXFxcXHUyMkI5JzonaGVyY29uJywnXFxcXHUyMkJBJzonaW50Y2FsJywnXFxcXHUyMkJCJzondmVlYmFyJywnXFxcXHUyMkJEJzonYmFydmVlJywnXFxcXHUyMkJFJzonYW5ncnR2YicsJ1xcXFx1MjJCRic6J2xydHJpJywnXFxcXHUyMkMwJzonV2VkZ2UnLCdcXFxcdTIyQzEnOidWZWUnLCdcXFxcdTIyQzInOid4Y2FwJywnXFxcXHUyMkMzJzoneGN1cCcsJ1xcXFx1MjJDNCc6J2RpYW0nLCdcXFxcdTIyQzUnOidzZG90JywnXFxcXHUyMkM2JzonU3RhcicsJ1xcXFx1MjJDNyc6J2Rpdm9ueCcsJ1xcXFx1MjJDOCc6J2Jvd3RpZScsJ1xcXFx1MjJDOSc6J2x0aW1lcycsJ1xcXFx1MjJDQSc6J3J0aW1lcycsJ1xcXFx1MjJDQic6J2x0aHJlZScsJ1xcXFx1MjJDQyc6J3J0aHJlZScsJ1xcXFx1MjJDRCc6J2JzaW1lJywnXFxcXHUyMkNFJzonY3V2ZWUnLCdcXFxcdTIyQ0YnOidjdXdlZCcsJ1xcXFx1MjJEMCc6J1N1YicsJ1xcXFx1MjJEMSc6J1N1cCcsJ1xcXFx1MjJEMic6J0NhcCcsJ1xcXFx1MjJEMyc6J0N1cCcsJ1xcXFx1MjJENCc6J2ZvcmsnLCdcXFxcdTIyRDUnOidlcGFyJywnXFxcXHUyMkQ2JzonbHRkb3QnLCdcXFxcdTIyRDcnOidndGRvdCcsJ1xcXFx1MjJEOCc6J0xsJywnXFxcXHUyMkQ4XFxcXHUwMzM4JzonbkxsJywnXFxcXHUyMkQ5JzonR2cnLCdcXFxcdTIyRDlcXFxcdTAzMzgnOiduR2cnLCdcXFxcdTIyREFcXFxcdUZFMDAnOidsZXNnJywnXFxcXHUyMkRBJzonbGVnJywnXFxcXHUyMkRCJzonZ2VsJywnXFxcXHUyMkRCXFxcXHVGRTAwJzonZ2VzbCcsJ1xcXFx1MjJERSc6J2N1ZXByJywnXFxcXHUyMkRGJzonY3Vlc2MnLCdcXFxcdTIyRTYnOidsbnNpbScsJ1xcXFx1MjJFNyc6J2duc2ltJywnXFxcXHUyMkU4JzoncHJuc2ltJywnXFxcXHUyMkU5Jzonc2Nuc2ltJywnXFxcXHUyMkVFJzondmVsbGlwJywnXFxcXHUyMkVGJzonY3Rkb3QnLCdcXFxcdTIyRjAnOid1dGRvdCcsJ1xcXFx1MjJGMSc6J2R0ZG90JywnXFxcXHUyMkYyJzonZGlzaW4nLCdcXFxcdTIyRjMnOidpc2luc3YnLCdcXFxcdTIyRjQnOidpc2lucycsJ1xcXFx1MjJGNSc6J2lzaW5kb3QnLCdcXFxcdTIyRjVcXFxcdTAzMzgnOidub3RpbmRvdCcsJ1xcXFx1MjJGNic6J25vdGludmMnLCdcXFxcdTIyRjcnOidub3RpbnZiJywnXFxcXHUyMkY5JzonaXNpbkUnLCdcXFxcdTIyRjlcXFxcdTAzMzgnOidub3RpbkUnLCdcXFxcdTIyRkEnOiduaXNkJywnXFxcXHUyMkZCJzoneG5pcycsJ1xcXFx1MjJGQyc6J25pcycsJ1xcXFx1MjJGRCc6J25vdG5pdmMnLCdcXFxcdTIyRkUnOidub3RuaXZiJywnXFxcXHUyMzA1JzonYmFyd2VkJywnXFxcXHUyMzA2JzonQmFyd2VkJywnXFxcXHUyMzBDJzonZHJjcm9wJywnXFxcXHUyMzBEJzonZGxjcm9wJywnXFxcXHUyMzBFJzondXJjcm9wJywnXFxcXHUyMzBGJzondWxjcm9wJywnXFxcXHUyMzEwJzonYm5vdCcsJ1xcXFx1MjMxMic6J3Byb2ZsaW5lJywnXFxcXHUyMzEzJzoncHJvZnN1cmYnLCdcXFxcdTIzMTUnOid0ZWxyZWMnLCdcXFxcdTIzMTYnOid0YXJnZXQnLCdcXFxcdTIzMUMnOid1bGNvcm4nLCdcXFxcdTIzMUQnOid1cmNvcm4nLCdcXFxcdTIzMUUnOidkbGNvcm4nLCdcXFxcdTIzMUYnOidkcmNvcm4nLCdcXFxcdTIzMjInOidmcm93bicsJ1xcXFx1MjMyMyc6J3NtaWxlJywnXFxcXHUyMzJEJzonY3lsY3R5JywnXFxcXHUyMzJFJzoncHJvZmFsYXInLCdcXFxcdTIzMzYnOid0b3Bib3QnLCdcXFxcdTIzM0QnOidvdmJhcicsJ1xcXFx1MjMzRic6J3NvbGJhcicsJ1xcXFx1MjM3Qyc6J2FuZ3phcnInLCdcXFxcdTIzQjAnOidsbW91c3QnLCdcXFxcdTIzQjEnOidybW91c3QnLCdcXFxcdTIzQjQnOid0YnJrJywnXFxcXHUyM0I1JzonYmJyaycsJ1xcXFx1MjNCNic6J2Jicmt0YnJrJywnXFxcXHUyM0RDJzonT3ZlclBhcmVudGhlc2lzJywnXFxcXHUyM0REJzonVW5kZXJQYXJlbnRoZXNpcycsJ1xcXFx1MjNERSc6J092ZXJCcmFjZScsJ1xcXFx1MjNERic6J1VuZGVyQnJhY2UnLCdcXFxcdTIzRTInOid0cnBleml1bScsJ1xcXFx1MjNFNyc6J2VsaW50ZXJzJywnXFxcXHUyNDIzJzonYmxhbmsnLCdcXFxcdTI1MDAnOidib3hoJywnXFxcXHUyNTAyJzonYm94dicsJ1xcXFx1MjUwQyc6J2JveGRyJywnXFxcXHUyNTEwJzonYm94ZGwnLCdcXFxcdTI1MTQnOidib3h1cicsJ1xcXFx1MjUxOCc6J2JveHVsJywnXFxcXHUyNTFDJzonYm94dnInLCdcXFxcdTI1MjQnOidib3h2bCcsJ1xcXFx1MjUyQyc6J2JveGhkJywnXFxcXHUyNTM0JzonYm94aHUnLCdcXFxcdTI1M0MnOidib3h2aCcsJ1xcXFx1MjU1MCc6J2JveEgnLCdcXFxcdTI1NTEnOidib3hWJywnXFxcXHUyNTUyJzonYm94ZFInLCdcXFxcdTI1NTMnOidib3hEcicsJ1xcXFx1MjU1NCc6J2JveERSJywnXFxcXHUyNTU1JzonYm94ZEwnLCdcXFxcdTI1NTYnOidib3hEbCcsJ1xcXFx1MjU1Nyc6J2JveERMJywnXFxcXHUyNTU4JzonYm94dVInLCdcXFxcdTI1NTknOidib3hVcicsJ1xcXFx1MjU1QSc6J2JveFVSJywnXFxcXHUyNTVCJzonYm94dUwnLCdcXFxcdTI1NUMnOidib3hVbCcsJ1xcXFx1MjU1RCc6J2JveFVMJywnXFxcXHUyNTVFJzonYm94dlInLCdcXFxcdTI1NUYnOidib3hWcicsJ1xcXFx1MjU2MCc6J2JveFZSJywnXFxcXHUyNTYxJzonYm94dkwnLCdcXFxcdTI1NjInOidib3hWbCcsJ1xcXFx1MjU2Myc6J2JveFZMJywnXFxcXHUyNTY0JzonYm94SGQnLCdcXFxcdTI1NjUnOidib3hoRCcsJ1xcXFx1MjU2Nic6J2JveEhEJywnXFxcXHUyNTY3JzonYm94SHUnLCdcXFxcdTI1NjgnOidib3hoVScsJ1xcXFx1MjU2OSc6J2JveEhVJywnXFxcXHUyNTZBJzonYm94dkgnLCdcXFxcdTI1NkInOidib3hWaCcsJ1xcXFx1MjU2Qyc6J2JveFZIJywnXFxcXHUyNTgwJzondWhibGsnLCdcXFxcdTI1ODQnOidsaGJsaycsJ1xcXFx1MjU4OCc6J2Jsb2NrJywnXFxcXHUyNTkxJzonYmxrMTQnLCdcXFxcdTI1OTInOidibGsxMicsJ1xcXFx1MjU5Myc6J2JsazM0JywnXFxcXHUyNUExJzonc3F1JywnXFxcXHUyNUFBJzonc3F1ZicsJ1xcXFx1MjVBQic6J0VtcHR5VmVyeVNtYWxsU3F1YXJlJywnXFxcXHUyNUFEJzoncmVjdCcsJ1xcXFx1MjVBRSc6J21hcmtlcicsJ1xcXFx1MjVCMSc6J2ZsdG5zJywnXFxcXHUyNUIzJzoneHV0cmknLCdcXFxcdTI1QjQnOid1dHJpZicsJ1xcXFx1MjVCNSc6J3V0cmknLCdcXFxcdTI1QjgnOidydHJpZicsJ1xcXFx1MjVCOSc6J3J0cmknLCdcXFxcdTI1QkQnOid4ZHRyaScsJ1xcXFx1MjVCRSc6J2R0cmlmJywnXFxcXHUyNUJGJzonZHRyaScsJ1xcXFx1MjVDMic6J2x0cmlmJywnXFxcXHUyNUMzJzonbHRyaScsJ1xcXFx1MjVDQSc6J2xveicsJ1xcXFx1MjVDQic6J2NpcicsJ1xcXFx1MjVFQyc6J3RyaWRvdCcsJ1xcXFx1MjVFRic6J3hjaXJjJywnXFxcXHUyNUY4JzondWx0cmknLCdcXFxcdTI1RjknOid1cnRyaScsJ1xcXFx1MjVGQSc6J2xsdHJpJywnXFxcXHUyNUZCJzonRW1wdHlTbWFsbFNxdWFyZScsJ1xcXFx1MjVGQyc6J0ZpbGxlZFNtYWxsU3F1YXJlJywnXFxcXHUyNjA1Jzonc3RhcmYnLCdcXFxcdTI2MDYnOidzdGFyJywnXFxcXHUyNjBFJzoncGhvbmUnLCdcXFxcdTI2NDAnOidmZW1hbGUnLCdcXFxcdTI2NDInOidtYWxlJywnXFxcXHUyNjYwJzonc3BhZGVzJywnXFxcXHUyNjYzJzonY2x1YnMnLCdcXFxcdTI2NjUnOidoZWFydHMnLCdcXFxcdTI2NjYnOidkaWFtcycsJ1xcXFx1MjY2QSc6J3N1bmcnLCdcXFxcdTI3MTMnOidjaGVjaycsJ1xcXFx1MjcxNyc6J2Nyb3NzJywnXFxcXHUyNzIwJzonbWFsdCcsJ1xcXFx1MjczNic6J3NleHQnLCdcXFxcdTI3NTgnOidWZXJ0aWNhbFNlcGFyYXRvcicsJ1xcXFx1MjdDOCc6J2Jzb2xoc3ViJywnXFxcXHUyN0M5Jzonc3VwaHNvbCcsJ1xcXFx1MjdGNSc6J3hsYXJyJywnXFxcXHUyN0Y2JzoneHJhcnInLCdcXFxcdTI3RjcnOid4aGFycicsJ1xcXFx1MjdGOCc6J3hsQXJyJywnXFxcXHUyN0Y5JzoneHJBcnInLCdcXFxcdTI3RkEnOid4aEFycicsJ1xcXFx1MjdGQyc6J3htYXAnLCdcXFxcdTI3RkYnOidkemlncmFycicsJ1xcXFx1MjkwMic6J252bEFycicsJ1xcXFx1MjkwMyc6J252ckFycicsJ1xcXFx1MjkwNCc6J252SGFycicsJ1xcXFx1MjkwNSc6J01hcCcsJ1xcXFx1MjkwQyc6J2xiYXJyJywnXFxcXHUyOTBEJzoncmJhcnInLCdcXFxcdTI5MEUnOidsQmFycicsJ1xcXFx1MjkwRic6J3JCYXJyJywnXFxcXHUyOTEwJzonUkJhcnInLCdcXFxcdTI5MTEnOidERG90cmFoZCcsJ1xcXFx1MjkxMic6J1VwQXJyb3dCYXInLCdcXFxcdTI5MTMnOidEb3duQXJyb3dCYXInLCdcXFxcdTI5MTYnOidSYXJydGwnLCdcXFxcdTI5MTknOidsYXRhaWwnLCdcXFxcdTI5MUEnOidyYXRhaWwnLCdcXFxcdTI5MUInOidsQXRhaWwnLCdcXFxcdTI5MUMnOidyQXRhaWwnLCdcXFxcdTI5MUQnOidsYXJyZnMnLCdcXFxcdTI5MUUnOidyYXJyZnMnLCdcXFxcdTI5MUYnOidsYXJyYmZzJywnXFxcXHUyOTIwJzoncmFycmJmcycsJ1xcXFx1MjkyMyc6J253YXJoaycsJ1xcXFx1MjkyNCc6J25lYXJoaycsJ1xcXFx1MjkyNSc6J3NlYXJoaycsJ1xcXFx1MjkyNic6J3N3YXJoaycsJ1xcXFx1MjkyNyc6J253bmVhcicsJ1xcXFx1MjkyOCc6J3RvZWEnLCdcXFxcdTI5MjknOid0b3NhJywnXFxcXHUyOTJBJzonc3dud2FyJywnXFxcXHUyOTMzJzoncmFycmMnLCdcXFxcdTI5MzNcXFxcdTAzMzgnOiducmFycmMnLCdcXFxcdTI5MzUnOidjdWRhcnJyJywnXFxcXHUyOTM2JzonbGRjYScsJ1xcXFx1MjkzNyc6J3JkY2EnLCdcXFxcdTI5MzgnOidjdWRhcnJsJywnXFxcXHUyOTM5JzonbGFycnBsJywnXFxcXHUyOTNDJzonY3VyYXJybScsJ1xcXFx1MjkzRCc6J2N1bGFycnAnLCdcXFxcdTI5NDUnOidyYXJycGwnLCdcXFxcdTI5NDgnOidoYXJyY2lyJywnXFxcXHUyOTQ5JzonVWFycm9jaXInLCdcXFxcdTI5NEEnOidsdXJkc2hhcicsJ1xcXFx1Mjk0Qic6J2xkcnVzaGFyJywnXFxcXHUyOTRFJzonTGVmdFJpZ2h0VmVjdG9yJywnXFxcXHUyOTRGJzonUmlnaHRVcERvd25WZWN0b3InLCdcXFxcdTI5NTAnOidEb3duTGVmdFJpZ2h0VmVjdG9yJywnXFxcXHUyOTUxJzonTGVmdFVwRG93blZlY3RvcicsJ1xcXFx1Mjk1Mic6J0xlZnRWZWN0b3JCYXInLCdcXFxcdTI5NTMnOidSaWdodFZlY3RvckJhcicsJ1xcXFx1Mjk1NCc6J1JpZ2h0VXBWZWN0b3JCYXInLCdcXFxcdTI5NTUnOidSaWdodERvd25WZWN0b3JCYXInLCdcXFxcdTI5NTYnOidEb3duTGVmdFZlY3RvckJhcicsJ1xcXFx1Mjk1Nyc6J0Rvd25SaWdodFZlY3RvckJhcicsJ1xcXFx1Mjk1OCc6J0xlZnRVcFZlY3RvckJhcicsJ1xcXFx1Mjk1OSc6J0xlZnREb3duVmVjdG9yQmFyJywnXFxcXHUyOTVBJzonTGVmdFRlZVZlY3RvcicsJ1xcXFx1Mjk1Qic6J1JpZ2h0VGVlVmVjdG9yJywnXFxcXHUyOTVDJzonUmlnaHRVcFRlZVZlY3RvcicsJ1xcXFx1Mjk1RCc6J1JpZ2h0RG93blRlZVZlY3RvcicsJ1xcXFx1Mjk1RSc6J0Rvd25MZWZ0VGVlVmVjdG9yJywnXFxcXHUyOTVGJzonRG93blJpZ2h0VGVlVmVjdG9yJywnXFxcXHUyOTYwJzonTGVmdFVwVGVlVmVjdG9yJywnXFxcXHUyOTYxJzonTGVmdERvd25UZWVWZWN0b3InLCdcXFxcdTI5NjInOidsSGFyJywnXFxcXHUyOTYzJzondUhhcicsJ1xcXFx1Mjk2NCc6J3JIYXInLCdcXFxcdTI5NjUnOidkSGFyJywnXFxcXHUyOTY2JzonbHVydWhhcicsJ1xcXFx1Mjk2Nyc6J2xkcmRoYXInLCdcXFxcdTI5NjgnOidydWx1aGFyJywnXFxcXHUyOTY5JzoncmRsZGhhcicsJ1xcXFx1Mjk2QSc6J2xoYXJ1bCcsJ1xcXFx1Mjk2Qic6J2xsaGFyZCcsJ1xcXFx1Mjk2Qyc6J3JoYXJ1bCcsJ1xcXFx1Mjk2RCc6J2xyaGFyZCcsJ1xcXFx1Mjk2RSc6J3VkaGFyJywnXFxcXHUyOTZGJzonZHVoYXInLCdcXFxcdTI5NzAnOidSb3VuZEltcGxpZXMnLCdcXFxcdTI5NzEnOidlcmFycicsJ1xcXFx1Mjk3Mic6J3NpbXJhcnInLCdcXFxcdTI5NzMnOidsYXJyc2ltJywnXFxcXHUyOTc0JzoncmFycnNpbScsJ1xcXFx1Mjk3NSc6J3JhcnJhcCcsJ1xcXFx1Mjk3Nic6J2x0bGFycicsJ1xcXFx1Mjk3OCc6J2d0cmFycicsJ1xcXFx1Mjk3OSc6J3N1YnJhcnInLCdcXFxcdTI5N0InOidzdXBsYXJyJywnXFxcXHUyOTdDJzonbGZpc2h0JywnXFxcXHUyOTdEJzoncmZpc2h0JywnXFxcXHUyOTdFJzondWZpc2h0JywnXFxcXHUyOTdGJzonZGZpc2h0JywnXFxcXHUyOTlBJzondnppZ3phZycsJ1xcXFx1Mjk5Qyc6J3ZhbmdydCcsJ1xcXFx1Mjk5RCc6J2FuZ3J0dmJkJywnXFxcXHUyOUE0JzonYW5nZScsJ1xcXFx1MjlBNSc6J3JhbmdlJywnXFxcXHUyOUE2JzonZHdhbmdsZScsJ1xcXFx1MjlBNyc6J3V3YW5nbGUnLCdcXFxcdTI5QTgnOidhbmdtc2RhYScsJ1xcXFx1MjlBOSc6J2FuZ21zZGFiJywnXFxcXHUyOUFBJzonYW5nbXNkYWMnLCdcXFxcdTI5QUInOidhbmdtc2RhZCcsJ1xcXFx1MjlBQyc6J2FuZ21zZGFlJywnXFxcXHUyOUFEJzonYW5nbXNkYWYnLCdcXFxcdTI5QUUnOidhbmdtc2RhZycsJ1xcXFx1MjlBRic6J2FuZ21zZGFoJywnXFxcXHUyOUIwJzonYmVtcHR5dicsJ1xcXFx1MjlCMSc6J2RlbXB0eXYnLCdcXFxcdTI5QjInOidjZW1wdHl2JywnXFxcXHUyOUIzJzoncmFlbXB0eXYnLCdcXFxcdTI5QjQnOidsYWVtcHR5dicsJ1xcXFx1MjlCNSc6J29oYmFyJywnXFxcXHUyOUI2Jzonb21pZCcsJ1xcXFx1MjlCNyc6J29wYXInLCdcXFxcdTI5QjknOidvcGVycCcsJ1xcXFx1MjlCQic6J29sY3Jvc3MnLCdcXFxcdTI5QkMnOidvZHNvbGQnLCdcXFxcdTI5QkUnOidvbGNpcicsJ1xcXFx1MjlCRic6J29mY2lyJywnXFxcXHUyOUMwJzonb2x0JywnXFxcXHUyOUMxJzonb2d0JywnXFxcXHUyOUMyJzonY2lyc2NpcicsJ1xcXFx1MjlDMyc6J2NpckUnLCdcXFxcdTI5QzQnOidzb2xiJywnXFxcXHUyOUM1JzonYnNvbGInLCdcXFxcdTI5QzknOidib3hib3gnLCdcXFxcdTI5Q0QnOid0cmlzYicsJ1xcXFx1MjlDRSc6J3J0cmlsdHJpJywnXFxcXHUyOUNGJzonTGVmdFRyaWFuZ2xlQmFyJywnXFxcXHUyOUNGXFxcXHUwMzM4JzonTm90TGVmdFRyaWFuZ2xlQmFyJywnXFxcXHUyOUQwJzonUmlnaHRUcmlhbmdsZUJhcicsJ1xcXFx1MjlEMFxcXFx1MDMzOCc6J05vdFJpZ2h0VHJpYW5nbGVCYXInLCdcXFxcdTI5REMnOidpaW5maW4nLCdcXFxcdTI5REQnOidpbmZpbnRpZScsJ1xcXFx1MjlERSc6J252aW5maW4nLCdcXFxcdTI5RTMnOidlcGFyc2wnLCdcXFxcdTI5RTQnOidzbWVwYXJzbCcsJ1xcXFx1MjlFNSc6J2VxdnBhcnNsJywnXFxcXHUyOUVCJzonbG96ZicsJ1xcXFx1MjlGNCc6J1J1bGVEZWxheWVkJywnXFxcXHUyOUY2JzonZHNvbCcsJ1xcXFx1MkEwMCc6J3hvZG90JywnXFxcXHUyQTAxJzoneG9wbHVzJywnXFxcXHUyQTAyJzoneG90aW1lJywnXFxcXHUyQTA0JzoneHVwbHVzJywnXFxcXHUyQTA2JzoneHNxY3VwJywnXFxcXHUyQTBEJzonZnBhcnRpbnQnLCdcXFxcdTJBMTAnOidjaXJmbmludCcsJ1xcXFx1MkExMSc6J2F3aW50JywnXFxcXHUyQTEyJzoncnBwb2xpbnQnLCdcXFxcdTJBMTMnOidzY3BvbGludCcsJ1xcXFx1MkExNCc6J25wb2xpbnQnLCdcXFxcdTJBMTUnOidwb2ludGludCcsJ1xcXFx1MkExNic6J3F1YXRpbnQnLCdcXFxcdTJBMTcnOidpbnRsYXJoaycsJ1xcXFx1MkEyMic6J3BsdXNjaXInLCdcXFxcdTJBMjMnOidwbHVzYWNpcicsJ1xcXFx1MkEyNCc6J3NpbXBsdXMnLCdcXFxcdTJBMjUnOidwbHVzZHUnLCdcXFxcdTJBMjYnOidwbHVzc2ltJywnXFxcXHUyQTI3JzoncGx1c3R3bycsJ1xcXFx1MkEyOSc6J21jb21tYScsJ1xcXFx1MkEyQSc6J21pbnVzZHUnLCdcXFxcdTJBMkQnOidsb3BsdXMnLCdcXFxcdTJBMkUnOidyb3BsdXMnLCdcXFxcdTJBMkYnOidDcm9zcycsJ1xcXFx1MkEzMCc6J3RpbWVzZCcsJ1xcXFx1MkEzMSc6J3RpbWVzYmFyJywnXFxcXHUyQTMzJzonc21hc2hwJywnXFxcXHUyQTM0JzonbG90aW1lcycsJ1xcXFx1MkEzNSc6J3JvdGltZXMnLCdcXFxcdTJBMzYnOidvdGltZXNhcycsJ1xcXFx1MkEzNyc6J090aW1lcycsJ1xcXFx1MkEzOCc6J29kaXYnLCdcXFxcdTJBMzknOid0cmlwbHVzJywnXFxcXHUyQTNBJzondHJpbWludXMnLCdcXFxcdTJBM0InOid0cml0aW1lJywnXFxcXHUyQTNDJzonaXByb2QnLCdcXFxcdTJBM0YnOidhbWFsZycsJ1xcXFx1MkE0MCc6J2NhcGRvdCcsJ1xcXFx1MkE0Mic6J25jdXAnLCdcXFxcdTJBNDMnOiduY2FwJywnXFxcXHUyQTQ0JzonY2FwYW5kJywnXFxcXHUyQTQ1JzonY3Vwb3InLCdcXFxcdTJBNDYnOidjdXBjYXAnLCdcXFxcdTJBNDcnOidjYXBjdXAnLCdcXFxcdTJBNDgnOidjdXBicmNhcCcsJ1xcXFx1MkE0OSc6J2NhcGJyY3VwJywnXFxcXHUyQTRBJzonY3VwY3VwJywnXFxcXHUyQTRCJzonY2FwY2FwJywnXFxcXHUyQTRDJzonY2N1cHMnLCdcXFxcdTJBNEQnOidjY2FwcycsJ1xcXFx1MkE1MCc6J2NjdXBzc20nLCdcXFxcdTJBNTMnOidBbmQnLCdcXFxcdTJBNTQnOidPcicsJ1xcXFx1MkE1NSc6J2FuZGFuZCcsJ1xcXFx1MkE1Nic6J29yb3InLCdcXFxcdTJBNTcnOidvcnNsb3BlJywnXFxcXHUyQTU4JzonYW5kc2xvcGUnLCdcXFxcdTJBNUEnOidhbmR2JywnXFxcXHUyQTVCJzonb3J2JywnXFxcXHUyQTVDJzonYW5kZCcsJ1xcXFx1MkE1RCc6J29yZCcsJ1xcXFx1MkE1Ric6J3dlZGJhcicsJ1xcXFx1MkE2Nic6J3Nkb3RlJywnXFxcXHUyQTZBJzonc2ltZG90JywnXFxcXHUyQTZEJzonY29uZ2RvdCcsJ1xcXFx1MkE2RFxcXFx1MDMzOCc6J25jb25nZG90JywnXFxcXHUyQTZFJzonZWFzdGVyJywnXFxcXHUyQTZGJzonYXBhY2lyJywnXFxcXHUyQTcwJzonYXBFJywnXFxcXHUyQTcwXFxcXHUwMzM4JzonbmFwRScsJ1xcXFx1MkE3MSc6J2VwbHVzJywnXFxcXHUyQTcyJzoncGx1c2UnLCdcXFxcdTJBNzMnOidFc2ltJywnXFxcXHUyQTc3JzonZUREb3QnLCdcXFxcdTJBNzgnOidlcXVpdkREJywnXFxcXHUyQTc5JzonbHRjaXInLCdcXFxcdTJBN0EnOidndGNpcicsJ1xcXFx1MkE3Qic6J2x0cXVlc3QnLCdcXFxcdTJBN0MnOidndHF1ZXN0JywnXFxcXHUyQTdEJzonbGVzJywnXFxcXHUyQTdEXFxcXHUwMzM4JzonbmxlcycsJ1xcXFx1MkE3RSc6J2dlcycsJ1xcXFx1MkE3RVxcXFx1MDMzOCc6J25nZXMnLCdcXFxcdTJBN0YnOidsZXNkb3QnLCdcXFxcdTJBODAnOidnZXNkb3QnLCdcXFxcdTJBODEnOidsZXNkb3RvJywnXFxcXHUyQTgyJzonZ2VzZG90bycsJ1xcXFx1MkE4Myc6J2xlc2RvdG9yJywnXFxcXHUyQTg0JzonZ2VzZG90b2wnLCdcXFxcdTJBODUnOidsYXAnLCdcXFxcdTJBODYnOidnYXAnLCdcXFxcdTJBODcnOidsbmUnLCdcXFxcdTJBODgnOidnbmUnLCdcXFxcdTJBODknOidsbmFwJywnXFxcXHUyQThBJzonZ25hcCcsJ1xcXFx1MkE4Qic6J2xFZycsJ1xcXFx1MkE4Qyc6J2dFbCcsJ1xcXFx1MkE4RCc6J2xzaW1lJywnXFxcXHUyQThFJzonZ3NpbWUnLCdcXFxcdTJBOEYnOidsc2ltZycsJ1xcXFx1MkE5MCc6J2dzaW1sJywnXFxcXHUyQTkxJzonbGdFJywnXFxcXHUyQTkyJzonZ2xFJywnXFxcXHUyQTkzJzonbGVzZ2VzJywnXFxcXHUyQTk0JzonZ2VzbGVzJywnXFxcXHUyQTk1JzonZWxzJywnXFxcXHUyQTk2JzonZWdzJywnXFxcXHUyQTk3JzonZWxzZG90JywnXFxcXHUyQTk4JzonZWdzZG90JywnXFxcXHUyQTk5JzonZWwnLCdcXFxcdTJBOUEnOidlZycsJ1xcXFx1MkE5RCc6J3NpbWwnLCdcXFxcdTJBOUUnOidzaW1nJywnXFxcXHUyQTlGJzonc2ltbEUnLCdcXFxcdTJBQTAnOidzaW1nRScsJ1xcXFx1MkFBMSc6J0xlc3NMZXNzJywnXFxcXHUyQUExXFxcXHUwMzM4JzonTm90TmVzdGVkTGVzc0xlc3MnLCdcXFxcdTJBQTInOidHcmVhdGVyR3JlYXRlcicsJ1xcXFx1MkFBMlxcXFx1MDMzOCc6J05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywnXFxcXHUyQUE0JzonZ2xqJywnXFxcXHUyQUE1JzonZ2xhJywnXFxcXHUyQUE2JzonbHRjYycsJ1xcXFx1MkFBNyc6J2d0Y2MnLCdcXFxcdTJBQTgnOidsZXNjYycsJ1xcXFx1MkFBOSc6J2dlc2NjJywnXFxcXHUyQUFBJzonc210JywnXFxcXHUyQUFCJzonbGF0JywnXFxcXHUyQUFDJzonc210ZScsJ1xcXFx1MkFBQ1xcXFx1RkUwMCc6J3NtdGVzJywnXFxcXHUyQUFEJzonbGF0ZScsJ1xcXFx1MkFBRFxcXFx1RkUwMCc6J2xhdGVzJywnXFxcXHUyQUFFJzonYnVtcEUnLCdcXFxcdTJBQUYnOidwcmUnLCdcXFxcdTJBQUZcXFxcdTAzMzgnOiducHJlJywnXFxcXHUyQUIwJzonc2NlJywnXFxcXHUyQUIwXFxcXHUwMzM4JzonbnNjZScsJ1xcXFx1MkFCMyc6J3ByRScsJ1xcXFx1MkFCNCc6J3NjRScsJ1xcXFx1MkFCNSc6J3BybkUnLCdcXFxcdTJBQjYnOidzY25FJywnXFxcXHUyQUI3JzoncHJhcCcsJ1xcXFx1MkFCOCc6J3NjYXAnLCdcXFxcdTJBQjknOidwcm5hcCcsJ1xcXFx1MkFCQSc6J3NjbmFwJywnXFxcXHUyQUJCJzonUHInLCdcXFxcdTJBQkMnOidTYycsJ1xcXFx1MkFCRCc6J3N1YmRvdCcsJ1xcXFx1MkFCRSc6J3N1cGRvdCcsJ1xcXFx1MkFCRic6J3N1YnBsdXMnLCdcXFxcdTJBQzAnOidzdXBwbHVzJywnXFxcXHUyQUMxJzonc3VibXVsdCcsJ1xcXFx1MkFDMic6J3N1cG11bHQnLCdcXFxcdTJBQzMnOidzdWJlZG90JywnXFxcXHUyQUM0Jzonc3VwZWRvdCcsJ1xcXFx1MkFDNSc6J3N1YkUnLCdcXFxcdTJBQzVcXFxcdTAzMzgnOiduc3ViRScsJ1xcXFx1MkFDNic6J3N1cEUnLCdcXFxcdTJBQzZcXFxcdTAzMzgnOiduc3VwRScsJ1xcXFx1MkFDNyc6J3N1YnNpbScsJ1xcXFx1MkFDOCc6J3N1cHNpbScsJ1xcXFx1MkFDQlxcXFx1RkUwMCc6J3ZzdWJuRScsJ1xcXFx1MkFDQic6J3N1Ym5FJywnXFxcXHUyQUNDXFxcXHVGRTAwJzondnN1cG5FJywnXFxcXHUyQUNDJzonc3VwbkUnLCdcXFxcdTJBQ0YnOidjc3ViJywnXFxcXHUyQUQwJzonY3N1cCcsJ1xcXFx1MkFEMSc6J2NzdWJlJywnXFxcXHUyQUQyJzonY3N1cGUnLCdcXFxcdTJBRDMnOidzdWJzdXAnLCdcXFxcdTJBRDQnOidzdXBzdWInLCdcXFxcdTJBRDUnOidzdWJzdWInLCdcXFxcdTJBRDYnOidzdXBzdXAnLCdcXFxcdTJBRDcnOidzdXBoc3ViJywnXFxcXHUyQUQ4Jzonc3VwZHN1YicsJ1xcXFx1MkFEOSc6J2Zvcmt2JywnXFxcXHUyQURBJzondG9wZm9yaycsJ1xcXFx1MkFEQic6J21sY3AnLCdcXFxcdTJBRTQnOidEYXNodicsJ1xcXFx1MkFFNic6J1ZkYXNobCcsJ1xcXFx1MkFFNyc6J0JhcnYnLCdcXFxcdTJBRTgnOid2QmFyJywnXFxcXHUyQUU5JzondkJhcnYnLCdcXFxcdTJBRUInOidWYmFyJywnXFxcXHUyQUVDJzonTm90JywnXFxcXHUyQUVEJzonYk5vdCcsJ1xcXFx1MkFFRSc6J3JubWlkJywnXFxcXHUyQUVGJzonY2lybWlkJywnXFxcXHUyQUYwJzonbWlkY2lyJywnXFxcXHUyQUYxJzondG9wY2lyJywnXFxcXHUyQUYyJzonbmhwYXInLCdcXFxcdTJBRjMnOidwYXJzaW0nLCdcXFxcdTJBRkQnOidwYXJzbCcsJ1xcXFx1MkFGRFxcXFx1MjBFNSc6J25wYXJzbCcsJ1xcXFx1MjY2RCc6J2ZsYXQnLCdcXFxcdTI2NkUnOiduYXR1cicsJ1xcXFx1MjY2Ric6J3NoYXJwJywnXFxcXHhBNCc6J2N1cnJlbicsJ1xcXFx4QTInOidjZW50JywnJCc6J2RvbGxhcicsJ1xcXFx4QTMnOidwb3VuZCcsJ1xcXFx4QTUnOid5ZW4nLCdcXFxcdTIwQUMnOidldXJvJywnXFxcXHhCOSc6J3N1cDEnLCdcXFxceEJEJzonaGFsZicsJ1xcXFx1MjE1Myc6J2ZyYWMxMycsJ1xcXFx4QkMnOidmcmFjMTQnLCdcXFxcdTIxNTUnOidmcmFjMTUnLCdcXFxcdTIxNTknOidmcmFjMTYnLCdcXFxcdTIxNUInOidmcmFjMTgnLCdcXFxceEIyJzonc3VwMicsJ1xcXFx1MjE1NCc6J2ZyYWMyMycsJ1xcXFx1MjE1Nic6J2ZyYWMyNScsJ1xcXFx4QjMnOidzdXAzJywnXFxcXHhCRSc6J2ZyYWMzNCcsJ1xcXFx1MjE1Nyc6J2ZyYWMzNScsJ1xcXFx1MjE1Qyc6J2ZyYWMzOCcsJ1xcXFx1MjE1OCc6J2ZyYWM0NScsJ1xcXFx1MjE1QSc6J2ZyYWM1NicsJ1xcXFx1MjE1RCc6J2ZyYWM1OCcsJ1xcXFx1MjE1RSc6J2ZyYWM3OCcsJ1xcXFx1RDgzNVxcXFx1RENCNic6J2FzY3InLCdcXFxcdUQ4MzVcXFxcdURENTInOidhb3BmJywnXFxcXHVEODM1XFxcXHVERDFFJzonYWZyJywnXFxcXHVEODM1XFxcXHVERDM4JzonQW9wZicsJ1xcXFx1RDgzNVxcXFx1REQwNCc6J0FmcicsJ1xcXFx1RDgzNVxcXFx1REM5Qyc6J0FzY3InLCdcXFxceEFBJzonb3JkZicsJ1xcXFx4RTEnOidhYWN1dGUnLCdcXFxceEMxJzonQWFjdXRlJywnXFxcXHhFMCc6J2FncmF2ZScsJ1xcXFx4QzAnOidBZ3JhdmUnLCdcXFxcdTAxMDMnOidhYnJldmUnLCdcXFxcdTAxMDInOidBYnJldmUnLCdcXFxceEUyJzonYWNpcmMnLCdcXFxceEMyJzonQWNpcmMnLCdcXFxceEU1JzonYXJpbmcnLCdcXFxceEM1JzonYW5nc3QnLCdcXFxceEU0JzonYXVtbCcsJ1xcXFx4QzQnOidBdW1sJywnXFxcXHhFMyc6J2F0aWxkZScsJ1xcXFx4QzMnOidBdGlsZGUnLCdcXFxcdTAxMDUnOidhb2dvbicsJ1xcXFx1MDEwNCc6J0FvZ29uJywnXFxcXHUwMTAxJzonYW1hY3InLCdcXFxcdTAxMDAnOidBbWFjcicsJ1xcXFx4RTYnOidhZWxpZycsJ1xcXFx4QzYnOidBRWxpZycsJ1xcXFx1RDgzNVxcXFx1RENCNyc6J2JzY3InLCdcXFxcdUQ4MzVcXFxcdURENTMnOidib3BmJywnXFxcXHVEODM1XFxcXHVERDFGJzonYmZyJywnXFxcXHVEODM1XFxcXHVERDM5JzonQm9wZicsJ1xcXFx1MjEyQyc6J0JzY3InLCdcXFxcdUQ4MzVcXFxcdUREMDUnOidCZnInLCdcXFxcdUQ4MzVcXFxcdUREMjAnOidjZnInLCdcXFxcdUQ4MzVcXFxcdURDQjgnOidjc2NyJywnXFxcXHVEODM1XFxcXHVERDU0JzonY29wZicsJ1xcXFx1MjEyRCc6J0NmcicsJ1xcXFx1RDgzNVxcXFx1REM5RSc6J0NzY3InLCdcXFxcdTIxMDInOidDb3BmJywnXFxcXHUwMTA3JzonY2FjdXRlJywnXFxcXHUwMTA2JzonQ2FjdXRlJywnXFxcXHUwMTA5JzonY2NpcmMnLCdcXFxcdTAxMDgnOidDY2lyYycsJ1xcXFx1MDEwRCc6J2NjYXJvbicsJ1xcXFx1MDEwQyc6J0NjYXJvbicsJ1xcXFx1MDEwQic6J2Nkb3QnLCdcXFxcdTAxMEEnOidDZG90JywnXFxcXHhFNyc6J2NjZWRpbCcsJ1xcXFx4QzcnOidDY2VkaWwnLCdcXFxcdTIxMDUnOidpbmNhcmUnLCdcXFxcdUQ4MzVcXFxcdUREMjEnOidkZnInLCdcXFxcdTIxNDYnOidkZCcsJ1xcXFx1RDgzNVxcXFx1REQ1NSc6J2RvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjknOidkc2NyJywnXFxcXHVEODM1XFxcXHVEQzlGJzonRHNjcicsJ1xcXFx1RDgzNVxcXFx1REQwNyc6J0RmcicsJ1xcXFx1MjE0NSc6J0REJywnXFxcXHVEODM1XFxcXHVERDNCJzonRG9wZicsJ1xcXFx1MDEwRic6J2RjYXJvbicsJ1xcXFx1MDEwRSc6J0RjYXJvbicsJ1xcXFx1MDExMSc6J2RzdHJvaycsJ1xcXFx1MDExMCc6J0RzdHJvaycsJ1xcXFx4RjAnOidldGgnLCdcXFxceEQwJzonRVRIJywnXFxcXHUyMTQ3JzonZWUnLCdcXFxcdTIxMkYnOidlc2NyJywnXFxcXHVEODM1XFxcXHVERDIyJzonZWZyJywnXFxcXHVEODM1XFxcXHVERDU2JzonZW9wZicsJ1xcXFx1MjEzMCc6J0VzY3InLCdcXFxcdUQ4MzVcXFxcdUREMDgnOidFZnInLCdcXFxcdUQ4MzVcXFxcdUREM0MnOidFb3BmJywnXFxcXHhFOSc6J2VhY3V0ZScsJ1xcXFx4QzknOidFYWN1dGUnLCdcXFxceEU4JzonZWdyYXZlJywnXFxcXHhDOCc6J0VncmF2ZScsJ1xcXFx4RUEnOidlY2lyYycsJ1xcXFx4Q0EnOidFY2lyYycsJ1xcXFx1MDExQic6J2VjYXJvbicsJ1xcXFx1MDExQSc6J0VjYXJvbicsJ1xcXFx4RUInOidldW1sJywnXFxcXHhDQic6J0V1bWwnLCdcXFxcdTAxMTcnOidlZG90JywnXFxcXHUwMTE2JzonRWRvdCcsJ1xcXFx1MDExOSc6J2VvZ29uJywnXFxcXHUwMTE4JzonRW9nb24nLCdcXFxcdTAxMTMnOidlbWFjcicsJ1xcXFx1MDExMic6J0VtYWNyJywnXFxcXHVEODM1XFxcXHVERDIzJzonZmZyJywnXFxcXHVEODM1XFxcXHVERDU3JzonZm9wZicsJ1xcXFx1RDgzNVxcXFx1RENCQic6J2ZzY3InLCdcXFxcdUQ4MzVcXFxcdUREMDknOidGZnInLCdcXFxcdUQ4MzVcXFxcdUREM0QnOidGb3BmJywnXFxcXHUyMTMxJzonRnNjcicsJ1xcXFx1RkIwMCc6J2ZmbGlnJywnXFxcXHVGQjAzJzonZmZpbGlnJywnXFxcXHVGQjA0JzonZmZsbGlnJywnXFxcXHVGQjAxJzonZmlsaWcnLCdmaic6J2ZqbGlnJywnXFxcXHVGQjAyJzonZmxsaWcnLCdcXFxcdTAxOTInOidmbm9mJywnXFxcXHUyMTBBJzonZ3NjcicsJ1xcXFx1RDgzNVxcXFx1REQ1OCc6J2dvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMjQnOidnZnInLCdcXFxcdUQ4MzVcXFxcdURDQTInOidHc2NyJywnXFxcXHVEODM1XFxcXHVERDNFJzonR29wZicsJ1xcXFx1RDgzNVxcXFx1REQwQSc6J0dmcicsJ1xcXFx1MDFGNSc6J2dhY3V0ZScsJ1xcXFx1MDExRic6J2dicmV2ZScsJ1xcXFx1MDExRSc6J0dicmV2ZScsJ1xcXFx1MDExRCc6J2djaXJjJywnXFxcXHUwMTFDJzonR2NpcmMnLCdcXFxcdTAxMjEnOidnZG90JywnXFxcXHUwMTIwJzonR2RvdCcsJ1xcXFx1MDEyMic6J0djZWRpbCcsJ1xcXFx1RDgzNVxcXFx1REQyNSc6J2hmcicsJ1xcXFx1MjEwRSc6J3BsYW5ja2gnLCdcXFxcdUQ4MzVcXFxcdURDQkQnOidoc2NyJywnXFxcXHVEODM1XFxcXHVERDU5JzonaG9wZicsJ1xcXFx1MjEwQic6J0hzY3InLCdcXFxcdTIxMEMnOidIZnInLCdcXFxcdTIxMEQnOidIb3BmJywnXFxcXHUwMTI1JzonaGNpcmMnLCdcXFxcdTAxMjQnOidIY2lyYycsJ1xcXFx1MjEwRic6J2hiYXInLCdcXFxcdTAxMjcnOidoc3Ryb2snLCdcXFxcdTAxMjYnOidIc3Ryb2snLCdcXFxcdUQ4MzVcXFxcdURENUEnOidpb3BmJywnXFxcXHVEODM1XFxcXHVERDI2JzonaWZyJywnXFxcXHVEODM1XFxcXHVEQ0JFJzonaXNjcicsJ1xcXFx1MjE0OCc6J2lpJywnXFxcXHVEODM1XFxcXHVERDQwJzonSW9wZicsJ1xcXFx1MjExMCc6J0lzY3InLCdcXFxcdTIxMTEnOidJbScsJ1xcXFx4RUQnOidpYWN1dGUnLCdcXFxceENEJzonSWFjdXRlJywnXFxcXHhFQyc6J2lncmF2ZScsJ1xcXFx4Q0MnOidJZ3JhdmUnLCdcXFxceEVFJzonaWNpcmMnLCdcXFxceENFJzonSWNpcmMnLCdcXFxceEVGJzonaXVtbCcsJ1xcXFx4Q0YnOidJdW1sJywnXFxcXHUwMTI5JzonaXRpbGRlJywnXFxcXHUwMTI4JzonSXRpbGRlJywnXFxcXHUwMTMwJzonSWRvdCcsJ1xcXFx1MDEyRic6J2lvZ29uJywnXFxcXHUwMTJFJzonSW9nb24nLCdcXFxcdTAxMkInOidpbWFjcicsJ1xcXFx1MDEyQSc6J0ltYWNyJywnXFxcXHUwMTMzJzonaWpsaWcnLCdcXFxcdTAxMzInOidJSmxpZycsJ1xcXFx1MDEzMSc6J2ltYXRoJywnXFxcXHVEODM1XFxcXHVEQ0JGJzonanNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1Qic6J2pvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMjcnOidqZnInLCdcXFxcdUQ4MzVcXFxcdURDQTUnOidKc2NyJywnXFxcXHVEODM1XFxcXHVERDBEJzonSmZyJywnXFxcXHVEODM1XFxcXHVERDQxJzonSm9wZicsJ1xcXFx1MDEzNSc6J2pjaXJjJywnXFxcXHUwMTM0JzonSmNpcmMnLCdcXFxcdTAyMzcnOidqbWF0aCcsJ1xcXFx1RDgzNVxcXFx1REQ1Qyc6J2tvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzAnOidrc2NyJywnXFxcXHVEODM1XFxcXHVERDI4Jzona2ZyJywnXFxcXHVEODM1XFxcXHVEQ0E2JzonS3NjcicsJ1xcXFx1RDgzNVxcXFx1REQ0Mic6J0tvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMEUnOidLZnInLCdcXFxcdTAxMzcnOidrY2VkaWwnLCdcXFxcdTAxMzYnOidLY2VkaWwnLCdcXFxcdUQ4MzVcXFxcdUREMjknOidsZnInLCdcXFxcdUQ4MzVcXFxcdURDQzEnOidsc2NyJywnXFxcXHUyMTEzJzonZWxsJywnXFxcXHVEODM1XFxcXHVERDVEJzonbG9wZicsJ1xcXFx1MjExMic6J0xzY3InLCdcXFxcdUQ4MzVcXFxcdUREMEYnOidMZnInLCdcXFxcdUQ4MzVcXFxcdURENDMnOidMb3BmJywnXFxcXHUwMTNBJzonbGFjdXRlJywnXFxcXHUwMTM5JzonTGFjdXRlJywnXFxcXHUwMTNFJzonbGNhcm9uJywnXFxcXHUwMTNEJzonTGNhcm9uJywnXFxcXHUwMTNDJzonbGNlZGlsJywnXFxcXHUwMTNCJzonTGNlZGlsJywnXFxcXHUwMTQyJzonbHN0cm9rJywnXFxcXHUwMTQxJzonTHN0cm9rJywnXFxcXHUwMTQwJzonbG1pZG90JywnXFxcXHUwMTNGJzonTG1pZG90JywnXFxcXHVEODM1XFxcXHVERDJBJzonbWZyJywnXFxcXHVEODM1XFxcXHVERDVFJzonbW9wZicsJ1xcXFx1RDgzNVxcXFx1RENDMic6J21zY3InLCdcXFxcdUQ4MzVcXFxcdUREMTAnOidNZnInLCdcXFxcdUQ4MzVcXFxcdURENDQnOidNb3BmJywnXFxcXHUyMTMzJzonTXNjcicsJ1xcXFx1RDgzNVxcXFx1REQyQic6J25mcicsJ1xcXFx1RDgzNVxcXFx1REQ1Ric6J25vcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzMnOiduc2NyJywnXFxcXHUyMTE1JzonTm9wZicsJ1xcXFx1RDgzNVxcXFx1RENBOSc6J05zY3InLCdcXFxcdUQ4MzVcXFxcdUREMTEnOidOZnInLCdcXFxcdTAxNDQnOiduYWN1dGUnLCdcXFxcdTAxNDMnOidOYWN1dGUnLCdcXFxcdTAxNDgnOiduY2Fyb24nLCdcXFxcdTAxNDcnOidOY2Fyb24nLCdcXFxceEYxJzonbnRpbGRlJywnXFxcXHhEMSc6J050aWxkZScsJ1xcXFx1MDE0Nic6J25jZWRpbCcsJ1xcXFx1MDE0NSc6J05jZWRpbCcsJ1xcXFx1MjExNic6J251bWVybycsJ1xcXFx1MDE0Qic6J2VuZycsJ1xcXFx1MDE0QSc6J0VORycsJ1xcXFx1RDgzNVxcXFx1REQ2MCc6J29vcGYnLCdcXFxcdUQ4MzVcXFxcdUREMkMnOidvZnInLCdcXFxcdTIxMzQnOidvc2NyJywnXFxcXHVEODM1XFxcXHVEQ0FBJzonT3NjcicsJ1xcXFx1RDgzNVxcXFx1REQxMic6J09mcicsJ1xcXFx1RDgzNVxcXFx1REQ0Nic6J09vcGYnLCdcXFxceEJBJzonb3JkbScsJ1xcXFx4RjMnOidvYWN1dGUnLCdcXFxceEQzJzonT2FjdXRlJywnXFxcXHhGMic6J29ncmF2ZScsJ1xcXFx4RDInOidPZ3JhdmUnLCdcXFxceEY0Jzonb2NpcmMnLCdcXFxceEQ0JzonT2NpcmMnLCdcXFxceEY2Jzonb3VtbCcsJ1xcXFx4RDYnOidPdW1sJywnXFxcXHUwMTUxJzonb2RibGFjJywnXFxcXHUwMTUwJzonT2RibGFjJywnXFxcXHhGNSc6J290aWxkZScsJ1xcXFx4RDUnOidPdGlsZGUnLCdcXFxceEY4Jzonb3NsYXNoJywnXFxcXHhEOCc6J09zbGFzaCcsJ1xcXFx1MDE0RCc6J29tYWNyJywnXFxcXHUwMTRDJzonT21hY3InLCdcXFxcdTAxNTMnOidvZWxpZycsJ1xcXFx1MDE1Mic6J09FbGlnJywnXFxcXHVEODM1XFxcXHVERDJEJzoncGZyJywnXFxcXHVEODM1XFxcXHVEQ0M1JzoncHNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2MSc6J3BvcGYnLCdcXFxcdTIxMTknOidQb3BmJywnXFxcXHVEODM1XFxcXHVERDEzJzonUGZyJywnXFxcXHVEODM1XFxcXHVEQ0FCJzonUHNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2Mic6J3FvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMkUnOidxZnInLCdcXFxcdUQ4MzVcXFxcdURDQzYnOidxc2NyJywnXFxcXHVEODM1XFxcXHVEQ0FDJzonUXNjcicsJ1xcXFx1RDgzNVxcXFx1REQxNCc6J1FmcicsJ1xcXFx1MjExQSc6J1FvcGYnLCdcXFxcdTAxMzgnOidrZ3JlZW4nLCdcXFxcdUQ4MzVcXFxcdUREMkYnOidyZnInLCdcXFxcdUQ4MzVcXFxcdURENjMnOidyb3BmJywnXFxcXHVEODM1XFxcXHVEQ0M3JzoncnNjcicsJ1xcXFx1MjExQic6J1JzY3InLCdcXFxcdTIxMUMnOidSZScsJ1xcXFx1MjExRCc6J1JvcGYnLCdcXFxcdTAxNTUnOidyYWN1dGUnLCdcXFxcdTAxNTQnOidSYWN1dGUnLCdcXFxcdTAxNTknOidyY2Fyb24nLCdcXFxcdTAxNTgnOidSY2Fyb24nLCdcXFxcdTAxNTcnOidyY2VkaWwnLCdcXFxcdTAxNTYnOidSY2VkaWwnLCdcXFxcdUQ4MzVcXFxcdURENjQnOidzb3BmJywnXFxcXHVEODM1XFxcXHVEQ0M4Jzonc3NjcicsJ1xcXFx1RDgzNVxcXFx1REQzMCc6J3NmcicsJ1xcXFx1RDgzNVxcXFx1REQ0QSc6J1NvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMTYnOidTZnInLCdcXFxcdUQ4MzVcXFxcdURDQUUnOidTc2NyJywnXFxcXHUyNEM4Jzonb1MnLCdcXFxcdTAxNUInOidzYWN1dGUnLCdcXFxcdTAxNUEnOidTYWN1dGUnLCdcXFxcdTAxNUQnOidzY2lyYycsJ1xcXFx1MDE1Qyc6J1NjaXJjJywnXFxcXHUwMTYxJzonc2Nhcm9uJywnXFxcXHUwMTYwJzonU2Nhcm9uJywnXFxcXHUwMTVGJzonc2NlZGlsJywnXFxcXHUwMTVFJzonU2NlZGlsJywnXFxcXHhERic6J3N6bGlnJywnXFxcXHVEODM1XFxcXHVERDMxJzondGZyJywnXFxcXHVEODM1XFxcXHVEQ0M5JzondHNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2NSc6J3RvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQUYnOidUc2NyJywnXFxcXHVEODM1XFxcXHVERDE3JzonVGZyJywnXFxcXHVEODM1XFxcXHVERDRCJzonVG9wZicsJ1xcXFx1MDE2NSc6J3RjYXJvbicsJ1xcXFx1MDE2NCc6J1RjYXJvbicsJ1xcXFx1MDE2Myc6J3RjZWRpbCcsJ1xcXFx1MDE2Mic6J1RjZWRpbCcsJ1xcXFx1MjEyMic6J3RyYWRlJywnXFxcXHUwMTY3JzondHN0cm9rJywnXFxcXHUwMTY2JzonVHN0cm9rJywnXFxcXHVEODM1XFxcXHVEQ0NBJzondXNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2Nic6J3VvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMzInOid1ZnInLCdcXFxcdUQ4MzVcXFxcdURENEMnOidVb3BmJywnXFxcXHVEODM1XFxcXHVERDE4JzonVWZyJywnXFxcXHVEODM1XFxcXHVEQ0IwJzonVXNjcicsJ1xcXFx4RkEnOid1YWN1dGUnLCdcXFxceERBJzonVWFjdXRlJywnXFxcXHhGOSc6J3VncmF2ZScsJ1xcXFx4RDknOidVZ3JhdmUnLCdcXFxcdTAxNkQnOid1YnJldmUnLCdcXFxcdTAxNkMnOidVYnJldmUnLCdcXFxceEZCJzondWNpcmMnLCdcXFxceERCJzonVWNpcmMnLCdcXFxcdTAxNkYnOid1cmluZycsJ1xcXFx1MDE2RSc6J1VyaW5nJywnXFxcXHhGQyc6J3V1bWwnLCdcXFxceERDJzonVXVtbCcsJ1xcXFx1MDE3MSc6J3VkYmxhYycsJ1xcXFx1MDE3MCc6J1VkYmxhYycsJ1xcXFx1MDE2OSc6J3V0aWxkZScsJ1xcXFx1MDE2OCc6J1V0aWxkZScsJ1xcXFx1MDE3Myc6J3VvZ29uJywnXFxcXHUwMTcyJzonVW9nb24nLCdcXFxcdTAxNkInOid1bWFjcicsJ1xcXFx1MDE2QSc6J1VtYWNyJywnXFxcXHVEODM1XFxcXHVERDMzJzondmZyJywnXFxcXHVEODM1XFxcXHVERDY3Jzondm9wZicsJ1xcXFx1RDgzNVxcXFx1RENDQic6J3ZzY3InLCdcXFxcdUQ4MzVcXFxcdUREMTknOidWZnInLCdcXFxcdUQ4MzVcXFxcdURENEQnOidWb3BmJywnXFxcXHVEODM1XFxcXHVEQ0IxJzonVnNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2OCc6J3dvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQ0MnOid3c2NyJywnXFxcXHVEODM1XFxcXHVERDM0Jzond2ZyJywnXFxcXHVEODM1XFxcXHVEQ0IyJzonV3NjcicsJ1xcXFx1RDgzNVxcXFx1REQ0RSc6J1dvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMUEnOidXZnInLCdcXFxcdTAxNzUnOid3Y2lyYycsJ1xcXFx1MDE3NCc6J1djaXJjJywnXFxcXHVEODM1XFxcXHVERDM1JzoneGZyJywnXFxcXHVEODM1XFxcXHVEQ0NEJzoneHNjcicsJ1xcXFx1RDgzNVxcXFx1REQ2OSc6J3hvcGYnLCdcXFxcdUQ4MzVcXFxcdURENEYnOidYb3BmJywnXFxcXHVEODM1XFxcXHVERDFCJzonWGZyJywnXFxcXHVEODM1XFxcXHVEQ0IzJzonWHNjcicsJ1xcXFx1RDgzNVxcXFx1REQzNic6J3lmcicsJ1xcXFx1RDgzNVxcXFx1RENDRSc6J3lzY3InLCdcXFxcdUQ4MzVcXFxcdURENkEnOid5b3BmJywnXFxcXHVEODM1XFxcXHVEQ0I0JzonWXNjcicsJ1xcXFx1RDgzNVxcXFx1REQxQyc6J1lmcicsJ1xcXFx1RDgzNVxcXFx1REQ1MCc6J1lvcGYnLCdcXFxceEZEJzoneWFjdXRlJywnXFxcXHhERCc6J1lhY3V0ZScsJ1xcXFx1MDE3Nyc6J3ljaXJjJywnXFxcXHUwMTc2JzonWWNpcmMnLCdcXFxceEZGJzoneXVtbCcsJ1xcXFx1MDE3OCc6J1l1bWwnLCdcXFxcdUQ4MzVcXFxcdURDQ0YnOid6c2NyJywnXFxcXHVEODM1XFxcXHVERDM3JzonemZyJywnXFxcXHVEODM1XFxcXHVERDZCJzonem9wZicsJ1xcXFx1MjEyOCc6J1pmcicsJ1xcXFx1MjEyNCc6J1pvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQjUnOidac2NyJywnXFxcXHUwMTdBJzonemFjdXRlJywnXFxcXHUwMTc5JzonWmFjdXRlJywnXFxcXHUwMTdFJzonemNhcm9uJywnXFxcXHUwMTdEJzonWmNhcm9uJywnXFxcXHUwMTdDJzonemRvdCcsJ1xcXFx1MDE3Qic6J1pkb3QnLCdcXFxcdTAxQjUnOidpbXBlZCcsJ1xcXFx4RkUnOid0aG9ybicsJ1xcXFx4REUnOidUSE9STicsJ1xcXFx1MDE0OSc6J25hcG9zJywnXFxcXHUwM0IxJzonYWxwaGEnLCdcXFxcdTAzOTEnOidBbHBoYScsJ1xcXFx1MDNCMic6J2JldGEnLCdcXFxcdTAzOTInOidCZXRhJywnXFxcXHUwM0IzJzonZ2FtbWEnLCdcXFxcdTAzOTMnOidHYW1tYScsJ1xcXFx1MDNCNCc6J2RlbHRhJywnXFxcXHUwMzk0JzonRGVsdGEnLCdcXFxcdTAzQjUnOidlcHNpJywnXFxcXHUwM0Y1JzonZXBzaXYnLCdcXFxcdTAzOTUnOidFcHNpbG9uJywnXFxcXHUwM0REJzonZ2FtbWFkJywnXFxcXHUwM0RDJzonR2FtbWFkJywnXFxcXHUwM0I2JzonemV0YScsJ1xcXFx1MDM5Nic6J1pldGEnLCdcXFxcdTAzQjcnOidldGEnLCdcXFxcdTAzOTcnOidFdGEnLCdcXFxcdTAzQjgnOid0aGV0YScsJ1xcXFx1MDNEMSc6J3RoZXRhdicsJ1xcXFx1MDM5OCc6J1RoZXRhJywnXFxcXHUwM0I5JzonaW90YScsJ1xcXFx1MDM5OSc6J0lvdGEnLCdcXFxcdTAzQkEnOidrYXBwYScsJ1xcXFx1MDNGMCc6J2thcHBhdicsJ1xcXFx1MDM5QSc6J0thcHBhJywnXFxcXHUwM0JCJzonbGFtYmRhJywnXFxcXHUwMzlCJzonTGFtYmRhJywnXFxcXHUwM0JDJzonbXUnLCdcXFxceEI1JzonbWljcm8nLCdcXFxcdTAzOUMnOidNdScsJ1xcXFx1MDNCRCc6J251JywnXFxcXHUwMzlEJzonTnUnLCdcXFxcdTAzQkUnOid4aScsJ1xcXFx1MDM5RSc6J1hpJywnXFxcXHUwM0JGJzonb21pY3JvbicsJ1xcXFx1MDM5Ric6J09taWNyb24nLCdcXFxcdTAzQzAnOidwaScsJ1xcXFx1MDNENic6J3BpdicsJ1xcXFx1MDNBMCc6J1BpJywnXFxcXHUwM0MxJzoncmhvJywnXFxcXHUwM0YxJzoncmhvdicsJ1xcXFx1MDNBMSc6J1JobycsJ1xcXFx1MDNDMyc6J3NpZ21hJywnXFxcXHUwM0EzJzonU2lnbWEnLCdcXFxcdTAzQzInOidzaWdtYWYnLCdcXFxcdTAzQzQnOid0YXUnLCdcXFxcdTAzQTQnOidUYXUnLCdcXFxcdTAzQzUnOid1cHNpJywnXFxcXHUwM0E1JzonVXBzaWxvbicsJ1xcXFx1MDNEMic6J1Vwc2knLCdcXFxcdTAzQzYnOidwaGknLCdcXFxcdTAzRDUnOidwaGl2JywnXFxcXHUwM0E2JzonUGhpJywnXFxcXHUwM0M3JzonY2hpJywnXFxcXHUwM0E3JzonQ2hpJywnXFxcXHUwM0M4JzoncHNpJywnXFxcXHUwM0E4JzonUHNpJywnXFxcXHUwM0M5Jzonb21lZ2EnLCdcXFxcdTAzQTknOidvaG0nLCdcXFxcdTA0MzAnOidhY3knLCdcXFxcdTA0MTAnOidBY3knLCdcXFxcdTA0MzEnOidiY3knLCdcXFxcdTA0MTEnOidCY3knLCdcXFxcdTA0MzInOid2Y3knLCdcXFxcdTA0MTInOidWY3knLCdcXFxcdTA0MzMnOidnY3knLCdcXFxcdTA0MTMnOidHY3knLCdcXFxcdTA0NTMnOidnamN5JywnXFxcXHUwNDAzJzonR0pjeScsJ1xcXFx1MDQzNCc6J2RjeScsJ1xcXFx1MDQxNCc6J0RjeScsJ1xcXFx1MDQ1Mic6J2RqY3knLCdcXFxcdTA0MDInOidESmN5JywnXFxcXHUwNDM1JzonaWVjeScsJ1xcXFx1MDQxNSc6J0lFY3knLCdcXFxcdTA0NTEnOidpb2N5JywnXFxcXHUwNDAxJzonSU9jeScsJ1xcXFx1MDQ1NCc6J2p1a2N5JywnXFxcXHUwNDA0JzonSnVrY3knLCdcXFxcdTA0MzYnOid6aGN5JywnXFxcXHUwNDE2JzonWkhjeScsJ1xcXFx1MDQzNyc6J3pjeScsJ1xcXFx1MDQxNyc6J1pjeScsJ1xcXFx1MDQ1NSc6J2RzY3knLCdcXFxcdTA0MDUnOidEU2N5JywnXFxcXHUwNDM4JzonaWN5JywnXFxcXHUwNDE4JzonSWN5JywnXFxcXHUwNDU2JzonaXVrY3knLCdcXFxcdTA0MDYnOidJdWtjeScsJ1xcXFx1MDQ1Nyc6J3lpY3knLCdcXFxcdTA0MDcnOidZSWN5JywnXFxcXHUwNDM5JzonamN5JywnXFxcXHUwNDE5JzonSmN5JywnXFxcXHUwNDU4JzonanNlcmN5JywnXFxcXHUwNDA4JzonSnNlcmN5JywnXFxcXHUwNDNBJzona2N5JywnXFxcXHUwNDFBJzonS2N5JywnXFxcXHUwNDVDJzona2pjeScsJ1xcXFx1MDQwQyc6J0tKY3knLCdcXFxcdTA0M0InOidsY3knLCdcXFxcdTA0MUInOidMY3knLCdcXFxcdTA0NTknOidsamN5JywnXFxcXHUwNDA5JzonTEpjeScsJ1xcXFx1MDQzQyc6J21jeScsJ1xcXFx1MDQxQyc6J01jeScsJ1xcXFx1MDQzRCc6J25jeScsJ1xcXFx1MDQxRCc6J05jeScsJ1xcXFx1MDQ1QSc6J25qY3knLCdcXFxcdTA0MEEnOidOSmN5JywnXFxcXHUwNDNFJzonb2N5JywnXFxcXHUwNDFFJzonT2N5JywnXFxcXHUwNDNGJzoncGN5JywnXFxcXHUwNDFGJzonUGN5JywnXFxcXHUwNDQwJzoncmN5JywnXFxcXHUwNDIwJzonUmN5JywnXFxcXHUwNDQxJzonc2N5JywnXFxcXHUwNDIxJzonU2N5JywnXFxcXHUwNDQyJzondGN5JywnXFxcXHUwNDIyJzonVGN5JywnXFxcXHUwNDVCJzondHNoY3knLCdcXFxcdTA0MEInOidUU0hjeScsJ1xcXFx1MDQ0Myc6J3VjeScsJ1xcXFx1MDQyMyc6J1VjeScsJ1xcXFx1MDQ1RSc6J3VicmN5JywnXFxcXHUwNDBFJzonVWJyY3knLCdcXFxcdTA0NDQnOidmY3knLCdcXFxcdTA0MjQnOidGY3knLCdcXFxcdTA0NDUnOidraGN5JywnXFxcXHUwNDI1JzonS0hjeScsJ1xcXFx1MDQ0Nic6J3RzY3knLCdcXFxcdTA0MjYnOidUU2N5JywnXFxcXHUwNDQ3JzonY2hjeScsJ1xcXFx1MDQyNyc6J0NIY3knLCdcXFxcdTA0NUYnOidkemN5JywnXFxcXHUwNDBGJzonRFpjeScsJ1xcXFx1MDQ0OCc6J3NoY3knLCdcXFxcdTA0MjgnOidTSGN5JywnXFxcXHUwNDQ5Jzonc2hjaGN5JywnXFxcXHUwNDI5JzonU0hDSGN5JywnXFxcXHUwNDRBJzonaGFyZGN5JywnXFxcXHUwNDJBJzonSEFSRGN5JywnXFxcXHUwNDRCJzoneWN5JywnXFxcXHUwNDJCJzonWWN5JywnXFxcXHUwNDRDJzonc29mdGN5JywnXFxcXHUwNDJDJzonU09GVGN5JywnXFxcXHUwNDREJzonZWN5JywnXFxcXHUwNDJEJzonRWN5JywnXFxcXHUwNDRFJzoneXVjeScsJ1xcXFx1MDQyRSc6J1lVY3knLCdcXFxcdTA0NEYnOid5YWN5JywnXFxcXHUwNDJGJzonWUFjeScsJ1xcXFx1MjEzNSc6J2FsZXBoJywnXFxcXHUyMTM2JzonYmV0aCcsJ1xcXFx1MjEzNyc6J2dpbWVsJywnXFxcXHUyMTM4JzonZGFsZXRoJ307XFxuXFxuXFx0dmFyIHJlZ2V4RXNjYXBlID0gL1tcXFwiJic8PmBdL2c7XFxuXFx0dmFyIGVzY2FwZU1hcCA9IHtcXG5cXHRcXHQnXFxcIic6ICcmcXVvdDsnLFxcblxcdFxcdCcmJzogJyZhbXA7JyxcXG5cXHRcXHQnXFxcXCcnOiAnJiN4Mjc7JyxcXG5cXHRcXHQnPCc6ICcmbHQ7JyxcXG5cXHRcXHQvLyBTZWUgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzOiBpbiBIVE1MLCB0aGVcXG5cXHRcXHQvLyBmb2xsb3dpbmcgaXMgbm90IHN0cmljdGx5IG5lY2Vzc2FyeSB1bmxlc3MgaXTigJlzIHBhcnQgb2YgYSB0YWcgb3IgYW5cXG5cXHRcXHQvLyB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFdl4oCZcmUgb25seSBlc2NhcGluZyBpdCB0byBzdXBwb3J0IHRob3NlXFxuXFx0XFx0Ly8gc2l0dWF0aW9ucywgYW5kIGZvciBYTUwgc3VwcG9ydC5cXG5cXHRcXHQnPic6ICcmZ3Q7JyxcXG5cXHRcXHQvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciDiiaQgOCwgdGhlIGJhY2t0aWNrIGNoYXJhY3RlciBjYW4gYmUgdXNlZFxcblxcdFxcdC8vIHRvIGJyZWFrIG91dCBvZiAodW4pcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZXMgb3IgSFRNTCBjb21tZW50cy5cXG5cXHRcXHQvLyBTZWUgaHR0cDovL2h0bWw1c2VjLm9yZy8jMTAyLCBodHRwOi8vaHRtbDVzZWMub3JnLyMxMDgsIGFuZFxcblxcdFxcdC8vIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEzMy5cXG5cXHRcXHQnYCc6ICcmI3g2MDsnXFxuXFx0fTtcXG5cXG5cXHR2YXIgcmVnZXhJbnZhbGlkRW50aXR5ID0gLyYjKD86W3hYXVteYS1mQS1GMC05XXxbXjAtOXhYXSkvO1xcblxcdHZhciByZWdleEludmFsaWRSYXdDb2RlUG9pbnQgPSAvW1xcXFwwLVxcXFx4MDhcXFxceDBCXFxcXHgwRS1cXFxceDFGXFxcXHg3Ri1cXFxceDlGXFxcXHVGREQwLVxcXFx1RkRFRlxcXFx1RkZGRVxcXFx1RkZGRl18W1xcXFx1RDgzRlxcXFx1RDg3RlxcXFx1RDhCRlxcXFx1RDhGRlxcXFx1RDkzRlxcXFx1RDk3RlxcXFx1RDlCRlxcXFx1RDlGRlxcXFx1REEzRlxcXFx1REE3RlxcXFx1REFCRlxcXFx1REFGRlxcXFx1REIzRlxcXFx1REI3RlxcXFx1REJCRlxcXFx1REJGRl1bXFxcXHVERkZFXFxcXHVERkZGXXxbXFxcXHVEODAwLVxcXFx1REJGRl0oPyFbXFxcXHVEQzAwLVxcXFx1REZGRl0pfCg/OlteXFxcXHVEODAwLVxcXFx1REJGRl18XilbXFxcXHVEQzAwLVxcXFx1REZGRl0vO1xcblxcdHZhciByZWdleERlY29kZSA9IC8mIyhbMC05XSspKDs/KXwmI1t4WF0oW2EtZkEtRjAtOV0rKSg7Pyl8JihbMC05YS16QS1aXSspO3wmKEFhY3V0ZXxBZ3JhdmV8QXRpbGRlfENjZWRpbHxFYWN1dGV8RWdyYXZlfElhY3V0ZXxJZ3JhdmV8TnRpbGRlfE9hY3V0ZXxPZ3JhdmV8T3NsYXNofE90aWxkZXxVYWN1dGV8VWdyYXZlfFlhY3V0ZXxhYWN1dGV8YWdyYXZlfGF0aWxkZXxicnZiYXJ8Y2NlZGlsfGN1cnJlbnxkaXZpZGV8ZWFjdXRlfGVncmF2ZXxmcmFjMTJ8ZnJhYzE0fGZyYWMzNHxpYWN1dGV8aWdyYXZlfGlxdWVzdHxtaWRkb3R8bnRpbGRlfG9hY3V0ZXxvZ3JhdmV8b3NsYXNofG90aWxkZXxwbHVzbW58dWFjdXRlfHVncmF2ZXx5YWN1dGV8QUVsaWd8QWNpcmN8QXJpbmd8RWNpcmN8SWNpcmN8T2NpcmN8VEhPUk58VWNpcmN8YWNpcmN8YWN1dGV8YWVsaWd8YXJpbmd8Y2VkaWx8ZWNpcmN8aWNpcmN8aWV4Y2x8bGFxdW98bWljcm98b2NpcmN8cG91bmR8cmFxdW98c3psaWd8dGhvcm58dGltZXN8dWNpcmN8QXVtbHxDT1BZfEV1bWx8SXVtbHxPdW1sfFFVT1R8VXVtbHxhdW1sfGNlbnR8Y29weXxldW1sfGl1bWx8bWFjcnxuYnNwfG9yZGZ8b3JkbXxvdW1sfHBhcmF8cXVvdHxzZWN0fHN1cDF8c3VwMnxzdXAzfHV1bWx8eXVtbHxBTVB8RVRIfFJFR3xhbXB8ZGVnfGV0aHxub3R8cmVnfHNoeXx1bWx8eWVufEdUfExUfGd0fGx0KShbPWEtekEtWjAtOV0pPy9nO1xcblxcdHZhciBkZWNvZGVNYXAgPSB7J2FhY3V0ZSc6J1xcXFx4RTEnLCdBYWN1dGUnOidcXFxceEMxJywnYWJyZXZlJzonXFxcXHUwMTAzJywnQWJyZXZlJzonXFxcXHUwMTAyJywnYWMnOidcXFxcdTIyM0UnLCdhY2QnOidcXFxcdTIyM0YnLCdhY0UnOidcXFxcdTIyM0VcXFxcdTAzMzMnLCdhY2lyYyc6J1xcXFx4RTInLCdBY2lyYyc6J1xcXFx4QzInLCdhY3V0ZSc6J1xcXFx4QjQnLCdhY3knOidcXFxcdTA0MzAnLCdBY3knOidcXFxcdTA0MTAnLCdhZWxpZyc6J1xcXFx4RTYnLCdBRWxpZyc6J1xcXFx4QzYnLCdhZic6J1xcXFx1MjA2MScsJ2Fmcic6J1xcXFx1RDgzNVxcXFx1REQxRScsJ0Fmcic6J1xcXFx1RDgzNVxcXFx1REQwNCcsJ2FncmF2ZSc6J1xcXFx4RTAnLCdBZ3JhdmUnOidcXFxceEMwJywnYWxlZnN5bSc6J1xcXFx1MjEzNScsJ2FsZXBoJzonXFxcXHUyMTM1JywnYWxwaGEnOidcXFxcdTAzQjEnLCdBbHBoYSc6J1xcXFx1MDM5MScsJ2FtYWNyJzonXFxcXHUwMTAxJywnQW1hY3InOidcXFxcdTAxMDAnLCdhbWFsZyc6J1xcXFx1MkEzRicsJ2FtcCc6JyYnLCdBTVAnOicmJywnYW5kJzonXFxcXHUyMjI3JywnQW5kJzonXFxcXHUyQTUzJywnYW5kYW5kJzonXFxcXHUyQTU1JywnYW5kZCc6J1xcXFx1MkE1QycsJ2FuZHNsb3BlJzonXFxcXHUyQTU4JywnYW5kdic6J1xcXFx1MkE1QScsJ2FuZyc6J1xcXFx1MjIyMCcsJ2FuZ2UnOidcXFxcdTI5QTQnLCdhbmdsZSc6J1xcXFx1MjIyMCcsJ2FuZ21zZCc6J1xcXFx1MjIyMScsJ2FuZ21zZGFhJzonXFxcXHUyOUE4JywnYW5nbXNkYWInOidcXFxcdTI5QTknLCdhbmdtc2RhYyc6J1xcXFx1MjlBQScsJ2FuZ21zZGFkJzonXFxcXHUyOUFCJywnYW5nbXNkYWUnOidcXFxcdTI5QUMnLCdhbmdtc2RhZic6J1xcXFx1MjlBRCcsJ2FuZ21zZGFnJzonXFxcXHUyOUFFJywnYW5nbXNkYWgnOidcXFxcdTI5QUYnLCdhbmdydCc6J1xcXFx1MjIxRicsJ2FuZ3J0dmInOidcXFxcdTIyQkUnLCdhbmdydHZiZCc6J1xcXFx1Mjk5RCcsJ2FuZ3NwaCc6J1xcXFx1MjIyMicsJ2FuZ3N0JzonXFxcXHhDNScsJ2FuZ3phcnInOidcXFxcdTIzN0MnLCdhb2dvbic6J1xcXFx1MDEwNScsJ0FvZ29uJzonXFxcXHUwMTA0JywnYW9wZic6J1xcXFx1RDgzNVxcXFx1REQ1MicsJ0FvcGYnOidcXFxcdUQ4MzVcXFxcdUREMzgnLCdhcCc6J1xcXFx1MjI0OCcsJ2FwYWNpcic6J1xcXFx1MkE2RicsJ2FwZSc6J1xcXFx1MjI0QScsJ2FwRSc6J1xcXFx1MkE3MCcsJ2FwaWQnOidcXFxcdTIyNEInLCdhcG9zJzonXFxcXCcnLCdBcHBseUZ1bmN0aW9uJzonXFxcXHUyMDYxJywnYXBwcm94JzonXFxcXHUyMjQ4JywnYXBwcm94ZXEnOidcXFxcdTIyNEEnLCdhcmluZyc6J1xcXFx4RTUnLCdBcmluZyc6J1xcXFx4QzUnLCdhc2NyJzonXFxcXHVEODM1XFxcXHVEQ0I2JywnQXNjcic6J1xcXFx1RDgzNVxcXFx1REM5QycsJ0Fzc2lnbic6J1xcXFx1MjI1NCcsJ2FzdCc6JyonLCdhc3ltcCc6J1xcXFx1MjI0OCcsJ2FzeW1wZXEnOidcXFxcdTIyNEQnLCdhdGlsZGUnOidcXFxceEUzJywnQXRpbGRlJzonXFxcXHhDMycsJ2F1bWwnOidcXFxceEU0JywnQXVtbCc6J1xcXFx4QzQnLCdhd2NvbmludCc6J1xcXFx1MjIzMycsJ2F3aW50JzonXFxcXHUyQTExJywnYmFja2NvbmcnOidcXFxcdTIyNEMnLCdiYWNrZXBzaWxvbic6J1xcXFx1MDNGNicsJ2JhY2twcmltZSc6J1xcXFx1MjAzNScsJ2JhY2tzaW0nOidcXFxcdTIyM0QnLCdiYWNrc2ltZXEnOidcXFxcdTIyQ0QnLCdCYWNrc2xhc2gnOidcXFxcdTIyMTYnLCdCYXJ2JzonXFxcXHUyQUU3JywnYmFydmVlJzonXFxcXHUyMkJEJywnYmFyd2VkJzonXFxcXHUyMzA1JywnQmFyd2VkJzonXFxcXHUyMzA2JywnYmFyd2VkZ2UnOidcXFxcdTIzMDUnLCdiYnJrJzonXFxcXHUyM0I1JywnYmJya3RicmsnOidcXFxcdTIzQjYnLCdiY29uZyc6J1xcXFx1MjI0QycsJ2JjeSc6J1xcXFx1MDQzMScsJ0JjeSc6J1xcXFx1MDQxMScsJ2JkcXVvJzonXFxcXHUyMDFFJywnYmVjYXVzJzonXFxcXHUyMjM1JywnYmVjYXVzZSc6J1xcXFx1MjIzNScsJ0JlY2F1c2UnOidcXFxcdTIyMzUnLCdiZW1wdHl2JzonXFxcXHUyOUIwJywnYmVwc2knOidcXFxcdTAzRjYnLCdiZXJub3UnOidcXFxcdTIxMkMnLCdCZXJub3VsbGlzJzonXFxcXHUyMTJDJywnYmV0YSc6J1xcXFx1MDNCMicsJ0JldGEnOidcXFxcdTAzOTInLCdiZXRoJzonXFxcXHUyMTM2JywnYmV0d2Vlbic6J1xcXFx1MjI2QycsJ2Jmcic6J1xcXFx1RDgzNVxcXFx1REQxRicsJ0Jmcic6J1xcXFx1RDgzNVxcXFx1REQwNScsJ2JpZ2NhcCc6J1xcXFx1MjJDMicsJ2JpZ2NpcmMnOidcXFxcdTI1RUYnLCdiaWdjdXAnOidcXFxcdTIyQzMnLCdiaWdvZG90JzonXFxcXHUyQTAwJywnYmlnb3BsdXMnOidcXFxcdTJBMDEnLCdiaWdvdGltZXMnOidcXFxcdTJBMDInLCdiaWdzcWN1cCc6J1xcXFx1MkEwNicsJ2JpZ3N0YXInOidcXFxcdTI2MDUnLCdiaWd0cmlhbmdsZWRvd24nOidcXFxcdTI1QkQnLCdiaWd0cmlhbmdsZXVwJzonXFxcXHUyNUIzJywnYmlndXBsdXMnOidcXFxcdTJBMDQnLCdiaWd2ZWUnOidcXFxcdTIyQzEnLCdiaWd3ZWRnZSc6J1xcXFx1MjJDMCcsJ2JrYXJvdyc6J1xcXFx1MjkwRCcsJ2JsYWNrbG96ZW5nZSc6J1xcXFx1MjlFQicsJ2JsYWNrc3F1YXJlJzonXFxcXHUyNUFBJywnYmxhY2t0cmlhbmdsZSc6J1xcXFx1MjVCNCcsJ2JsYWNrdHJpYW5nbGVkb3duJzonXFxcXHUyNUJFJywnYmxhY2t0cmlhbmdsZWxlZnQnOidcXFxcdTI1QzInLCdibGFja3RyaWFuZ2xlcmlnaHQnOidcXFxcdTI1QjgnLCdibGFuayc6J1xcXFx1MjQyMycsJ2JsazEyJzonXFxcXHUyNTkyJywnYmxrMTQnOidcXFxcdTI1OTEnLCdibGszNCc6J1xcXFx1MjU5MycsJ2Jsb2NrJzonXFxcXHUyNTg4JywnYm5lJzonPVxcXFx1MjBFNScsJ2JuZXF1aXYnOidcXFxcdTIyNjFcXFxcdTIwRTUnLCdibm90JzonXFxcXHUyMzEwJywnYk5vdCc6J1xcXFx1MkFFRCcsJ2JvcGYnOidcXFxcdUQ4MzVcXFxcdURENTMnLCdCb3BmJzonXFxcXHVEODM1XFxcXHVERDM5JywnYm90JzonXFxcXHUyMkE1JywnYm90dG9tJzonXFxcXHUyMkE1JywnYm93dGllJzonXFxcXHUyMkM4JywnYm94Ym94JzonXFxcXHUyOUM5JywnYm94ZGwnOidcXFxcdTI1MTAnLCdib3hkTCc6J1xcXFx1MjU1NScsJ2JveERsJzonXFxcXHUyNTU2JywnYm94REwnOidcXFxcdTI1NTcnLCdib3hkcic6J1xcXFx1MjUwQycsJ2JveGRSJzonXFxcXHUyNTUyJywnYm94RHInOidcXFxcdTI1NTMnLCdib3hEUic6J1xcXFx1MjU1NCcsJ2JveGgnOidcXFxcdTI1MDAnLCdib3hIJzonXFxcXHUyNTUwJywnYm94aGQnOidcXFxcdTI1MkMnLCdib3hoRCc6J1xcXFx1MjU2NScsJ2JveEhkJzonXFxcXHUyNTY0JywnYm94SEQnOidcXFxcdTI1NjYnLCdib3hodSc6J1xcXFx1MjUzNCcsJ2JveGhVJzonXFxcXHUyNTY4JywnYm94SHUnOidcXFxcdTI1NjcnLCdib3hIVSc6J1xcXFx1MjU2OScsJ2JveG1pbnVzJzonXFxcXHUyMjlGJywnYm94cGx1cyc6J1xcXFx1MjI5RScsJ2JveHRpbWVzJzonXFxcXHUyMkEwJywnYm94dWwnOidcXFxcdTI1MTgnLCdib3h1TCc6J1xcXFx1MjU1QicsJ2JveFVsJzonXFxcXHUyNTVDJywnYm94VUwnOidcXFxcdTI1NUQnLCdib3h1cic6J1xcXFx1MjUxNCcsJ2JveHVSJzonXFxcXHUyNTU4JywnYm94VXInOidcXFxcdTI1NTknLCdib3hVUic6J1xcXFx1MjU1QScsJ2JveHYnOidcXFxcdTI1MDInLCdib3hWJzonXFxcXHUyNTUxJywnYm94dmgnOidcXFxcdTI1M0MnLCdib3h2SCc6J1xcXFx1MjU2QScsJ2JveFZoJzonXFxcXHUyNTZCJywnYm94VkgnOidcXFxcdTI1NkMnLCdib3h2bCc6J1xcXFx1MjUyNCcsJ2JveHZMJzonXFxcXHUyNTYxJywnYm94VmwnOidcXFxcdTI1NjInLCdib3hWTCc6J1xcXFx1MjU2MycsJ2JveHZyJzonXFxcXHUyNTFDJywnYm94dlInOidcXFxcdTI1NUUnLCdib3hWcic6J1xcXFx1MjU1RicsJ2JveFZSJzonXFxcXHUyNTYwJywnYnByaW1lJzonXFxcXHUyMDM1JywnYnJldmUnOidcXFxcdTAyRDgnLCdCcmV2ZSc6J1xcXFx1MDJEOCcsJ2JydmJhcic6J1xcXFx4QTYnLCdic2NyJzonXFxcXHVEODM1XFxcXHVEQ0I3JywnQnNjcic6J1xcXFx1MjEyQycsJ2JzZW1pJzonXFxcXHUyMDRGJywnYnNpbSc6J1xcXFx1MjIzRCcsJ2JzaW1lJzonXFxcXHUyMkNEJywnYnNvbCc6J1xcXFxcXFxcJywnYnNvbGInOidcXFxcdTI5QzUnLCdic29saHN1Yic6J1xcXFx1MjdDOCcsJ2J1bGwnOidcXFxcdTIwMjInLCdidWxsZXQnOidcXFxcdTIwMjInLCdidW1wJzonXFxcXHUyMjRFJywnYnVtcGUnOidcXFxcdTIyNEYnLCdidW1wRSc6J1xcXFx1MkFBRScsJ2J1bXBlcSc6J1xcXFx1MjI0RicsJ0J1bXBlcSc6J1xcXFx1MjI0RScsJ2NhY3V0ZSc6J1xcXFx1MDEwNycsJ0NhY3V0ZSc6J1xcXFx1MDEwNicsJ2NhcCc6J1xcXFx1MjIyOScsJ0NhcCc6J1xcXFx1MjJEMicsJ2NhcGFuZCc6J1xcXFx1MkE0NCcsJ2NhcGJyY3VwJzonXFxcXHUyQTQ5JywnY2FwY2FwJzonXFxcXHUyQTRCJywnY2FwY3VwJzonXFxcXHUyQTQ3JywnY2FwZG90JzonXFxcXHUyQTQwJywnQ2FwaXRhbERpZmZlcmVudGlhbEQnOidcXFxcdTIxNDUnLCdjYXBzJzonXFxcXHUyMjI5XFxcXHVGRTAwJywnY2FyZXQnOidcXFxcdTIwNDEnLCdjYXJvbic6J1xcXFx1MDJDNycsJ0NheWxleXMnOidcXFxcdTIxMkQnLCdjY2Fwcyc6J1xcXFx1MkE0RCcsJ2NjYXJvbic6J1xcXFx1MDEwRCcsJ0NjYXJvbic6J1xcXFx1MDEwQycsJ2NjZWRpbCc6J1xcXFx4RTcnLCdDY2VkaWwnOidcXFxceEM3JywnY2NpcmMnOidcXFxcdTAxMDknLCdDY2lyYyc6J1xcXFx1MDEwOCcsJ0Njb25pbnQnOidcXFxcdTIyMzAnLCdjY3Vwcyc6J1xcXFx1MkE0QycsJ2NjdXBzc20nOidcXFxcdTJBNTAnLCdjZG90JzonXFxcXHUwMTBCJywnQ2RvdCc6J1xcXFx1MDEwQScsJ2NlZGlsJzonXFxcXHhCOCcsJ0NlZGlsbGEnOidcXFxceEI4JywnY2VtcHR5dic6J1xcXFx1MjlCMicsJ2NlbnQnOidcXFxceEEyJywnY2VudGVyZG90JzonXFxcXHhCNycsJ0NlbnRlckRvdCc6J1xcXFx4QjcnLCdjZnInOidcXFxcdUQ4MzVcXFxcdUREMjAnLCdDZnInOidcXFxcdTIxMkQnLCdjaGN5JzonXFxcXHUwNDQ3JywnQ0hjeSc6J1xcXFx1MDQyNycsJ2NoZWNrJzonXFxcXHUyNzEzJywnY2hlY2ttYXJrJzonXFxcXHUyNzEzJywnY2hpJzonXFxcXHUwM0M3JywnQ2hpJzonXFxcXHUwM0E3JywnY2lyJzonXFxcXHUyNUNCJywnY2lyYyc6J1xcXFx1MDJDNicsJ2NpcmNlcSc6J1xcXFx1MjI1NycsJ2NpcmNsZWFycm93bGVmdCc6J1xcXFx1MjFCQScsJ2NpcmNsZWFycm93cmlnaHQnOidcXFxcdTIxQkInLCdjaXJjbGVkYXN0JzonXFxcXHUyMjlCJywnY2lyY2xlZGNpcmMnOidcXFxcdTIyOUEnLCdjaXJjbGVkZGFzaCc6J1xcXFx1MjI5RCcsJ0NpcmNsZURvdCc6J1xcXFx1MjI5OScsJ2NpcmNsZWRSJzonXFxcXHhBRScsJ2NpcmNsZWRTJzonXFxcXHUyNEM4JywnQ2lyY2xlTWludXMnOidcXFxcdTIyOTYnLCdDaXJjbGVQbHVzJzonXFxcXHUyMjk1JywnQ2lyY2xlVGltZXMnOidcXFxcdTIyOTcnLCdjaXJlJzonXFxcXHUyMjU3JywnY2lyRSc6J1xcXFx1MjlDMycsJ2NpcmZuaW50JzonXFxcXHUyQTEwJywnY2lybWlkJzonXFxcXHUyQUVGJywnY2lyc2Npcic6J1xcXFx1MjlDMicsJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6J1xcXFx1MjIzMicsJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZSc6J1xcXFx1MjAxRCcsJ0Nsb3NlQ3VybHlRdW90ZSc6J1xcXFx1MjAxOScsJ2NsdWJzJzonXFxcXHUyNjYzJywnY2x1YnN1aXQnOidcXFxcdTI2NjMnLCdjb2xvbic6JzonLCdDb2xvbic6J1xcXFx1MjIzNycsJ2NvbG9uZSc6J1xcXFx1MjI1NCcsJ0NvbG9uZSc6J1xcXFx1MkE3NCcsJ2NvbG9uZXEnOidcXFxcdTIyNTQnLCdjb21tYSc6JywnLCdjb21tYXQnOidAJywnY29tcCc6J1xcXFx1MjIwMScsJ2NvbXBmbic6J1xcXFx1MjIxOCcsJ2NvbXBsZW1lbnQnOidcXFxcdTIyMDEnLCdjb21wbGV4ZXMnOidcXFxcdTIxMDInLCdjb25nJzonXFxcXHUyMjQ1JywnY29uZ2RvdCc6J1xcXFx1MkE2RCcsJ0NvbmdydWVudCc6J1xcXFx1MjI2MScsJ2NvbmludCc6J1xcXFx1MjIyRScsJ0NvbmludCc6J1xcXFx1MjIyRicsJ0NvbnRvdXJJbnRlZ3JhbCc6J1xcXFx1MjIyRScsJ2NvcGYnOidcXFxcdUQ4MzVcXFxcdURENTQnLCdDb3BmJzonXFxcXHUyMTAyJywnY29wcm9kJzonXFxcXHUyMjEwJywnQ29wcm9kdWN0JzonXFxcXHUyMjEwJywnY29weSc6J1xcXFx4QTknLCdDT1BZJzonXFxcXHhBOScsJ2NvcHlzcic6J1xcXFx1MjExNycsJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnOidcXFxcdTIyMzMnLCdjcmFycic6J1xcXFx1MjFCNScsJ2Nyb3NzJzonXFxcXHUyNzE3JywnQ3Jvc3MnOidcXFxcdTJBMkYnLCdjc2NyJzonXFxcXHVEODM1XFxcXHVEQ0I4JywnQ3Njcic6J1xcXFx1RDgzNVxcXFx1REM5RScsJ2NzdWInOidcXFxcdTJBQ0YnLCdjc3ViZSc6J1xcXFx1MkFEMScsJ2NzdXAnOidcXFxcdTJBRDAnLCdjc3VwZSc6J1xcXFx1MkFEMicsJ2N0ZG90JzonXFxcXHUyMkVGJywnY3VkYXJybCc6J1xcXFx1MjkzOCcsJ2N1ZGFycnInOidcXFxcdTI5MzUnLCdjdWVwcic6J1xcXFx1MjJERScsJ2N1ZXNjJzonXFxcXHUyMkRGJywnY3VsYXJyJzonXFxcXHUyMUI2JywnY3VsYXJycCc6J1xcXFx1MjkzRCcsJ2N1cCc6J1xcXFx1MjIyQScsJ0N1cCc6J1xcXFx1MjJEMycsJ2N1cGJyY2FwJzonXFxcXHUyQTQ4JywnY3VwY2FwJzonXFxcXHUyQTQ2JywnQ3VwQ2FwJzonXFxcXHUyMjREJywnY3VwY3VwJzonXFxcXHUyQTRBJywnY3VwZG90JzonXFxcXHUyMjhEJywnY3Vwb3InOidcXFxcdTJBNDUnLCdjdXBzJzonXFxcXHUyMjJBXFxcXHVGRTAwJywnY3VyYXJyJzonXFxcXHUyMUI3JywnY3VyYXJybSc6J1xcXFx1MjkzQycsJ2N1cmx5ZXFwcmVjJzonXFxcXHUyMkRFJywnY3VybHllcXN1Y2MnOidcXFxcdTIyREYnLCdjdXJseXZlZSc6J1xcXFx1MjJDRScsJ2N1cmx5d2VkZ2UnOidcXFxcdTIyQ0YnLCdjdXJyZW4nOidcXFxceEE0JywnY3VydmVhcnJvd2xlZnQnOidcXFxcdTIxQjYnLCdjdXJ2ZWFycm93cmlnaHQnOidcXFxcdTIxQjcnLCdjdXZlZSc6J1xcXFx1MjJDRScsJ2N1d2VkJzonXFxcXHUyMkNGJywnY3djb25pbnQnOidcXFxcdTIyMzInLCdjd2ludCc6J1xcXFx1MjIzMScsJ2N5bGN0eSc6J1xcXFx1MjMyRCcsJ2RhZ2dlcic6J1xcXFx1MjAyMCcsJ0RhZ2dlcic6J1xcXFx1MjAyMScsJ2RhbGV0aCc6J1xcXFx1MjEzOCcsJ2RhcnInOidcXFxcdTIxOTMnLCdkQXJyJzonXFxcXHUyMUQzJywnRGFycic6J1xcXFx1MjFBMScsJ2Rhc2gnOidcXFxcdTIwMTAnLCdkYXNodic6J1xcXFx1MjJBMycsJ0Rhc2h2JzonXFxcXHUyQUU0JywnZGJrYXJvdyc6J1xcXFx1MjkwRicsJ2RibGFjJzonXFxcXHUwMkREJywnZGNhcm9uJzonXFxcXHUwMTBGJywnRGNhcm9uJzonXFxcXHUwMTBFJywnZGN5JzonXFxcXHUwNDM0JywnRGN5JzonXFxcXHUwNDE0JywnZGQnOidcXFxcdTIxNDYnLCdERCc6J1xcXFx1MjE0NScsJ2RkYWdnZXInOidcXFxcdTIwMjEnLCdkZGFycic6J1xcXFx1MjFDQScsJ0REb3RyYWhkJzonXFxcXHUyOTExJywnZGRvdHNlcSc6J1xcXFx1MkE3NycsJ2RlZyc6J1xcXFx4QjAnLCdEZWwnOidcXFxcdTIyMDcnLCdkZWx0YSc6J1xcXFx1MDNCNCcsJ0RlbHRhJzonXFxcXHUwMzk0JywnZGVtcHR5dic6J1xcXFx1MjlCMScsJ2RmaXNodCc6J1xcXFx1Mjk3RicsJ2Rmcic6J1xcXFx1RDgzNVxcXFx1REQyMScsJ0Rmcic6J1xcXFx1RDgzNVxcXFx1REQwNycsJ2RIYXInOidcXFxcdTI5NjUnLCdkaGFybCc6J1xcXFx1MjFDMycsJ2RoYXJyJzonXFxcXHUyMUMyJywnRGlhY3JpdGljYWxBY3V0ZSc6J1xcXFx4QjQnLCdEaWFjcml0aWNhbERvdCc6J1xcXFx1MDJEOScsJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnOidcXFxcdTAyREQnLCdEaWFjcml0aWNhbEdyYXZlJzonYCcsJ0RpYWNyaXRpY2FsVGlsZGUnOidcXFxcdTAyREMnLCdkaWFtJzonXFxcXHUyMkM0JywnZGlhbW9uZCc6J1xcXFx1MjJDNCcsJ0RpYW1vbmQnOidcXFxcdTIyQzQnLCdkaWFtb25kc3VpdCc6J1xcXFx1MjY2NicsJ2RpYW1zJzonXFxcXHUyNjY2JywnZGllJzonXFxcXHhBOCcsJ0RpZmZlcmVudGlhbEQnOidcXFxcdTIxNDYnLCdkaWdhbW1hJzonXFxcXHUwM0REJywnZGlzaW4nOidcXFxcdTIyRjInLCdkaXYnOidcXFxceEY3JywnZGl2aWRlJzonXFxcXHhGNycsJ2RpdmlkZW9udGltZXMnOidcXFxcdTIyQzcnLCdkaXZvbngnOidcXFxcdTIyQzcnLCdkamN5JzonXFxcXHUwNDUyJywnREpjeSc6J1xcXFx1MDQwMicsJ2RsY29ybic6J1xcXFx1MjMxRScsJ2RsY3JvcCc6J1xcXFx1MjMwRCcsJ2RvbGxhcic6JyQnLCdkb3BmJzonXFxcXHVEODM1XFxcXHVERDU1JywnRG9wZic6J1xcXFx1RDgzNVxcXFx1REQzQicsJ2RvdCc6J1xcXFx1MDJEOScsJ0RvdCc6J1xcXFx4QTgnLCdEb3REb3QnOidcXFxcdTIwREMnLCdkb3RlcSc6J1xcXFx1MjI1MCcsJ2RvdGVxZG90JzonXFxcXHUyMjUxJywnRG90RXF1YWwnOidcXFxcdTIyNTAnLCdkb3RtaW51cyc6J1xcXFx1MjIzOCcsJ2RvdHBsdXMnOidcXFxcdTIyMTQnLCdkb3RzcXVhcmUnOidcXFxcdTIyQTEnLCdkb3VibGViYXJ3ZWRnZSc6J1xcXFx1MjMwNicsJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCc6J1xcXFx1MjIyRicsJ0RvdWJsZURvdCc6J1xcXFx4QTgnLCdEb3VibGVEb3duQXJyb3cnOidcXFxcdTIxRDMnLCdEb3VibGVMZWZ0QXJyb3cnOidcXFxcdTIxRDAnLCdEb3VibGVMZWZ0UmlnaHRBcnJvdyc6J1xcXFx1MjFENCcsJ0RvdWJsZUxlZnRUZWUnOidcXFxcdTJBRTQnLCdEb3VibGVMb25nTGVmdEFycm93JzonXFxcXHUyN0Y4JywnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JzonXFxcXHUyN0ZBJywnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnOidcXFxcdTI3RjknLCdEb3VibGVSaWdodEFycm93JzonXFxcXHUyMUQyJywnRG91YmxlUmlnaHRUZWUnOidcXFxcdTIyQTgnLCdEb3VibGVVcEFycm93JzonXFxcXHUyMUQxJywnRG91YmxlVXBEb3duQXJyb3cnOidcXFxcdTIxRDUnLCdEb3VibGVWZXJ0aWNhbEJhcic6J1xcXFx1MjIyNScsJ2Rvd25hcnJvdyc6J1xcXFx1MjE5MycsJ0Rvd25hcnJvdyc6J1xcXFx1MjFEMycsJ0Rvd25BcnJvdyc6J1xcXFx1MjE5MycsJ0Rvd25BcnJvd0Jhcic6J1xcXFx1MjkxMycsJ0Rvd25BcnJvd1VwQXJyb3cnOidcXFxcdTIxRjUnLCdEb3duQnJldmUnOidcXFxcdTAzMTEnLCdkb3duZG93bmFycm93cyc6J1xcXFx1MjFDQScsJ2Rvd25oYXJwb29ubGVmdCc6J1xcXFx1MjFDMycsJ2Rvd25oYXJwb29ucmlnaHQnOidcXFxcdTIxQzInLCdEb3duTGVmdFJpZ2h0VmVjdG9yJzonXFxcXHUyOTUwJywnRG93bkxlZnRUZWVWZWN0b3InOidcXFxcdTI5NUUnLCdEb3duTGVmdFZlY3Rvcic6J1xcXFx1MjFCRCcsJ0Rvd25MZWZ0VmVjdG9yQmFyJzonXFxcXHUyOTU2JywnRG93blJpZ2h0VGVlVmVjdG9yJzonXFxcXHUyOTVGJywnRG93blJpZ2h0VmVjdG9yJzonXFxcXHUyMUMxJywnRG93blJpZ2h0VmVjdG9yQmFyJzonXFxcXHUyOTU3JywnRG93blRlZSc6J1xcXFx1MjJBNCcsJ0Rvd25UZWVBcnJvdyc6J1xcXFx1MjFBNycsJ2RyYmthcm93JzonXFxcXHUyOTEwJywnZHJjb3JuJzonXFxcXHUyMzFGJywnZHJjcm9wJzonXFxcXHUyMzBDJywnZHNjcic6J1xcXFx1RDgzNVxcXFx1RENCOScsJ0RzY3InOidcXFxcdUQ4MzVcXFxcdURDOUYnLCdkc2N5JzonXFxcXHUwNDU1JywnRFNjeSc6J1xcXFx1MDQwNScsJ2Rzb2wnOidcXFxcdTI5RjYnLCdkc3Ryb2snOidcXFxcdTAxMTEnLCdEc3Ryb2snOidcXFxcdTAxMTAnLCdkdGRvdCc6J1xcXFx1MjJGMScsJ2R0cmknOidcXFxcdTI1QkYnLCdkdHJpZic6J1xcXFx1MjVCRScsJ2R1YXJyJzonXFxcXHUyMUY1JywnZHVoYXInOidcXFxcdTI5NkYnLCdkd2FuZ2xlJzonXFxcXHUyOUE2JywnZHpjeSc6J1xcXFx1MDQ1RicsJ0RaY3knOidcXFxcdTA0MEYnLCdkemlncmFycic6J1xcXFx1MjdGRicsJ2VhY3V0ZSc6J1xcXFx4RTknLCdFYWN1dGUnOidcXFxceEM5JywnZWFzdGVyJzonXFxcXHUyQTZFJywnZWNhcm9uJzonXFxcXHUwMTFCJywnRWNhcm9uJzonXFxcXHUwMTFBJywnZWNpcic6J1xcXFx1MjI1NicsJ2VjaXJjJzonXFxcXHhFQScsJ0VjaXJjJzonXFxcXHhDQScsJ2Vjb2xvbic6J1xcXFx1MjI1NScsJ2VjeSc6J1xcXFx1MDQ0RCcsJ0VjeSc6J1xcXFx1MDQyRCcsJ2VERG90JzonXFxcXHUyQTc3JywnZWRvdCc6J1xcXFx1MDExNycsJ2VEb3QnOidcXFxcdTIyNTEnLCdFZG90JzonXFxcXHUwMTE2JywnZWUnOidcXFxcdTIxNDcnLCdlZkRvdCc6J1xcXFx1MjI1MicsJ2Vmcic6J1xcXFx1RDgzNVxcXFx1REQyMicsJ0Vmcic6J1xcXFx1RDgzNVxcXFx1REQwOCcsJ2VnJzonXFxcXHUyQTlBJywnZWdyYXZlJzonXFxcXHhFOCcsJ0VncmF2ZSc6J1xcXFx4QzgnLCdlZ3MnOidcXFxcdTJBOTYnLCdlZ3Nkb3QnOidcXFxcdTJBOTgnLCdlbCc6J1xcXFx1MkE5OScsJ0VsZW1lbnQnOidcXFxcdTIyMDgnLCdlbGludGVycyc6J1xcXFx1MjNFNycsJ2VsbCc6J1xcXFx1MjExMycsJ2Vscyc6J1xcXFx1MkE5NScsJ2Vsc2RvdCc6J1xcXFx1MkE5NycsJ2VtYWNyJzonXFxcXHUwMTEzJywnRW1hY3InOidcXFxcdTAxMTInLCdlbXB0eSc6J1xcXFx1MjIwNScsJ2VtcHR5c2V0JzonXFxcXHUyMjA1JywnRW1wdHlTbWFsbFNxdWFyZSc6J1xcXFx1MjVGQicsJ2VtcHR5dic6J1xcXFx1MjIwNScsJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJzonXFxcXHUyNUFCJywnZW1zcCc6J1xcXFx1MjAwMycsJ2Vtc3AxMyc6J1xcXFx1MjAwNCcsJ2Vtc3AxNCc6J1xcXFx1MjAwNScsJ2VuZyc6J1xcXFx1MDE0QicsJ0VORyc6J1xcXFx1MDE0QScsJ2Vuc3AnOidcXFxcdTIwMDInLCdlb2dvbic6J1xcXFx1MDExOScsJ0VvZ29uJzonXFxcXHUwMTE4JywnZW9wZic6J1xcXFx1RDgzNVxcXFx1REQ1NicsJ0VvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0MnLCdlcGFyJzonXFxcXHUyMkQ1JywnZXBhcnNsJzonXFxcXHUyOUUzJywnZXBsdXMnOidcXFxcdTJBNzEnLCdlcHNpJzonXFxcXHUwM0I1JywnZXBzaWxvbic6J1xcXFx1MDNCNScsJ0Vwc2lsb24nOidcXFxcdTAzOTUnLCdlcHNpdic6J1xcXFx1MDNGNScsJ2VxY2lyYyc6J1xcXFx1MjI1NicsJ2VxY29sb24nOidcXFxcdTIyNTUnLCdlcXNpbSc6J1xcXFx1MjI0MicsJ2Vxc2xhbnRndHInOidcXFxcdTJBOTYnLCdlcXNsYW50bGVzcyc6J1xcXFx1MkE5NScsJ0VxdWFsJzonXFxcXHUyQTc1JywnZXF1YWxzJzonPScsJ0VxdWFsVGlsZGUnOidcXFxcdTIyNDInLCdlcXVlc3QnOidcXFxcdTIyNUYnLCdFcXVpbGlicml1bSc6J1xcXFx1MjFDQycsJ2VxdWl2JzonXFxcXHUyMjYxJywnZXF1aXZERCc6J1xcXFx1MkE3OCcsJ2VxdnBhcnNsJzonXFxcXHUyOUU1JywnZXJhcnInOidcXFxcdTI5NzEnLCdlckRvdCc6J1xcXFx1MjI1MycsJ2VzY3InOidcXFxcdTIxMkYnLCdFc2NyJzonXFxcXHUyMTMwJywnZXNkb3QnOidcXFxcdTIyNTAnLCdlc2ltJzonXFxcXHUyMjQyJywnRXNpbSc6J1xcXFx1MkE3MycsJ2V0YSc6J1xcXFx1MDNCNycsJ0V0YSc6J1xcXFx1MDM5NycsJ2V0aCc6J1xcXFx4RjAnLCdFVEgnOidcXFxceEQwJywnZXVtbCc6J1xcXFx4RUInLCdFdW1sJzonXFxcXHhDQicsJ2V1cm8nOidcXFxcdTIwQUMnLCdleGNsJzonIScsJ2V4aXN0JzonXFxcXHUyMjAzJywnRXhpc3RzJzonXFxcXHUyMjAzJywnZXhwZWN0YXRpb24nOidcXFxcdTIxMzAnLCdleHBvbmVudGlhbGUnOidcXFxcdTIxNDcnLCdFeHBvbmVudGlhbEUnOidcXFxcdTIxNDcnLCdmYWxsaW5nZG90c2VxJzonXFxcXHUyMjUyJywnZmN5JzonXFxcXHUwNDQ0JywnRmN5JzonXFxcXHUwNDI0JywnZmVtYWxlJzonXFxcXHUyNjQwJywnZmZpbGlnJzonXFxcXHVGQjAzJywnZmZsaWcnOidcXFxcdUZCMDAnLCdmZmxsaWcnOidcXFxcdUZCMDQnLCdmZnInOidcXFxcdUQ4MzVcXFxcdUREMjMnLCdGZnInOidcXFxcdUQ4MzVcXFxcdUREMDknLCdmaWxpZyc6J1xcXFx1RkIwMScsJ0ZpbGxlZFNtYWxsU3F1YXJlJzonXFxcXHUyNUZDJywnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJzonXFxcXHUyNUFBJywnZmpsaWcnOidmaicsJ2ZsYXQnOidcXFxcdTI2NkQnLCdmbGxpZyc6J1xcXFx1RkIwMicsJ2ZsdG5zJzonXFxcXHUyNUIxJywnZm5vZic6J1xcXFx1MDE5MicsJ2ZvcGYnOidcXFxcdUQ4MzVcXFxcdURENTcnLCdGb3BmJzonXFxcXHVEODM1XFxcXHVERDNEJywnZm9yYWxsJzonXFxcXHUyMjAwJywnRm9yQWxsJzonXFxcXHUyMjAwJywnZm9yayc6J1xcXFx1MjJENCcsJ2Zvcmt2JzonXFxcXHUyQUQ5JywnRm91cmllcnRyZic6J1xcXFx1MjEzMScsJ2ZwYXJ0aW50JzonXFxcXHUyQTBEJywnZnJhYzEyJzonXFxcXHhCRCcsJ2ZyYWMxMyc6J1xcXFx1MjE1MycsJ2ZyYWMxNCc6J1xcXFx4QkMnLCdmcmFjMTUnOidcXFxcdTIxNTUnLCdmcmFjMTYnOidcXFxcdTIxNTknLCdmcmFjMTgnOidcXFxcdTIxNUInLCdmcmFjMjMnOidcXFxcdTIxNTQnLCdmcmFjMjUnOidcXFxcdTIxNTYnLCdmcmFjMzQnOidcXFxceEJFJywnZnJhYzM1JzonXFxcXHUyMTU3JywnZnJhYzM4JzonXFxcXHUyMTVDJywnZnJhYzQ1JzonXFxcXHUyMTU4JywnZnJhYzU2JzonXFxcXHUyMTVBJywnZnJhYzU4JzonXFxcXHUyMTVEJywnZnJhYzc4JzonXFxcXHUyMTVFJywnZnJhc2wnOidcXFxcdTIwNDQnLCdmcm93bic6J1xcXFx1MjMyMicsJ2ZzY3InOidcXFxcdUQ4MzVcXFxcdURDQkInLCdGc2NyJzonXFxcXHUyMTMxJywnZ2FjdXRlJzonXFxcXHUwMUY1JywnZ2FtbWEnOidcXFxcdTAzQjMnLCdHYW1tYSc6J1xcXFx1MDM5MycsJ2dhbW1hZCc6J1xcXFx1MDNERCcsJ0dhbW1hZCc6J1xcXFx1MDNEQycsJ2dhcCc6J1xcXFx1MkE4NicsJ2dicmV2ZSc6J1xcXFx1MDExRicsJ0dicmV2ZSc6J1xcXFx1MDExRScsJ0djZWRpbCc6J1xcXFx1MDEyMicsJ2djaXJjJzonXFxcXHUwMTFEJywnR2NpcmMnOidcXFxcdTAxMUMnLCdnY3knOidcXFxcdTA0MzMnLCdHY3knOidcXFxcdTA0MTMnLCdnZG90JzonXFxcXHUwMTIxJywnR2RvdCc6J1xcXFx1MDEyMCcsJ2dlJzonXFxcXHUyMjY1JywnZ0UnOidcXFxcdTIyNjcnLCdnZWwnOidcXFxcdTIyREInLCdnRWwnOidcXFxcdTJBOEMnLCdnZXEnOidcXFxcdTIyNjUnLCdnZXFxJzonXFxcXHUyMjY3JywnZ2Vxc2xhbnQnOidcXFxcdTJBN0UnLCdnZXMnOidcXFxcdTJBN0UnLCdnZXNjYyc6J1xcXFx1MkFBOScsJ2dlc2RvdCc6J1xcXFx1MkE4MCcsJ2dlc2RvdG8nOidcXFxcdTJBODInLCdnZXNkb3RvbCc6J1xcXFx1MkE4NCcsJ2dlc2wnOidcXFxcdTIyREJcXFxcdUZFMDAnLCdnZXNsZXMnOidcXFxcdTJBOTQnLCdnZnInOidcXFxcdUQ4MzVcXFxcdUREMjQnLCdHZnInOidcXFxcdUQ4MzVcXFxcdUREMEEnLCdnZyc6J1xcXFx1MjI2QicsJ0dnJzonXFxcXHUyMkQ5JywnZ2dnJzonXFxcXHUyMkQ5JywnZ2ltZWwnOidcXFxcdTIxMzcnLCdnamN5JzonXFxcXHUwNDUzJywnR0pjeSc6J1xcXFx1MDQwMycsJ2dsJzonXFxcXHUyMjc3JywnZ2xhJzonXFxcXHUyQUE1JywnZ2xFJzonXFxcXHUyQTkyJywnZ2xqJzonXFxcXHUyQUE0JywnZ25hcCc6J1xcXFx1MkE4QScsJ2duYXBwcm94JzonXFxcXHUyQThBJywnZ25lJzonXFxcXHUyQTg4JywnZ25FJzonXFxcXHUyMjY5JywnZ25lcSc6J1xcXFx1MkE4OCcsJ2duZXFxJzonXFxcXHUyMjY5JywnZ25zaW0nOidcXFxcdTIyRTcnLCdnb3BmJzonXFxcXHVEODM1XFxcXHVERDU4JywnR29wZic6J1xcXFx1RDgzNVxcXFx1REQzRScsJ2dyYXZlJzonYCcsJ0dyZWF0ZXJFcXVhbCc6J1xcXFx1MjI2NScsJ0dyZWF0ZXJFcXVhbExlc3MnOidcXFxcdTIyREInLCdHcmVhdGVyRnVsbEVxdWFsJzonXFxcXHUyMjY3JywnR3JlYXRlckdyZWF0ZXInOidcXFxcdTJBQTInLCdHcmVhdGVyTGVzcyc6J1xcXFx1MjI3NycsJ0dyZWF0ZXJTbGFudEVxdWFsJzonXFxcXHUyQTdFJywnR3JlYXRlclRpbGRlJzonXFxcXHUyMjczJywnZ3Njcic6J1xcXFx1MjEwQScsJ0dzY3InOidcXFxcdUQ4MzVcXFxcdURDQTInLCdnc2ltJzonXFxcXHUyMjczJywnZ3NpbWUnOidcXFxcdTJBOEUnLCdnc2ltbCc6J1xcXFx1MkE5MCcsJ2d0JzonPicsJ0d0JzonXFxcXHUyMjZCJywnR1QnOic+JywnZ3RjYyc6J1xcXFx1MkFBNycsJ2d0Y2lyJzonXFxcXHUyQTdBJywnZ3Rkb3QnOidcXFxcdTIyRDcnLCdndGxQYXInOidcXFxcdTI5OTUnLCdndHF1ZXN0JzonXFxcXHUyQTdDJywnZ3RyYXBwcm94JzonXFxcXHUyQTg2JywnZ3RyYXJyJzonXFxcXHUyOTc4JywnZ3RyZG90JzonXFxcXHUyMkQ3JywnZ3RyZXFsZXNzJzonXFxcXHUyMkRCJywnZ3RyZXFxbGVzcyc6J1xcXFx1MkE4QycsJ2d0cmxlc3MnOidcXFxcdTIyNzcnLCdndHJzaW0nOidcXFxcdTIyNzMnLCdndmVydG5lcXEnOidcXFxcdTIyNjlcXFxcdUZFMDAnLCdndm5FJzonXFxcXHUyMjY5XFxcXHVGRTAwJywnSGFjZWsnOidcXFxcdTAyQzcnLCdoYWlyc3AnOidcXFxcdTIwMEEnLCdoYWxmJzonXFxcXHhCRCcsJ2hhbWlsdCc6J1xcXFx1MjEwQicsJ2hhcmRjeSc6J1xcXFx1MDQ0QScsJ0hBUkRjeSc6J1xcXFx1MDQyQScsJ2hhcnInOidcXFxcdTIxOTQnLCdoQXJyJzonXFxcXHUyMUQ0JywnaGFycmNpcic6J1xcXFx1Mjk0OCcsJ2hhcnJ3JzonXFxcXHUyMUFEJywnSGF0JzonXicsJ2hiYXInOidcXFxcdTIxMEYnLCdoY2lyYyc6J1xcXFx1MDEyNScsJ0hjaXJjJzonXFxcXHUwMTI0JywnaGVhcnRzJzonXFxcXHUyNjY1JywnaGVhcnRzdWl0JzonXFxcXHUyNjY1JywnaGVsbGlwJzonXFxcXHUyMDI2JywnaGVyY29uJzonXFxcXHUyMkI5JywnaGZyJzonXFxcXHVEODM1XFxcXHVERDI1JywnSGZyJzonXFxcXHUyMTBDJywnSGlsYmVydFNwYWNlJzonXFxcXHUyMTBCJywnaGtzZWFyb3cnOidcXFxcdTI5MjUnLCdoa3N3YXJvdyc6J1xcXFx1MjkyNicsJ2hvYXJyJzonXFxcXHUyMUZGJywnaG9tdGh0JzonXFxcXHUyMjNCJywnaG9va2xlZnRhcnJvdyc6J1xcXFx1MjFBOScsJ2hvb2tyaWdodGFycm93JzonXFxcXHUyMUFBJywnaG9wZic6J1xcXFx1RDgzNVxcXFx1REQ1OScsJ0hvcGYnOidcXFxcdTIxMEQnLCdob3JiYXInOidcXFxcdTIwMTUnLCdIb3Jpem9udGFsTGluZSc6J1xcXFx1MjUwMCcsJ2hzY3InOidcXFxcdUQ4MzVcXFxcdURDQkQnLCdIc2NyJzonXFxcXHUyMTBCJywnaHNsYXNoJzonXFxcXHUyMTBGJywnaHN0cm9rJzonXFxcXHUwMTI3JywnSHN0cm9rJzonXFxcXHUwMTI2JywnSHVtcERvd25IdW1wJzonXFxcXHUyMjRFJywnSHVtcEVxdWFsJzonXFxcXHUyMjRGJywnaHlidWxsJzonXFxcXHUyMDQzJywnaHlwaGVuJzonXFxcXHUyMDEwJywnaWFjdXRlJzonXFxcXHhFRCcsJ0lhY3V0ZSc6J1xcXFx4Q0QnLCdpYyc6J1xcXFx1MjA2MycsJ2ljaXJjJzonXFxcXHhFRScsJ0ljaXJjJzonXFxcXHhDRScsJ2ljeSc6J1xcXFx1MDQzOCcsJ0ljeSc6J1xcXFx1MDQxOCcsJ0lkb3QnOidcXFxcdTAxMzAnLCdpZWN5JzonXFxcXHUwNDM1JywnSUVjeSc6J1xcXFx1MDQxNScsJ2lleGNsJzonXFxcXHhBMScsJ2lmZic6J1xcXFx1MjFENCcsJ2lmcic6J1xcXFx1RDgzNVxcXFx1REQyNicsJ0lmcic6J1xcXFx1MjExMScsJ2lncmF2ZSc6J1xcXFx4RUMnLCdJZ3JhdmUnOidcXFxceENDJywnaWknOidcXFxcdTIxNDgnLCdpaWlpbnQnOidcXFxcdTJBMEMnLCdpaWludCc6J1xcXFx1MjIyRCcsJ2lpbmZpbic6J1xcXFx1MjlEQycsJ2lpb3RhJzonXFxcXHUyMTI5JywnaWpsaWcnOidcXFxcdTAxMzMnLCdJSmxpZyc6J1xcXFx1MDEzMicsJ0ltJzonXFxcXHUyMTExJywnaW1hY3InOidcXFxcdTAxMkInLCdJbWFjcic6J1xcXFx1MDEyQScsJ2ltYWdlJzonXFxcXHUyMTExJywnSW1hZ2luYXJ5SSc6J1xcXFx1MjE0OCcsJ2ltYWdsaW5lJzonXFxcXHUyMTEwJywnaW1hZ3BhcnQnOidcXFxcdTIxMTEnLCdpbWF0aCc6J1xcXFx1MDEzMScsJ2ltb2YnOidcXFxcdTIyQjcnLCdpbXBlZCc6J1xcXFx1MDFCNScsJ0ltcGxpZXMnOidcXFxcdTIxRDInLCdpbic6J1xcXFx1MjIwOCcsJ2luY2FyZSc6J1xcXFx1MjEwNScsJ2luZmluJzonXFxcXHUyMjFFJywnaW5maW50aWUnOidcXFxcdTI5REQnLCdpbm9kb3QnOidcXFxcdTAxMzEnLCdpbnQnOidcXFxcdTIyMkInLCdJbnQnOidcXFxcdTIyMkMnLCdpbnRjYWwnOidcXFxcdTIyQkEnLCdpbnRlZ2Vycyc6J1xcXFx1MjEyNCcsJ0ludGVncmFsJzonXFxcXHUyMjJCJywnaW50ZXJjYWwnOidcXFxcdTIyQkEnLCdJbnRlcnNlY3Rpb24nOidcXFxcdTIyQzInLCdpbnRsYXJoayc6J1xcXFx1MkExNycsJ2ludHByb2QnOidcXFxcdTJBM0MnLCdJbnZpc2libGVDb21tYSc6J1xcXFx1MjA2MycsJ0ludmlzaWJsZVRpbWVzJzonXFxcXHUyMDYyJywnaW9jeSc6J1xcXFx1MDQ1MScsJ0lPY3knOidcXFxcdTA0MDEnLCdpb2dvbic6J1xcXFx1MDEyRicsJ0lvZ29uJzonXFxcXHUwMTJFJywnaW9wZic6J1xcXFx1RDgzNVxcXFx1REQ1QScsJ0lvcGYnOidcXFxcdUQ4MzVcXFxcdURENDAnLCdpb3RhJzonXFxcXHUwM0I5JywnSW90YSc6J1xcXFx1MDM5OScsJ2lwcm9kJzonXFxcXHUyQTNDJywnaXF1ZXN0JzonXFxcXHhCRicsJ2lzY3InOidcXFxcdUQ4MzVcXFxcdURDQkUnLCdJc2NyJzonXFxcXHUyMTEwJywnaXNpbic6J1xcXFx1MjIwOCcsJ2lzaW5kb3QnOidcXFxcdTIyRjUnLCdpc2luRSc6J1xcXFx1MjJGOScsJ2lzaW5zJzonXFxcXHUyMkY0JywnaXNpbnN2JzonXFxcXHUyMkYzJywnaXNpbnYnOidcXFxcdTIyMDgnLCdpdCc6J1xcXFx1MjA2MicsJ2l0aWxkZSc6J1xcXFx1MDEyOScsJ0l0aWxkZSc6J1xcXFx1MDEyOCcsJ2l1a2N5JzonXFxcXHUwNDU2JywnSXVrY3knOidcXFxcdTA0MDYnLCdpdW1sJzonXFxcXHhFRicsJ0l1bWwnOidcXFxceENGJywnamNpcmMnOidcXFxcdTAxMzUnLCdKY2lyYyc6J1xcXFx1MDEzNCcsJ2pjeSc6J1xcXFx1MDQzOScsJ0pjeSc6J1xcXFx1MDQxOScsJ2pmcic6J1xcXFx1RDgzNVxcXFx1REQyNycsJ0pmcic6J1xcXFx1RDgzNVxcXFx1REQwRCcsJ2ptYXRoJzonXFxcXHUwMjM3Jywnam9wZic6J1xcXFx1RDgzNVxcXFx1REQ1QicsJ0pvcGYnOidcXFxcdUQ4MzVcXFxcdURENDEnLCdqc2NyJzonXFxcXHVEODM1XFxcXHVEQ0JGJywnSnNjcic6J1xcXFx1RDgzNVxcXFx1RENBNScsJ2pzZXJjeSc6J1xcXFx1MDQ1OCcsJ0pzZXJjeSc6J1xcXFx1MDQwOCcsJ2p1a2N5JzonXFxcXHUwNDU0JywnSnVrY3knOidcXFxcdTA0MDQnLCdrYXBwYSc6J1xcXFx1MDNCQScsJ0thcHBhJzonXFxcXHUwMzlBJywna2FwcGF2JzonXFxcXHUwM0YwJywna2NlZGlsJzonXFxcXHUwMTM3JywnS2NlZGlsJzonXFxcXHUwMTM2Jywna2N5JzonXFxcXHUwNDNBJywnS2N5JzonXFxcXHUwNDFBJywna2ZyJzonXFxcXHVEODM1XFxcXHVERDI4JywnS2ZyJzonXFxcXHVEODM1XFxcXHVERDBFJywna2dyZWVuJzonXFxcXHUwMTM4Jywna2hjeSc6J1xcXFx1MDQ0NScsJ0tIY3knOidcXFxcdTA0MjUnLCdramN5JzonXFxcXHUwNDVDJywnS0pjeSc6J1xcXFx1MDQwQycsJ2tvcGYnOidcXFxcdUQ4MzVcXFxcdURENUMnLCdLb3BmJzonXFxcXHVEODM1XFxcXHVERDQyJywna3Njcic6J1xcXFx1RDgzNVxcXFx1RENDMCcsJ0tzY3InOidcXFxcdUQ4MzVcXFxcdURDQTYnLCdsQWFycic6J1xcXFx1MjFEQScsJ2xhY3V0ZSc6J1xcXFx1MDEzQScsJ0xhY3V0ZSc6J1xcXFx1MDEzOScsJ2xhZW1wdHl2JzonXFxcXHUyOUI0JywnbGFncmFuJzonXFxcXHUyMTEyJywnbGFtYmRhJzonXFxcXHUwM0JCJywnTGFtYmRhJzonXFxcXHUwMzlCJywnbGFuZyc6J1xcXFx1MjdFOCcsJ0xhbmcnOidcXFxcdTI3RUEnLCdsYW5nZCc6J1xcXFx1Mjk5MScsJ2xhbmdsZSc6J1xcXFx1MjdFOCcsJ2xhcCc6J1xcXFx1MkE4NScsJ0xhcGxhY2V0cmYnOidcXFxcdTIxMTInLCdsYXF1byc6J1xcXFx4QUInLCdsYXJyJzonXFxcXHUyMTkwJywnbEFycic6J1xcXFx1MjFEMCcsJ0xhcnInOidcXFxcdTIxOUUnLCdsYXJyYic6J1xcXFx1MjFFNCcsJ2xhcnJiZnMnOidcXFxcdTI5MUYnLCdsYXJyZnMnOidcXFxcdTI5MUQnLCdsYXJyaGsnOidcXFxcdTIxQTknLCdsYXJybHAnOidcXFxcdTIxQUInLCdsYXJycGwnOidcXFxcdTI5MzknLCdsYXJyc2ltJzonXFxcXHUyOTczJywnbGFycnRsJzonXFxcXHUyMUEyJywnbGF0JzonXFxcXHUyQUFCJywnbGF0YWlsJzonXFxcXHUyOTE5JywnbEF0YWlsJzonXFxcXHUyOTFCJywnbGF0ZSc6J1xcXFx1MkFBRCcsJ2xhdGVzJzonXFxcXHUyQUFEXFxcXHVGRTAwJywnbGJhcnInOidcXFxcdTI5MEMnLCdsQmFycic6J1xcXFx1MjkwRScsJ2xiYnJrJzonXFxcXHUyNzcyJywnbGJyYWNlJzoneycsJ2xicmFjayc6J1snLCdsYnJrZSc6J1xcXFx1Mjk4QicsJ2xicmtzbGQnOidcXFxcdTI5OEYnLCdsYnJrc2x1JzonXFxcXHUyOThEJywnbGNhcm9uJzonXFxcXHUwMTNFJywnTGNhcm9uJzonXFxcXHUwMTNEJywnbGNlZGlsJzonXFxcXHUwMTNDJywnTGNlZGlsJzonXFxcXHUwMTNCJywnbGNlaWwnOidcXFxcdTIzMDgnLCdsY3ViJzoneycsJ2xjeSc6J1xcXFx1MDQzQicsJ0xjeSc6J1xcXFx1MDQxQicsJ2xkY2EnOidcXFxcdTI5MzYnLCdsZHF1byc6J1xcXFx1MjAxQycsJ2xkcXVvcic6J1xcXFx1MjAxRScsJ2xkcmRoYXInOidcXFxcdTI5NjcnLCdsZHJ1c2hhcic6J1xcXFx1Mjk0QicsJ2xkc2gnOidcXFxcdTIxQjInLCdsZSc6J1xcXFx1MjI2NCcsJ2xFJzonXFxcXHUyMjY2JywnTGVmdEFuZ2xlQnJhY2tldCc6J1xcXFx1MjdFOCcsJ2xlZnRhcnJvdyc6J1xcXFx1MjE5MCcsJ0xlZnRhcnJvdyc6J1xcXFx1MjFEMCcsJ0xlZnRBcnJvdyc6J1xcXFx1MjE5MCcsJ0xlZnRBcnJvd0Jhcic6J1xcXFx1MjFFNCcsJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnOidcXFxcdTIxQzYnLCdsZWZ0YXJyb3d0YWlsJzonXFxcXHUyMUEyJywnTGVmdENlaWxpbmcnOidcXFxcdTIzMDgnLCdMZWZ0RG91YmxlQnJhY2tldCc6J1xcXFx1MjdFNicsJ0xlZnREb3duVGVlVmVjdG9yJzonXFxcXHUyOTYxJywnTGVmdERvd25WZWN0b3InOidcXFxcdTIxQzMnLCdMZWZ0RG93blZlY3RvckJhcic6J1xcXFx1Mjk1OScsJ0xlZnRGbG9vcic6J1xcXFx1MjMwQScsJ2xlZnRoYXJwb29uZG93bic6J1xcXFx1MjFCRCcsJ2xlZnRoYXJwb29udXAnOidcXFxcdTIxQkMnLCdsZWZ0bGVmdGFycm93cyc6J1xcXFx1MjFDNycsJ2xlZnRyaWdodGFycm93JzonXFxcXHUyMTk0JywnTGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxRDQnLCdMZWZ0UmlnaHRBcnJvdyc6J1xcXFx1MjE5NCcsJ2xlZnRyaWdodGFycm93cyc6J1xcXFx1MjFDNicsJ2xlZnRyaWdodGhhcnBvb25zJzonXFxcXHUyMUNCJywnbGVmdHJpZ2h0c3F1aWdhcnJvdyc6J1xcXFx1MjFBRCcsJ0xlZnRSaWdodFZlY3Rvcic6J1xcXFx1Mjk0RScsJ0xlZnRUZWUnOidcXFxcdTIyQTMnLCdMZWZ0VGVlQXJyb3cnOidcXFxcdTIxQTQnLCdMZWZ0VGVlVmVjdG9yJzonXFxcXHUyOTVBJywnbGVmdHRocmVldGltZXMnOidcXFxcdTIyQ0InLCdMZWZ0VHJpYW5nbGUnOidcXFxcdTIyQjInLCdMZWZ0VHJpYW5nbGVCYXInOidcXFxcdTI5Q0YnLCdMZWZ0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJCNCcsJ0xlZnRVcERvd25WZWN0b3InOidcXFxcdTI5NTEnLCdMZWZ0VXBUZWVWZWN0b3InOidcXFxcdTI5NjAnLCdMZWZ0VXBWZWN0b3InOidcXFxcdTIxQkYnLCdMZWZ0VXBWZWN0b3JCYXInOidcXFxcdTI5NTgnLCdMZWZ0VmVjdG9yJzonXFxcXHUyMUJDJywnTGVmdFZlY3RvckJhcic6J1xcXFx1Mjk1MicsJ2xlZyc6J1xcXFx1MjJEQScsJ2xFZyc6J1xcXFx1MkE4QicsJ2xlcSc6J1xcXFx1MjI2NCcsJ2xlcXEnOidcXFxcdTIyNjYnLCdsZXFzbGFudCc6J1xcXFx1MkE3RCcsJ2xlcyc6J1xcXFx1MkE3RCcsJ2xlc2NjJzonXFxcXHUyQUE4JywnbGVzZG90JzonXFxcXHUyQTdGJywnbGVzZG90byc6J1xcXFx1MkE4MScsJ2xlc2RvdG9yJzonXFxcXHUyQTgzJywnbGVzZyc6J1xcXFx1MjJEQVxcXFx1RkUwMCcsJ2xlc2dlcyc6J1xcXFx1MkE5MycsJ2xlc3NhcHByb3gnOidcXFxcdTJBODUnLCdsZXNzZG90JzonXFxcXHUyMkQ2JywnbGVzc2VxZ3RyJzonXFxcXHUyMkRBJywnbGVzc2VxcWd0cic6J1xcXFx1MkE4QicsJ0xlc3NFcXVhbEdyZWF0ZXInOidcXFxcdTIyREEnLCdMZXNzRnVsbEVxdWFsJzonXFxcXHUyMjY2JywnTGVzc0dyZWF0ZXInOidcXFxcdTIyNzYnLCdsZXNzZ3RyJzonXFxcXHUyMjc2JywnTGVzc0xlc3MnOidcXFxcdTJBQTEnLCdsZXNzc2ltJzonXFxcXHUyMjcyJywnTGVzc1NsYW50RXF1YWwnOidcXFxcdTJBN0QnLCdMZXNzVGlsZGUnOidcXFxcdTIyNzInLCdsZmlzaHQnOidcXFxcdTI5N0MnLCdsZmxvb3InOidcXFxcdTIzMEEnLCdsZnInOidcXFxcdUQ4MzVcXFxcdUREMjknLCdMZnInOidcXFxcdUQ4MzVcXFxcdUREMEYnLCdsZyc6J1xcXFx1MjI3NicsJ2xnRSc6J1xcXFx1MkE5MScsJ2xIYXInOidcXFxcdTI5NjInLCdsaGFyZCc6J1xcXFx1MjFCRCcsJ2xoYXJ1JzonXFxcXHUyMUJDJywnbGhhcnVsJzonXFxcXHUyOTZBJywnbGhibGsnOidcXFxcdTI1ODQnLCdsamN5JzonXFxcXHUwNDU5JywnTEpjeSc6J1xcXFx1MDQwOScsJ2xsJzonXFxcXHUyMjZBJywnTGwnOidcXFxcdTIyRDgnLCdsbGFycic6J1xcXFx1MjFDNycsJ2xsY29ybmVyJzonXFxcXHUyMzFFJywnTGxlZnRhcnJvdyc6J1xcXFx1MjFEQScsJ2xsaGFyZCc6J1xcXFx1Mjk2QicsJ2xsdHJpJzonXFxcXHUyNUZBJywnbG1pZG90JzonXFxcXHUwMTQwJywnTG1pZG90JzonXFxcXHUwMTNGJywnbG1vdXN0JzonXFxcXHUyM0IwJywnbG1vdXN0YWNoZSc6J1xcXFx1MjNCMCcsJ2xuYXAnOidcXFxcdTJBODknLCdsbmFwcHJveCc6J1xcXFx1MkE4OScsJ2xuZSc6J1xcXFx1MkE4NycsJ2xuRSc6J1xcXFx1MjI2OCcsJ2xuZXEnOidcXFxcdTJBODcnLCdsbmVxcSc6J1xcXFx1MjI2OCcsJ2xuc2ltJzonXFxcXHUyMkU2JywnbG9hbmcnOidcXFxcdTI3RUMnLCdsb2Fycic6J1xcXFx1MjFGRCcsJ2xvYnJrJzonXFxcXHUyN0U2JywnbG9uZ2xlZnRhcnJvdyc6J1xcXFx1MjdGNScsJ0xvbmdsZWZ0YXJyb3cnOidcXFxcdTI3RjgnLCdMb25nTGVmdEFycm93JzonXFxcXHUyN0Y1JywnbG9uZ2xlZnRyaWdodGFycm93JzonXFxcXHUyN0Y3JywnTG9uZ2xlZnRyaWdodGFycm93JzonXFxcXHUyN0ZBJywnTG9uZ0xlZnRSaWdodEFycm93JzonXFxcXHUyN0Y3JywnbG9uZ21hcHN0byc6J1xcXFx1MjdGQycsJ2xvbmdyaWdodGFycm93JzonXFxcXHUyN0Y2JywnTG9uZ3JpZ2h0YXJyb3cnOidcXFxcdTI3RjknLCdMb25nUmlnaHRBcnJvdyc6J1xcXFx1MjdGNicsJ2xvb3BhcnJvd2xlZnQnOidcXFxcdTIxQUInLCdsb29wYXJyb3dyaWdodCc6J1xcXFx1MjFBQycsJ2xvcGFyJzonXFxcXHUyOTg1JywnbG9wZic6J1xcXFx1RDgzNVxcXFx1REQ1RCcsJ0xvcGYnOidcXFxcdUQ4MzVcXFxcdURENDMnLCdsb3BsdXMnOidcXFxcdTJBMkQnLCdsb3RpbWVzJzonXFxcXHUyQTM0JywnbG93YXN0JzonXFxcXHUyMjE3JywnbG93YmFyJzonXycsJ0xvd2VyTGVmdEFycm93JzonXFxcXHUyMTk5JywnTG93ZXJSaWdodEFycm93JzonXFxcXHUyMTk4JywnbG96JzonXFxcXHUyNUNBJywnbG96ZW5nZSc6J1xcXFx1MjVDQScsJ2xvemYnOidcXFxcdTI5RUInLCdscGFyJzonKCcsJ2xwYXJsdCc6J1xcXFx1Mjk5MycsJ2xyYXJyJzonXFxcXHUyMUM2JywnbHJjb3JuZXInOidcXFxcdTIzMUYnLCdscmhhcic6J1xcXFx1MjFDQicsJ2xyaGFyZCc6J1xcXFx1Mjk2RCcsJ2xybSc6J1xcXFx1MjAwRScsJ2xydHJpJzonXFxcXHUyMkJGJywnbHNhcXVvJzonXFxcXHUyMDM5JywnbHNjcic6J1xcXFx1RDgzNVxcXFx1RENDMScsJ0xzY3InOidcXFxcdTIxMTInLCdsc2gnOidcXFxcdTIxQjAnLCdMc2gnOidcXFxcdTIxQjAnLCdsc2ltJzonXFxcXHUyMjcyJywnbHNpbWUnOidcXFxcdTJBOEQnLCdsc2ltZyc6J1xcXFx1MkE4RicsJ2xzcWInOidbJywnbHNxdW8nOidcXFxcdTIwMTgnLCdsc3F1b3InOidcXFxcdTIwMUEnLCdsc3Ryb2snOidcXFxcdTAxNDInLCdMc3Ryb2snOidcXFxcdTAxNDEnLCdsdCc6JzwnLCdMdCc6J1xcXFx1MjI2QScsJ0xUJzonPCcsJ2x0Y2MnOidcXFxcdTJBQTYnLCdsdGNpcic6J1xcXFx1MkE3OScsJ2x0ZG90JzonXFxcXHUyMkQ2JywnbHRocmVlJzonXFxcXHUyMkNCJywnbHRpbWVzJzonXFxcXHUyMkM5JywnbHRsYXJyJzonXFxcXHUyOTc2JywnbHRxdWVzdCc6J1xcXFx1MkE3QicsJ2x0cmknOidcXFxcdTI1QzMnLCdsdHJpZSc6J1xcXFx1MjJCNCcsJ2x0cmlmJzonXFxcXHUyNUMyJywnbHRyUGFyJzonXFxcXHUyOTk2JywnbHVyZHNoYXInOidcXFxcdTI5NEEnLCdsdXJ1aGFyJzonXFxcXHUyOTY2JywnbHZlcnRuZXFxJzonXFxcXHUyMjY4XFxcXHVGRTAwJywnbHZuRSc6J1xcXFx1MjI2OFxcXFx1RkUwMCcsJ21hY3InOidcXFxceEFGJywnbWFsZSc6J1xcXFx1MjY0MicsJ21hbHQnOidcXFxcdTI3MjAnLCdtYWx0ZXNlJzonXFxcXHUyNzIwJywnbWFwJzonXFxcXHUyMUE2JywnTWFwJzonXFxcXHUyOTA1JywnbWFwc3RvJzonXFxcXHUyMUE2JywnbWFwc3RvZG93bic6J1xcXFx1MjFBNycsJ21hcHN0b2xlZnQnOidcXFxcdTIxQTQnLCdtYXBzdG91cCc6J1xcXFx1MjFBNScsJ21hcmtlcic6J1xcXFx1MjVBRScsJ21jb21tYSc6J1xcXFx1MkEyOScsJ21jeSc6J1xcXFx1MDQzQycsJ01jeSc6J1xcXFx1MDQxQycsJ21kYXNoJzonXFxcXHUyMDE0JywnbUREb3QnOidcXFxcdTIyM0EnLCdtZWFzdXJlZGFuZ2xlJzonXFxcXHUyMjIxJywnTWVkaXVtU3BhY2UnOidcXFxcdTIwNUYnLCdNZWxsaW50cmYnOidcXFxcdTIxMzMnLCdtZnInOidcXFxcdUQ4MzVcXFxcdUREMkEnLCdNZnInOidcXFxcdUQ4MzVcXFxcdUREMTAnLCdtaG8nOidcXFxcdTIxMjcnLCdtaWNybyc6J1xcXFx4QjUnLCdtaWQnOidcXFxcdTIyMjMnLCdtaWRhc3QnOicqJywnbWlkY2lyJzonXFxcXHUyQUYwJywnbWlkZG90JzonXFxcXHhCNycsJ21pbnVzJzonXFxcXHUyMjEyJywnbWludXNiJzonXFxcXHUyMjlGJywnbWludXNkJzonXFxcXHUyMjM4JywnbWludXNkdSc6J1xcXFx1MkEyQScsJ01pbnVzUGx1cyc6J1xcXFx1MjIxMycsJ21sY3AnOidcXFxcdTJBREInLCdtbGRyJzonXFxcXHUyMDI2JywnbW5wbHVzJzonXFxcXHUyMjEzJywnbW9kZWxzJzonXFxcXHUyMkE3JywnbW9wZic6J1xcXFx1RDgzNVxcXFx1REQ1RScsJ01vcGYnOidcXFxcdUQ4MzVcXFxcdURENDQnLCdtcCc6J1xcXFx1MjIxMycsJ21zY3InOidcXFxcdUQ4MzVcXFxcdURDQzInLCdNc2NyJzonXFxcXHUyMTMzJywnbXN0cG9zJzonXFxcXHUyMjNFJywnbXUnOidcXFxcdTAzQkMnLCdNdSc6J1xcXFx1MDM5QycsJ211bHRpbWFwJzonXFxcXHUyMkI4JywnbXVtYXAnOidcXFxcdTIyQjgnLCduYWJsYSc6J1xcXFx1MjIwNycsJ25hY3V0ZSc6J1xcXFx1MDE0NCcsJ05hY3V0ZSc6J1xcXFx1MDE0MycsJ25hbmcnOidcXFxcdTIyMjBcXFxcdTIwRDInLCduYXAnOidcXFxcdTIyNDknLCduYXBFJzonXFxcXHUyQTcwXFxcXHUwMzM4JywnbmFwaWQnOidcXFxcdTIyNEJcXFxcdTAzMzgnLCduYXBvcyc6J1xcXFx1MDE0OScsJ25hcHByb3gnOidcXFxcdTIyNDknLCduYXR1cic6J1xcXFx1MjY2RScsJ25hdHVyYWwnOidcXFxcdTI2NkUnLCduYXR1cmFscyc6J1xcXFx1MjExNScsJ25ic3AnOidcXFxceEEwJywnbmJ1bXAnOidcXFxcdTIyNEVcXFxcdTAzMzgnLCduYnVtcGUnOidcXFxcdTIyNEZcXFxcdTAzMzgnLCduY2FwJzonXFxcXHUyQTQzJywnbmNhcm9uJzonXFxcXHUwMTQ4JywnTmNhcm9uJzonXFxcXHUwMTQ3JywnbmNlZGlsJzonXFxcXHUwMTQ2JywnTmNlZGlsJzonXFxcXHUwMTQ1JywnbmNvbmcnOidcXFxcdTIyNDcnLCduY29uZ2RvdCc6J1xcXFx1MkE2RFxcXFx1MDMzOCcsJ25jdXAnOidcXFxcdTJBNDInLCduY3knOidcXFxcdTA0M0QnLCdOY3knOidcXFxcdTA0MUQnLCduZGFzaCc6J1xcXFx1MjAxMycsJ25lJzonXFxcXHUyMjYwJywnbmVhcmhrJzonXFxcXHUyOTI0JywnbmVhcnInOidcXFxcdTIxOTcnLCduZUFycic6J1xcXFx1MjFENycsJ25lYXJyb3cnOidcXFxcdTIxOTcnLCduZWRvdCc6J1xcXFx1MjI1MFxcXFx1MDMzOCcsJ05lZ2F0aXZlTWVkaXVtU3BhY2UnOidcXFxcdTIwMEInLCdOZWdhdGl2ZVRoaWNrU3BhY2UnOidcXFxcdTIwMEInLCdOZWdhdGl2ZVRoaW5TcGFjZSc6J1xcXFx1MjAwQicsJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZSc6J1xcXFx1MjAwQicsJ25lcXVpdic6J1xcXFx1MjI2MicsJ25lc2Vhcic6J1xcXFx1MjkyOCcsJ25lc2ltJzonXFxcXHUyMjQyXFxcXHUwMzM4JywnTmVzdGVkR3JlYXRlckdyZWF0ZXInOidcXFxcdTIyNkInLCdOZXN0ZWRMZXNzTGVzcyc6J1xcXFx1MjI2QScsJ05ld0xpbmUnOidcXFxcbicsJ25leGlzdCc6J1xcXFx1MjIwNCcsJ25leGlzdHMnOidcXFxcdTIyMDQnLCduZnInOidcXFxcdUQ4MzVcXFxcdUREMkInLCdOZnInOidcXFxcdUQ4MzVcXFxcdUREMTEnLCduZ2UnOidcXFxcdTIyNzEnLCduZ0UnOidcXFxcdTIyNjdcXFxcdTAzMzgnLCduZ2VxJzonXFxcXHUyMjcxJywnbmdlcXEnOidcXFxcdTIyNjdcXFxcdTAzMzgnLCduZ2Vxc2xhbnQnOidcXFxcdTJBN0VcXFxcdTAzMzgnLCduZ2VzJzonXFxcXHUyQTdFXFxcXHUwMzM4JywnbkdnJzonXFxcXHUyMkQ5XFxcXHUwMzM4JywnbmdzaW0nOidcXFxcdTIyNzUnLCduZ3QnOidcXFxcdTIyNkYnLCduR3QnOidcXFxcdTIyNkJcXFxcdTIwRDInLCduZ3RyJzonXFxcXHUyMjZGJywnbkd0dic6J1xcXFx1MjI2QlxcXFx1MDMzOCcsJ25oYXJyJzonXFxcXHUyMUFFJywnbmhBcnInOidcXFxcdTIxQ0UnLCduaHBhcic6J1xcXFx1MkFGMicsJ25pJzonXFxcXHUyMjBCJywnbmlzJzonXFxcXHUyMkZDJywnbmlzZCc6J1xcXFx1MjJGQScsJ25pdic6J1xcXFx1MjIwQicsJ25qY3knOidcXFxcdTA0NUEnLCdOSmN5JzonXFxcXHUwNDBBJywnbmxhcnInOidcXFxcdTIxOUEnLCdubEFycic6J1xcXFx1MjFDRCcsJ25sZHInOidcXFxcdTIwMjUnLCdubGUnOidcXFxcdTIyNzAnLCdubEUnOidcXFxcdTIyNjZcXFxcdTAzMzgnLCdubGVmdGFycm93JzonXFxcXHUyMTlBJywnbkxlZnRhcnJvdyc6J1xcXFx1MjFDRCcsJ25sZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjFBRScsJ25MZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjFDRScsJ25sZXEnOidcXFxcdTIyNzAnLCdubGVxcSc6J1xcXFx1MjI2NlxcXFx1MDMzOCcsJ25sZXFzbGFudCc6J1xcXFx1MkE3RFxcXFx1MDMzOCcsJ25sZXMnOidcXFxcdTJBN0RcXFxcdTAzMzgnLCdubGVzcyc6J1xcXFx1MjI2RScsJ25MbCc6J1xcXFx1MjJEOFxcXFx1MDMzOCcsJ25sc2ltJzonXFxcXHUyMjc0Jywnbmx0JzonXFxcXHUyMjZFJywnbkx0JzonXFxcXHUyMjZBXFxcXHUyMEQyJywnbmx0cmknOidcXFxcdTIyRUEnLCdubHRyaWUnOidcXFxcdTIyRUMnLCduTHR2JzonXFxcXHUyMjZBXFxcXHUwMzM4Jywnbm1pZCc6J1xcXFx1MjIyNCcsJ05vQnJlYWsnOidcXFxcdTIwNjAnLCdOb25CcmVha2luZ1NwYWNlJzonXFxcXHhBMCcsJ25vcGYnOidcXFxcdUQ4MzVcXFxcdURENUYnLCdOb3BmJzonXFxcXHUyMTE1Jywnbm90JzonXFxcXHhBQycsJ05vdCc6J1xcXFx1MkFFQycsJ05vdENvbmdydWVudCc6J1xcXFx1MjI2MicsJ05vdEN1cENhcCc6J1xcXFx1MjI2RCcsJ05vdERvdWJsZVZlcnRpY2FsQmFyJzonXFxcXHUyMjI2JywnTm90RWxlbWVudCc6J1xcXFx1MjIwOScsJ05vdEVxdWFsJzonXFxcXHUyMjYwJywnTm90RXF1YWxUaWxkZSc6J1xcXFx1MjI0MlxcXFx1MDMzOCcsJ05vdEV4aXN0cyc6J1xcXFx1MjIwNCcsJ05vdEdyZWF0ZXInOidcXFxcdTIyNkYnLCdOb3RHcmVhdGVyRXF1YWwnOidcXFxcdTIyNzEnLCdOb3RHcmVhdGVyRnVsbEVxdWFsJzonXFxcXHUyMjY3XFxcXHUwMzM4JywnTm90R3JlYXRlckdyZWF0ZXInOidcXFxcdTIyNkJcXFxcdTAzMzgnLCdOb3RHcmVhdGVyTGVzcyc6J1xcXFx1MjI3OScsJ05vdEdyZWF0ZXJTbGFudEVxdWFsJzonXFxcXHUyQTdFXFxcXHUwMzM4JywnTm90R3JlYXRlclRpbGRlJzonXFxcXHUyMjc1JywnTm90SHVtcERvd25IdW1wJzonXFxcXHUyMjRFXFxcXHUwMzM4JywnTm90SHVtcEVxdWFsJzonXFxcXHUyMjRGXFxcXHUwMzM4Jywnbm90aW4nOidcXFxcdTIyMDknLCdub3RpbmRvdCc6J1xcXFx1MjJGNVxcXFx1MDMzOCcsJ25vdGluRSc6J1xcXFx1MjJGOVxcXFx1MDMzOCcsJ25vdGludmEnOidcXFxcdTIyMDknLCdub3RpbnZiJzonXFxcXHUyMkY3Jywnbm90aW52Yyc6J1xcXFx1MjJGNicsJ05vdExlZnRUcmlhbmdsZSc6J1xcXFx1MjJFQScsJ05vdExlZnRUcmlhbmdsZUJhcic6J1xcXFx1MjlDRlxcXFx1MDMzOCcsJ05vdExlZnRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkVDJywnTm90TGVzcyc6J1xcXFx1MjI2RScsJ05vdExlc3NFcXVhbCc6J1xcXFx1MjI3MCcsJ05vdExlc3NHcmVhdGVyJzonXFxcXHUyMjc4JywnTm90TGVzc0xlc3MnOidcXFxcdTIyNkFcXFxcdTAzMzgnLCdOb3RMZXNzU2xhbnRFcXVhbCc6J1xcXFx1MkE3RFxcXFx1MDMzOCcsJ05vdExlc3NUaWxkZSc6J1xcXFx1MjI3NCcsJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJzonXFxcXHUyQUEyXFxcXHUwMzM4JywnTm90TmVzdGVkTGVzc0xlc3MnOidcXFxcdTJBQTFcXFxcdTAzMzgnLCdub3RuaSc6J1xcXFx1MjIwQycsJ25vdG5pdmEnOidcXFxcdTIyMEMnLCdub3RuaXZiJzonXFxcXHUyMkZFJywnbm90bml2Yyc6J1xcXFx1MjJGRCcsJ05vdFByZWNlZGVzJzonXFxcXHUyMjgwJywnTm90UHJlY2VkZXNFcXVhbCc6J1xcXFx1MkFBRlxcXFx1MDMzOCcsJ05vdFByZWNlZGVzU2xhbnRFcXVhbCc6J1xcXFx1MjJFMCcsJ05vdFJldmVyc2VFbGVtZW50JzonXFxcXHUyMjBDJywnTm90UmlnaHRUcmlhbmdsZSc6J1xcXFx1MjJFQicsJ05vdFJpZ2h0VHJpYW5nbGVCYXInOidcXFxcdTI5RDBcXFxcdTAzMzgnLCdOb3RSaWdodFRyaWFuZ2xlRXF1YWwnOidcXFxcdTIyRUQnLCdOb3RTcXVhcmVTdWJzZXQnOidcXFxcdTIyOEZcXFxcdTAzMzgnLCdOb3RTcXVhcmVTdWJzZXRFcXVhbCc6J1xcXFx1MjJFMicsJ05vdFNxdWFyZVN1cGVyc2V0JzonXFxcXHUyMjkwXFxcXHUwMzM4JywnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCc6J1xcXFx1MjJFMycsJ05vdFN1YnNldCc6J1xcXFx1MjI4MlxcXFx1MjBEMicsJ05vdFN1YnNldEVxdWFsJzonXFxcXHUyMjg4JywnTm90U3VjY2VlZHMnOidcXFxcdTIyODEnLCdOb3RTdWNjZWVkc0VxdWFsJzonXFxcXHUyQUIwXFxcXHUwMzM4JywnTm90U3VjY2VlZHNTbGFudEVxdWFsJzonXFxcXHUyMkUxJywnTm90U3VjY2VlZHNUaWxkZSc6J1xcXFx1MjI3RlxcXFx1MDMzOCcsJ05vdFN1cGVyc2V0JzonXFxcXHUyMjgzXFxcXHUyMEQyJywnTm90U3VwZXJzZXRFcXVhbCc6J1xcXFx1MjI4OScsJ05vdFRpbGRlJzonXFxcXHUyMjQxJywnTm90VGlsZGVFcXVhbCc6J1xcXFx1MjI0NCcsJ05vdFRpbGRlRnVsbEVxdWFsJzonXFxcXHUyMjQ3JywnTm90VGlsZGVUaWxkZSc6J1xcXFx1MjI0OScsJ05vdFZlcnRpY2FsQmFyJzonXFxcXHUyMjI0JywnbnBhcic6J1xcXFx1MjIyNicsJ25wYXJhbGxlbCc6J1xcXFx1MjIyNicsJ25wYXJzbCc6J1xcXFx1MkFGRFxcXFx1MjBFNScsJ25wYXJ0JzonXFxcXHUyMjAyXFxcXHUwMzM4JywnbnBvbGludCc6J1xcXFx1MkExNCcsJ25wcic6J1xcXFx1MjI4MCcsJ25wcmN1ZSc6J1xcXFx1MjJFMCcsJ25wcmUnOidcXFxcdTJBQUZcXFxcdTAzMzgnLCducHJlYyc6J1xcXFx1MjI4MCcsJ25wcmVjZXEnOidcXFxcdTJBQUZcXFxcdTAzMzgnLCducmFycic6J1xcXFx1MjE5QicsJ25yQXJyJzonXFxcXHUyMUNGJywnbnJhcnJjJzonXFxcXHUyOTMzXFxcXHUwMzM4JywnbnJhcnJ3JzonXFxcXHUyMTlEXFxcXHUwMzM4JywnbnJpZ2h0YXJyb3cnOidcXFxcdTIxOUInLCduUmlnaHRhcnJvdyc6J1xcXFx1MjFDRicsJ25ydHJpJzonXFxcXHUyMkVCJywnbnJ0cmllJzonXFxcXHUyMkVEJywnbnNjJzonXFxcXHUyMjgxJywnbnNjY3VlJzonXFxcXHUyMkUxJywnbnNjZSc6J1xcXFx1MkFCMFxcXFx1MDMzOCcsJ25zY3InOidcXFxcdUQ4MzVcXFxcdURDQzMnLCdOc2NyJzonXFxcXHVEODM1XFxcXHVEQ0E5JywnbnNob3J0bWlkJzonXFxcXHUyMjI0JywnbnNob3J0cGFyYWxsZWwnOidcXFxcdTIyMjYnLCduc2ltJzonXFxcXHUyMjQxJywnbnNpbWUnOidcXFxcdTIyNDQnLCduc2ltZXEnOidcXFxcdTIyNDQnLCduc21pZCc6J1xcXFx1MjIyNCcsJ25zcGFyJzonXFxcXHUyMjI2JywnbnNxc3ViZSc6J1xcXFx1MjJFMicsJ25zcXN1cGUnOidcXFxcdTIyRTMnLCduc3ViJzonXFxcXHUyMjg0JywnbnN1YmUnOidcXFxcdTIyODgnLCduc3ViRSc6J1xcXFx1MkFDNVxcXFx1MDMzOCcsJ25zdWJzZXQnOidcXFxcdTIyODJcXFxcdTIwRDInLCduc3Vic2V0ZXEnOidcXFxcdTIyODgnLCduc3Vic2V0ZXFxJzonXFxcXHUyQUM1XFxcXHUwMzM4JywnbnN1Y2MnOidcXFxcdTIyODEnLCduc3VjY2VxJzonXFxcXHUyQUIwXFxcXHUwMzM4JywnbnN1cCc6J1xcXFx1MjI4NScsJ25zdXBlJzonXFxcXHUyMjg5JywnbnN1cEUnOidcXFxcdTJBQzZcXFxcdTAzMzgnLCduc3Vwc2V0JzonXFxcXHUyMjgzXFxcXHUyMEQyJywnbnN1cHNldGVxJzonXFxcXHUyMjg5JywnbnN1cHNldGVxcSc6J1xcXFx1MkFDNlxcXFx1MDMzOCcsJ250Z2wnOidcXFxcdTIyNzknLCdudGlsZGUnOidcXFxceEYxJywnTnRpbGRlJzonXFxcXHhEMScsJ250bGcnOidcXFxcdTIyNzgnLCdudHJpYW5nbGVsZWZ0JzonXFxcXHUyMkVBJywnbnRyaWFuZ2xlbGVmdGVxJzonXFxcXHUyMkVDJywnbnRyaWFuZ2xlcmlnaHQnOidcXFxcdTIyRUInLCdudHJpYW5nbGVyaWdodGVxJzonXFxcXHUyMkVEJywnbnUnOidcXFxcdTAzQkQnLCdOdSc6J1xcXFx1MDM5RCcsJ251bSc6JyMnLCdudW1lcm8nOidcXFxcdTIxMTYnLCdudW1zcCc6J1xcXFx1MjAwNycsJ252YXAnOidcXFxcdTIyNERcXFxcdTIwRDInLCdudmRhc2gnOidcXFxcdTIyQUMnLCdudkRhc2gnOidcXFxcdTIyQUQnLCduVmRhc2gnOidcXFxcdTIyQUUnLCduVkRhc2gnOidcXFxcdTIyQUYnLCdudmdlJzonXFxcXHUyMjY1XFxcXHUyMEQyJywnbnZndCc6Jz5cXFxcdTIwRDInLCdudkhhcnInOidcXFxcdTI5MDQnLCdudmluZmluJzonXFxcXHUyOURFJywnbnZsQXJyJzonXFxcXHUyOTAyJywnbnZsZSc6J1xcXFx1MjI2NFxcXFx1MjBEMicsJ252bHQnOic8XFxcXHUyMEQyJywnbnZsdHJpZSc6J1xcXFx1MjJCNFxcXFx1MjBEMicsJ252ckFycic6J1xcXFx1MjkwMycsJ252cnRyaWUnOidcXFxcdTIyQjVcXFxcdTIwRDInLCdudnNpbSc6J1xcXFx1MjIzQ1xcXFx1MjBEMicsJ253YXJoayc6J1xcXFx1MjkyMycsJ253YXJyJzonXFxcXHUyMTk2JywnbndBcnInOidcXFxcdTIxRDYnLCdud2Fycm93JzonXFxcXHUyMTk2JywnbnduZWFyJzonXFxcXHUyOTI3Jywnb2FjdXRlJzonXFxcXHhGMycsJ09hY3V0ZSc6J1xcXFx4RDMnLCdvYXN0JzonXFxcXHUyMjlCJywnb2Npcic6J1xcXFx1MjI5QScsJ29jaXJjJzonXFxcXHhGNCcsJ09jaXJjJzonXFxcXHhENCcsJ29jeSc6J1xcXFx1MDQzRScsJ09jeSc6J1xcXFx1MDQxRScsJ29kYXNoJzonXFxcXHUyMjlEJywnb2RibGFjJzonXFxcXHUwMTUxJywnT2RibGFjJzonXFxcXHUwMTUwJywnb2Rpdic6J1xcXFx1MkEzOCcsJ29kb3QnOidcXFxcdTIyOTknLCdvZHNvbGQnOidcXFxcdTI5QkMnLCdvZWxpZyc6J1xcXFx1MDE1MycsJ09FbGlnJzonXFxcXHUwMTUyJywnb2ZjaXInOidcXFxcdTI5QkYnLCdvZnInOidcXFxcdUQ4MzVcXFxcdUREMkMnLCdPZnInOidcXFxcdUQ4MzVcXFxcdUREMTInLCdvZ29uJzonXFxcXHUwMkRCJywnb2dyYXZlJzonXFxcXHhGMicsJ09ncmF2ZSc6J1xcXFx4RDInLCdvZ3QnOidcXFxcdTI5QzEnLCdvaGJhcic6J1xcXFx1MjlCNScsJ29obSc6J1xcXFx1MDNBOScsJ29pbnQnOidcXFxcdTIyMkUnLCdvbGFycic6J1xcXFx1MjFCQScsJ29sY2lyJzonXFxcXHUyOUJFJywnb2xjcm9zcyc6J1xcXFx1MjlCQicsJ29saW5lJzonXFxcXHUyMDNFJywnb2x0JzonXFxcXHUyOUMwJywnb21hY3InOidcXFxcdTAxNEQnLCdPbWFjcic6J1xcXFx1MDE0QycsJ29tZWdhJzonXFxcXHUwM0M5JywnT21lZ2EnOidcXFxcdTAzQTknLCdvbWljcm9uJzonXFxcXHUwM0JGJywnT21pY3Jvbic6J1xcXFx1MDM5RicsJ29taWQnOidcXFxcdTI5QjYnLCdvbWludXMnOidcXFxcdTIyOTYnLCdvb3BmJzonXFxcXHVEODM1XFxcXHVERDYwJywnT29wZic6J1xcXFx1RDgzNVxcXFx1REQ0NicsJ29wYXInOidcXFxcdTI5QjcnLCdPcGVuQ3VybHlEb3VibGVRdW90ZSc6J1xcXFx1MjAxQycsJ09wZW5DdXJseVF1b3RlJzonXFxcXHUyMDE4Jywnb3BlcnAnOidcXFxcdTI5QjknLCdvcGx1cyc6J1xcXFx1MjI5NScsJ29yJzonXFxcXHUyMjI4JywnT3InOidcXFxcdTJBNTQnLCdvcmFycic6J1xcXFx1MjFCQicsJ29yZCc6J1xcXFx1MkE1RCcsJ29yZGVyJzonXFxcXHUyMTM0Jywnb3JkZXJvZic6J1xcXFx1MjEzNCcsJ29yZGYnOidcXFxceEFBJywnb3JkbSc6J1xcXFx4QkEnLCdvcmlnb2YnOidcXFxcdTIyQjYnLCdvcm9yJzonXFxcXHUyQTU2Jywnb3JzbG9wZSc6J1xcXFx1MkE1NycsJ29ydic6J1xcXFx1MkE1QicsJ29TJzonXFxcXHUyNEM4Jywnb3Njcic6J1xcXFx1MjEzNCcsJ09zY3InOidcXFxcdUQ4MzVcXFxcdURDQUEnLCdvc2xhc2gnOidcXFxceEY4JywnT3NsYXNoJzonXFxcXHhEOCcsJ29zb2wnOidcXFxcdTIyOTgnLCdvdGlsZGUnOidcXFxceEY1JywnT3RpbGRlJzonXFxcXHhENScsJ290aW1lcyc6J1xcXFx1MjI5NycsJ090aW1lcyc6J1xcXFx1MkEzNycsJ290aW1lc2FzJzonXFxcXHUyQTM2Jywnb3VtbCc6J1xcXFx4RjYnLCdPdW1sJzonXFxcXHhENicsJ292YmFyJzonXFxcXHUyMzNEJywnT3ZlckJhcic6J1xcXFx1MjAzRScsJ092ZXJCcmFjZSc6J1xcXFx1MjNERScsJ092ZXJCcmFja2V0JzonXFxcXHUyM0I0JywnT3ZlclBhcmVudGhlc2lzJzonXFxcXHUyM0RDJywncGFyJzonXFxcXHUyMjI1JywncGFyYSc6J1xcXFx4QjYnLCdwYXJhbGxlbCc6J1xcXFx1MjIyNScsJ3BhcnNpbSc6J1xcXFx1MkFGMycsJ3BhcnNsJzonXFxcXHUyQUZEJywncGFydCc6J1xcXFx1MjIwMicsJ1BhcnRpYWxEJzonXFxcXHUyMjAyJywncGN5JzonXFxcXHUwNDNGJywnUGN5JzonXFxcXHUwNDFGJywncGVyY250JzonJScsJ3BlcmlvZCc6Jy4nLCdwZXJtaWwnOidcXFxcdTIwMzAnLCdwZXJwJzonXFxcXHUyMkE1JywncGVydGVuayc6J1xcXFx1MjAzMScsJ3Bmcic6J1xcXFx1RDgzNVxcXFx1REQyRCcsJ1Bmcic6J1xcXFx1RDgzNVxcXFx1REQxMycsJ3BoaSc6J1xcXFx1MDNDNicsJ1BoaSc6J1xcXFx1MDNBNicsJ3BoaXYnOidcXFxcdTAzRDUnLCdwaG1tYXQnOidcXFxcdTIxMzMnLCdwaG9uZSc6J1xcXFx1MjYwRScsJ3BpJzonXFxcXHUwM0MwJywnUGknOidcXFxcdTAzQTAnLCdwaXRjaGZvcmsnOidcXFxcdTIyRDQnLCdwaXYnOidcXFxcdTAzRDYnLCdwbGFuY2snOidcXFxcdTIxMEYnLCdwbGFuY2toJzonXFxcXHUyMTBFJywncGxhbmt2JzonXFxcXHUyMTBGJywncGx1cyc6JysnLCdwbHVzYWNpcic6J1xcXFx1MkEyMycsJ3BsdXNiJzonXFxcXHUyMjlFJywncGx1c2Npcic6J1xcXFx1MkEyMicsJ3BsdXNkbyc6J1xcXFx1MjIxNCcsJ3BsdXNkdSc6J1xcXFx1MkEyNScsJ3BsdXNlJzonXFxcXHUyQTcyJywnUGx1c01pbnVzJzonXFxcXHhCMScsJ3BsdXNtbic6J1xcXFx4QjEnLCdwbHVzc2ltJzonXFxcXHUyQTI2JywncGx1c3R3byc6J1xcXFx1MkEyNycsJ3BtJzonXFxcXHhCMScsJ1BvaW5jYXJlcGxhbmUnOidcXFxcdTIxMEMnLCdwb2ludGludCc6J1xcXFx1MkExNScsJ3BvcGYnOidcXFxcdUQ4MzVcXFxcdURENjEnLCdQb3BmJzonXFxcXHUyMTE5JywncG91bmQnOidcXFxceEEzJywncHInOidcXFxcdTIyN0EnLCdQcic6J1xcXFx1MkFCQicsJ3ByYXAnOidcXFxcdTJBQjcnLCdwcmN1ZSc6J1xcXFx1MjI3QycsJ3ByZSc6J1xcXFx1MkFBRicsJ3ByRSc6J1xcXFx1MkFCMycsJ3ByZWMnOidcXFxcdTIyN0EnLCdwcmVjYXBwcm94JzonXFxcXHUyQUI3JywncHJlY2N1cmx5ZXEnOidcXFxcdTIyN0MnLCdQcmVjZWRlcyc6J1xcXFx1MjI3QScsJ1ByZWNlZGVzRXF1YWwnOidcXFxcdTJBQUYnLCdQcmVjZWRlc1NsYW50RXF1YWwnOidcXFxcdTIyN0MnLCdQcmVjZWRlc1RpbGRlJzonXFxcXHUyMjdFJywncHJlY2VxJzonXFxcXHUyQUFGJywncHJlY25hcHByb3gnOidcXFxcdTJBQjknLCdwcmVjbmVxcSc6J1xcXFx1MkFCNScsJ3ByZWNuc2ltJzonXFxcXHUyMkU4JywncHJlY3NpbSc6J1xcXFx1MjI3RScsJ3ByaW1lJzonXFxcXHUyMDMyJywnUHJpbWUnOidcXFxcdTIwMzMnLCdwcmltZXMnOidcXFxcdTIxMTknLCdwcm5hcCc6J1xcXFx1MkFCOScsJ3BybkUnOidcXFxcdTJBQjUnLCdwcm5zaW0nOidcXFxcdTIyRTgnLCdwcm9kJzonXFxcXHUyMjBGJywnUHJvZHVjdCc6J1xcXFx1MjIwRicsJ3Byb2ZhbGFyJzonXFxcXHUyMzJFJywncHJvZmxpbmUnOidcXFxcdTIzMTInLCdwcm9mc3VyZic6J1xcXFx1MjMxMycsJ3Byb3AnOidcXFxcdTIyMUQnLCdQcm9wb3J0aW9uJzonXFxcXHUyMjM3JywnUHJvcG9ydGlvbmFsJzonXFxcXHUyMjFEJywncHJvcHRvJzonXFxcXHUyMjFEJywncHJzaW0nOidcXFxcdTIyN0UnLCdwcnVyZWwnOidcXFxcdTIyQjAnLCdwc2NyJzonXFxcXHVEODM1XFxcXHVEQ0M1JywnUHNjcic6J1xcXFx1RDgzNVxcXFx1RENBQicsJ3BzaSc6J1xcXFx1MDNDOCcsJ1BzaSc6J1xcXFx1MDNBOCcsJ3B1bmNzcCc6J1xcXFx1MjAwOCcsJ3Fmcic6J1xcXFx1RDgzNVxcXFx1REQyRScsJ1Fmcic6J1xcXFx1RDgzNVxcXFx1REQxNCcsJ3FpbnQnOidcXFxcdTJBMEMnLCdxb3BmJzonXFxcXHVEODM1XFxcXHVERDYyJywnUW9wZic6J1xcXFx1MjExQScsJ3FwcmltZSc6J1xcXFx1MjA1NycsJ3FzY3InOidcXFxcdUQ4MzVcXFxcdURDQzYnLCdRc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FDJywncXVhdGVybmlvbnMnOidcXFxcdTIxMEQnLCdxdWF0aW50JzonXFxcXHUyQTE2JywncXVlc3QnOic/JywncXVlc3RlcSc6J1xcXFx1MjI1RicsJ3F1b3QnOidcXFwiJywnUVVPVCc6J1xcXCInLCdyQWFycic6J1xcXFx1MjFEQicsJ3JhY2UnOidcXFxcdTIyM0RcXFxcdTAzMzEnLCdyYWN1dGUnOidcXFxcdTAxNTUnLCdSYWN1dGUnOidcXFxcdTAxNTQnLCdyYWRpYyc6J1xcXFx1MjIxQScsJ3JhZW1wdHl2JzonXFxcXHUyOUIzJywncmFuZyc6J1xcXFx1MjdFOScsJ1JhbmcnOidcXFxcdTI3RUInLCdyYW5nZCc6J1xcXFx1Mjk5MicsJ3JhbmdlJzonXFxcXHUyOUE1JywncmFuZ2xlJzonXFxcXHUyN0U5JywncmFxdW8nOidcXFxceEJCJywncmFycic6J1xcXFx1MjE5MicsJ3JBcnInOidcXFxcdTIxRDInLCdSYXJyJzonXFxcXHUyMUEwJywncmFycmFwJzonXFxcXHUyOTc1JywncmFycmInOidcXFxcdTIxRTUnLCdyYXJyYmZzJzonXFxcXHUyOTIwJywncmFycmMnOidcXFxcdTI5MzMnLCdyYXJyZnMnOidcXFxcdTI5MUUnLCdyYXJyaGsnOidcXFxcdTIxQUEnLCdyYXJybHAnOidcXFxcdTIxQUMnLCdyYXJycGwnOidcXFxcdTI5NDUnLCdyYXJyc2ltJzonXFxcXHUyOTc0JywncmFycnRsJzonXFxcXHUyMUEzJywnUmFycnRsJzonXFxcXHUyOTE2JywncmFycncnOidcXFxcdTIxOUQnLCdyYXRhaWwnOidcXFxcdTI5MUEnLCdyQXRhaWwnOidcXFxcdTI5MUMnLCdyYXRpbyc6J1xcXFx1MjIzNicsJ3JhdGlvbmFscyc6J1xcXFx1MjExQScsJ3JiYXJyJzonXFxcXHUyOTBEJywnckJhcnInOidcXFxcdTI5MEYnLCdSQmFycic6J1xcXFx1MjkxMCcsJ3JiYnJrJzonXFxcXHUyNzczJywncmJyYWNlJzonfScsJ3JicmFjayc6J10nLCdyYnJrZSc6J1xcXFx1Mjk4QycsJ3JicmtzbGQnOidcXFxcdTI5OEUnLCdyYnJrc2x1JzonXFxcXHUyOTkwJywncmNhcm9uJzonXFxcXHUwMTU5JywnUmNhcm9uJzonXFxcXHUwMTU4JywncmNlZGlsJzonXFxcXHUwMTU3JywnUmNlZGlsJzonXFxcXHUwMTU2JywncmNlaWwnOidcXFxcdTIzMDknLCdyY3ViJzonfScsJ3JjeSc6J1xcXFx1MDQ0MCcsJ1JjeSc6J1xcXFx1MDQyMCcsJ3JkY2EnOidcXFxcdTI5MzcnLCdyZGxkaGFyJzonXFxcXHUyOTY5JywncmRxdW8nOidcXFxcdTIwMUQnLCdyZHF1b3InOidcXFxcdTIwMUQnLCdyZHNoJzonXFxcXHUyMUIzJywnUmUnOidcXFxcdTIxMUMnLCdyZWFsJzonXFxcXHUyMTFDJywncmVhbGluZSc6J1xcXFx1MjExQicsJ3JlYWxwYXJ0JzonXFxcXHUyMTFDJywncmVhbHMnOidcXFxcdTIxMUQnLCdyZWN0JzonXFxcXHUyNUFEJywncmVnJzonXFxcXHhBRScsJ1JFRyc6J1xcXFx4QUUnLCdSZXZlcnNlRWxlbWVudCc6J1xcXFx1MjIwQicsJ1JldmVyc2VFcXVpbGlicml1bSc6J1xcXFx1MjFDQicsJ1JldmVyc2VVcEVxdWlsaWJyaXVtJzonXFxcXHUyOTZGJywncmZpc2h0JzonXFxcXHUyOTdEJywncmZsb29yJzonXFxcXHUyMzBCJywncmZyJzonXFxcXHVEODM1XFxcXHVERDJGJywnUmZyJzonXFxcXHUyMTFDJywnckhhcic6J1xcXFx1Mjk2NCcsJ3JoYXJkJzonXFxcXHUyMUMxJywncmhhcnUnOidcXFxcdTIxQzAnLCdyaGFydWwnOidcXFxcdTI5NkMnLCdyaG8nOidcXFxcdTAzQzEnLCdSaG8nOidcXFxcdTAzQTEnLCdyaG92JzonXFxcXHUwM0YxJywnUmlnaHRBbmdsZUJyYWNrZXQnOidcXFxcdTI3RTknLCdyaWdodGFycm93JzonXFxcXHUyMTkyJywnUmlnaHRhcnJvdyc6J1xcXFx1MjFEMicsJ1JpZ2h0QXJyb3cnOidcXFxcdTIxOTInLCdSaWdodEFycm93QmFyJzonXFxcXHUyMUU1JywnUmlnaHRBcnJvd0xlZnRBcnJvdyc6J1xcXFx1MjFDNCcsJ3JpZ2h0YXJyb3d0YWlsJzonXFxcXHUyMUEzJywnUmlnaHRDZWlsaW5nJzonXFxcXHUyMzA5JywnUmlnaHREb3VibGVCcmFja2V0JzonXFxcXHUyN0U3JywnUmlnaHREb3duVGVlVmVjdG9yJzonXFxcXHUyOTVEJywnUmlnaHREb3duVmVjdG9yJzonXFxcXHUyMUMyJywnUmlnaHREb3duVmVjdG9yQmFyJzonXFxcXHUyOTU1JywnUmlnaHRGbG9vcic6J1xcXFx1MjMwQicsJ3JpZ2h0aGFycG9vbmRvd24nOidcXFxcdTIxQzEnLCdyaWdodGhhcnBvb251cCc6J1xcXFx1MjFDMCcsJ3JpZ2h0bGVmdGFycm93cyc6J1xcXFx1MjFDNCcsJ3JpZ2h0bGVmdGhhcnBvb25zJzonXFxcXHUyMUNDJywncmlnaHRyaWdodGFycm93cyc6J1xcXFx1MjFDOScsJ3JpZ2h0c3F1aWdhcnJvdyc6J1xcXFx1MjE5RCcsJ1JpZ2h0VGVlJzonXFxcXHUyMkEyJywnUmlnaHRUZWVBcnJvdyc6J1xcXFx1MjFBNicsJ1JpZ2h0VGVlVmVjdG9yJzonXFxcXHUyOTVCJywncmlnaHR0aHJlZXRpbWVzJzonXFxcXHUyMkNDJywnUmlnaHRUcmlhbmdsZSc6J1xcXFx1MjJCMycsJ1JpZ2h0VHJpYW5nbGVCYXInOidcXFxcdTI5RDAnLCdSaWdodFRyaWFuZ2xlRXF1YWwnOidcXFxcdTIyQjUnLCdSaWdodFVwRG93blZlY3Rvcic6J1xcXFx1Mjk0RicsJ1JpZ2h0VXBUZWVWZWN0b3InOidcXFxcdTI5NUMnLCdSaWdodFVwVmVjdG9yJzonXFxcXHUyMUJFJywnUmlnaHRVcFZlY3RvckJhcic6J1xcXFx1Mjk1NCcsJ1JpZ2h0VmVjdG9yJzonXFxcXHUyMUMwJywnUmlnaHRWZWN0b3JCYXInOidcXFxcdTI5NTMnLCdyaW5nJzonXFxcXHUwMkRBJywncmlzaW5nZG90c2VxJzonXFxcXHUyMjUzJywncmxhcnInOidcXFxcdTIxQzQnLCdybGhhcic6J1xcXFx1MjFDQycsJ3JsbSc6J1xcXFx1MjAwRicsJ3Jtb3VzdCc6J1xcXFx1MjNCMScsJ3Jtb3VzdGFjaGUnOidcXFxcdTIzQjEnLCdybm1pZCc6J1xcXFx1MkFFRScsJ3JvYW5nJzonXFxcXHUyN0VEJywncm9hcnInOidcXFxcdTIxRkUnLCdyb2Jyayc6J1xcXFx1MjdFNycsJ3JvcGFyJzonXFxcXHUyOTg2Jywncm9wZic6J1xcXFx1RDgzNVxcXFx1REQ2MycsJ1JvcGYnOidcXFxcdTIxMUQnLCdyb3BsdXMnOidcXFxcdTJBMkUnLCdyb3RpbWVzJzonXFxcXHUyQTM1JywnUm91bmRJbXBsaWVzJzonXFxcXHUyOTcwJywncnBhcic6JyknLCdycGFyZ3QnOidcXFxcdTI5OTQnLCdycHBvbGludCc6J1xcXFx1MkExMicsJ3JyYXJyJzonXFxcXHUyMUM5JywnUnJpZ2h0YXJyb3cnOidcXFxcdTIxREInLCdyc2FxdW8nOidcXFxcdTIwM0EnLCdyc2NyJzonXFxcXHVEODM1XFxcXHVEQ0M3JywnUnNjcic6J1xcXFx1MjExQicsJ3JzaCc6J1xcXFx1MjFCMScsJ1JzaCc6J1xcXFx1MjFCMScsJ3JzcWInOiddJywncnNxdW8nOidcXFxcdTIwMTknLCdyc3F1b3InOidcXFxcdTIwMTknLCdydGhyZWUnOidcXFxcdTIyQ0MnLCdydGltZXMnOidcXFxcdTIyQ0EnLCdydHJpJzonXFxcXHUyNUI5JywncnRyaWUnOidcXFxcdTIyQjUnLCdydHJpZic6J1xcXFx1MjVCOCcsJ3J0cmlsdHJpJzonXFxcXHUyOUNFJywnUnVsZURlbGF5ZWQnOidcXFxcdTI5RjQnLCdydWx1aGFyJzonXFxcXHUyOTY4JywncngnOidcXFxcdTIxMUUnLCdzYWN1dGUnOidcXFxcdTAxNUInLCdTYWN1dGUnOidcXFxcdTAxNUEnLCdzYnF1byc6J1xcXFx1MjAxQScsJ3NjJzonXFxcXHUyMjdCJywnU2MnOidcXFxcdTJBQkMnLCdzY2FwJzonXFxcXHUyQUI4Jywnc2Nhcm9uJzonXFxcXHUwMTYxJywnU2Nhcm9uJzonXFxcXHUwMTYwJywnc2NjdWUnOidcXFxcdTIyN0QnLCdzY2UnOidcXFxcdTJBQjAnLCdzY0UnOidcXFxcdTJBQjQnLCdzY2VkaWwnOidcXFxcdTAxNUYnLCdTY2VkaWwnOidcXFxcdTAxNUUnLCdzY2lyYyc6J1xcXFx1MDE1RCcsJ1NjaXJjJzonXFxcXHUwMTVDJywnc2NuYXAnOidcXFxcdTJBQkEnLCdzY25FJzonXFxcXHUyQUI2Jywnc2Nuc2ltJzonXFxcXHUyMkU5Jywnc2Nwb2xpbnQnOidcXFxcdTJBMTMnLCdzY3NpbSc6J1xcXFx1MjI3RicsJ3NjeSc6J1xcXFx1MDQ0MScsJ1NjeSc6J1xcXFx1MDQyMScsJ3Nkb3QnOidcXFxcdTIyQzUnLCdzZG90Yic6J1xcXFx1MjJBMScsJ3Nkb3RlJzonXFxcXHUyQTY2Jywnc2VhcmhrJzonXFxcXHUyOTI1Jywnc2VhcnInOidcXFxcdTIxOTgnLCdzZUFycic6J1xcXFx1MjFEOCcsJ3NlYXJyb3cnOidcXFxcdTIxOTgnLCdzZWN0JzonXFxcXHhBNycsJ3NlbWknOic7Jywnc2Vzd2FyJzonXFxcXHUyOTI5Jywnc2V0bWludXMnOidcXFxcdTIyMTYnLCdzZXRtbic6J1xcXFx1MjIxNicsJ3NleHQnOidcXFxcdTI3MzYnLCdzZnInOidcXFxcdUQ4MzVcXFxcdUREMzAnLCdTZnInOidcXFxcdUQ4MzVcXFxcdUREMTYnLCdzZnJvd24nOidcXFxcdTIzMjInLCdzaGFycCc6J1xcXFx1MjY2RicsJ3NoY2hjeSc6J1xcXFx1MDQ0OScsJ1NIQ0hjeSc6J1xcXFx1MDQyOScsJ3NoY3knOidcXFxcdTA0NDgnLCdTSGN5JzonXFxcXHUwNDI4JywnU2hvcnREb3duQXJyb3cnOidcXFxcdTIxOTMnLCdTaG9ydExlZnRBcnJvdyc6J1xcXFx1MjE5MCcsJ3Nob3J0bWlkJzonXFxcXHUyMjIzJywnc2hvcnRwYXJhbGxlbCc6J1xcXFx1MjIyNScsJ1Nob3J0UmlnaHRBcnJvdyc6J1xcXFx1MjE5MicsJ1Nob3J0VXBBcnJvdyc6J1xcXFx1MjE5MScsJ3NoeSc6J1xcXFx4QUQnLCdzaWdtYSc6J1xcXFx1MDNDMycsJ1NpZ21hJzonXFxcXHUwM0EzJywnc2lnbWFmJzonXFxcXHUwM0MyJywnc2lnbWF2JzonXFxcXHUwM0MyJywnc2ltJzonXFxcXHUyMjNDJywnc2ltZG90JzonXFxcXHUyQTZBJywnc2ltZSc6J1xcXFx1MjI0MycsJ3NpbWVxJzonXFxcXHUyMjQzJywnc2ltZyc6J1xcXFx1MkE5RScsJ3NpbWdFJzonXFxcXHUyQUEwJywnc2ltbCc6J1xcXFx1MkE5RCcsJ3NpbWxFJzonXFxcXHUyQTlGJywnc2ltbmUnOidcXFxcdTIyNDYnLCdzaW1wbHVzJzonXFxcXHUyQTI0Jywnc2ltcmFycic6J1xcXFx1Mjk3MicsJ3NsYXJyJzonXFxcXHUyMTkwJywnU21hbGxDaXJjbGUnOidcXFxcdTIyMTgnLCdzbWFsbHNldG1pbnVzJzonXFxcXHUyMjE2Jywnc21hc2hwJzonXFxcXHUyQTMzJywnc21lcGFyc2wnOidcXFxcdTI5RTQnLCdzbWlkJzonXFxcXHUyMjIzJywnc21pbGUnOidcXFxcdTIzMjMnLCdzbXQnOidcXFxcdTJBQUEnLCdzbXRlJzonXFxcXHUyQUFDJywnc210ZXMnOidcXFxcdTJBQUNcXFxcdUZFMDAnLCdzb2Z0Y3knOidcXFxcdTA0NEMnLCdTT0ZUY3knOidcXFxcdTA0MkMnLCdzb2wnOicvJywnc29sYic6J1xcXFx1MjlDNCcsJ3NvbGJhcic6J1xcXFx1MjMzRicsJ3NvcGYnOidcXFxcdUQ4MzVcXFxcdURENjQnLCdTb3BmJzonXFxcXHVEODM1XFxcXHVERDRBJywnc3BhZGVzJzonXFxcXHUyNjYwJywnc3BhZGVzdWl0JzonXFxcXHUyNjYwJywnc3Bhcic6J1xcXFx1MjIyNScsJ3NxY2FwJzonXFxcXHUyMjkzJywnc3FjYXBzJzonXFxcXHUyMjkzXFxcXHVGRTAwJywnc3FjdXAnOidcXFxcdTIyOTQnLCdzcWN1cHMnOidcXFxcdTIyOTRcXFxcdUZFMDAnLCdTcXJ0JzonXFxcXHUyMjFBJywnc3FzdWInOidcXFxcdTIyOEYnLCdzcXN1YmUnOidcXFxcdTIyOTEnLCdzcXN1YnNldCc6J1xcXFx1MjI4RicsJ3Nxc3Vic2V0ZXEnOidcXFxcdTIyOTEnLCdzcXN1cCc6J1xcXFx1MjI5MCcsJ3Nxc3VwZSc6J1xcXFx1MjI5MicsJ3Nxc3Vwc2V0JzonXFxcXHUyMjkwJywnc3FzdXBzZXRlcSc6J1xcXFx1MjI5MicsJ3NxdSc6J1xcXFx1MjVBMScsJ3NxdWFyZSc6J1xcXFx1MjVBMScsJ1NxdWFyZSc6J1xcXFx1MjVBMScsJ1NxdWFyZUludGVyc2VjdGlvbic6J1xcXFx1MjI5MycsJ1NxdWFyZVN1YnNldCc6J1xcXFx1MjI4RicsJ1NxdWFyZVN1YnNldEVxdWFsJzonXFxcXHUyMjkxJywnU3F1YXJlU3VwZXJzZXQnOidcXFxcdTIyOTAnLCdTcXVhcmVTdXBlcnNldEVxdWFsJzonXFxcXHUyMjkyJywnU3F1YXJlVW5pb24nOidcXFxcdTIyOTQnLCdzcXVhcmYnOidcXFxcdTI1QUEnLCdzcXVmJzonXFxcXHUyNUFBJywnc3JhcnInOidcXFxcdTIxOTInLCdzc2NyJzonXFxcXHVEODM1XFxcXHVEQ0M4JywnU3Njcic6J1xcXFx1RDgzNVxcXFx1RENBRScsJ3NzZXRtbic6J1xcXFx1MjIxNicsJ3NzbWlsZSc6J1xcXFx1MjMyMycsJ3NzdGFyZic6J1xcXFx1MjJDNicsJ3N0YXInOidcXFxcdTI2MDYnLCdTdGFyJzonXFxcXHUyMkM2Jywnc3RhcmYnOidcXFxcdTI2MDUnLCdzdHJhaWdodGVwc2lsb24nOidcXFxcdTAzRjUnLCdzdHJhaWdodHBoaSc6J1xcXFx1MDNENScsJ3N0cm5zJzonXFxcXHhBRicsJ3N1Yic6J1xcXFx1MjI4MicsJ1N1Yic6J1xcXFx1MjJEMCcsJ3N1YmRvdCc6J1xcXFx1MkFCRCcsJ3N1YmUnOidcXFxcdTIyODYnLCdzdWJFJzonXFxcXHUyQUM1Jywnc3ViZWRvdCc6J1xcXFx1MkFDMycsJ3N1Ym11bHQnOidcXFxcdTJBQzEnLCdzdWJuZSc6J1xcXFx1MjI4QScsJ3N1Ym5FJzonXFxcXHUyQUNCJywnc3VicGx1cyc6J1xcXFx1MkFCRicsJ3N1YnJhcnInOidcXFxcdTI5NzknLCdzdWJzZXQnOidcXFxcdTIyODInLCdTdWJzZXQnOidcXFxcdTIyRDAnLCdzdWJzZXRlcSc6J1xcXFx1MjI4NicsJ3N1YnNldGVxcSc6J1xcXFx1MkFDNScsJ1N1YnNldEVxdWFsJzonXFxcXHUyMjg2Jywnc3Vic2V0bmVxJzonXFxcXHUyMjhBJywnc3Vic2V0bmVxcSc6J1xcXFx1MkFDQicsJ3N1YnNpbSc6J1xcXFx1MkFDNycsJ3N1YnN1Yic6J1xcXFx1MkFENScsJ3N1YnN1cCc6J1xcXFx1MkFEMycsJ3N1Y2MnOidcXFxcdTIyN0InLCdzdWNjYXBwcm94JzonXFxcXHUyQUI4Jywnc3VjY2N1cmx5ZXEnOidcXFxcdTIyN0QnLCdTdWNjZWVkcyc6J1xcXFx1MjI3QicsJ1N1Y2NlZWRzRXF1YWwnOidcXFxcdTJBQjAnLCdTdWNjZWVkc1NsYW50RXF1YWwnOidcXFxcdTIyN0QnLCdTdWNjZWVkc1RpbGRlJzonXFxcXHUyMjdGJywnc3VjY2VxJzonXFxcXHUyQUIwJywnc3VjY25hcHByb3gnOidcXFxcdTJBQkEnLCdzdWNjbmVxcSc6J1xcXFx1MkFCNicsJ3N1Y2Nuc2ltJzonXFxcXHUyMkU5Jywnc3VjY3NpbSc6J1xcXFx1MjI3RicsJ1N1Y2hUaGF0JzonXFxcXHUyMjBCJywnc3VtJzonXFxcXHUyMjExJywnU3VtJzonXFxcXHUyMjExJywnc3VuZyc6J1xcXFx1MjY2QScsJ3N1cCc6J1xcXFx1MjI4MycsJ1N1cCc6J1xcXFx1MjJEMScsJ3N1cDEnOidcXFxceEI5Jywnc3VwMic6J1xcXFx4QjInLCdzdXAzJzonXFxcXHhCMycsJ3N1cGRvdCc6J1xcXFx1MkFCRScsJ3N1cGRzdWInOidcXFxcdTJBRDgnLCdzdXBlJzonXFxcXHUyMjg3Jywnc3VwRSc6J1xcXFx1MkFDNicsJ3N1cGVkb3QnOidcXFxcdTJBQzQnLCdTdXBlcnNldCc6J1xcXFx1MjI4MycsJ1N1cGVyc2V0RXF1YWwnOidcXFxcdTIyODcnLCdzdXBoc29sJzonXFxcXHUyN0M5Jywnc3VwaHN1Yic6J1xcXFx1MkFENycsJ3N1cGxhcnInOidcXFxcdTI5N0InLCdzdXBtdWx0JzonXFxcXHUyQUMyJywnc3VwbmUnOidcXFxcdTIyOEInLCdzdXBuRSc6J1xcXFx1MkFDQycsJ3N1cHBsdXMnOidcXFxcdTJBQzAnLCdzdXBzZXQnOidcXFxcdTIyODMnLCdTdXBzZXQnOidcXFxcdTIyRDEnLCdzdXBzZXRlcSc6J1xcXFx1MjI4NycsJ3N1cHNldGVxcSc6J1xcXFx1MkFDNicsJ3N1cHNldG5lcSc6J1xcXFx1MjI4QicsJ3N1cHNldG5lcXEnOidcXFxcdTJBQ0MnLCdzdXBzaW0nOidcXFxcdTJBQzgnLCdzdXBzdWInOidcXFxcdTJBRDQnLCdzdXBzdXAnOidcXFxcdTJBRDYnLCdzd2FyaGsnOidcXFxcdTI5MjYnLCdzd2Fycic6J1xcXFx1MjE5OScsJ3N3QXJyJzonXFxcXHUyMUQ5Jywnc3dhcnJvdyc6J1xcXFx1MjE5OScsJ3N3bndhcic6J1xcXFx1MjkyQScsJ3N6bGlnJzonXFxcXHhERicsJ1RhYic6J1xcXFx0JywndGFyZ2V0JzonXFxcXHUyMzE2JywndGF1JzonXFxcXHUwM0M0JywnVGF1JzonXFxcXHUwM0E0JywndGJyayc6J1xcXFx1MjNCNCcsJ3RjYXJvbic6J1xcXFx1MDE2NScsJ1RjYXJvbic6J1xcXFx1MDE2NCcsJ3RjZWRpbCc6J1xcXFx1MDE2MycsJ1RjZWRpbCc6J1xcXFx1MDE2MicsJ3RjeSc6J1xcXFx1MDQ0MicsJ1RjeSc6J1xcXFx1MDQyMicsJ3Rkb3QnOidcXFxcdTIwREInLCd0ZWxyZWMnOidcXFxcdTIzMTUnLCd0ZnInOidcXFxcdUQ4MzVcXFxcdUREMzEnLCdUZnInOidcXFxcdUQ4MzVcXFxcdUREMTcnLCd0aGVyZTQnOidcXFxcdTIyMzQnLCd0aGVyZWZvcmUnOidcXFxcdTIyMzQnLCdUaGVyZWZvcmUnOidcXFxcdTIyMzQnLCd0aGV0YSc6J1xcXFx1MDNCOCcsJ1RoZXRhJzonXFxcXHUwMzk4JywndGhldGFzeW0nOidcXFxcdTAzRDEnLCd0aGV0YXYnOidcXFxcdTAzRDEnLCd0aGlja2FwcHJveCc6J1xcXFx1MjI0OCcsJ3RoaWNrc2ltJzonXFxcXHUyMjNDJywnVGhpY2tTcGFjZSc6J1xcXFx1MjA1RlxcXFx1MjAwQScsJ3RoaW5zcCc6J1xcXFx1MjAwOScsJ1RoaW5TcGFjZSc6J1xcXFx1MjAwOScsJ3Roa2FwJzonXFxcXHUyMjQ4JywndGhrc2ltJzonXFxcXHUyMjNDJywndGhvcm4nOidcXFxceEZFJywnVEhPUk4nOidcXFxceERFJywndGlsZGUnOidcXFxcdTAyREMnLCdUaWxkZSc6J1xcXFx1MjIzQycsJ1RpbGRlRXF1YWwnOidcXFxcdTIyNDMnLCdUaWxkZUZ1bGxFcXVhbCc6J1xcXFx1MjI0NScsJ1RpbGRlVGlsZGUnOidcXFxcdTIyNDgnLCd0aW1lcyc6J1xcXFx4RDcnLCd0aW1lc2InOidcXFxcdTIyQTAnLCd0aW1lc2Jhcic6J1xcXFx1MkEzMScsJ3RpbWVzZCc6J1xcXFx1MkEzMCcsJ3RpbnQnOidcXFxcdTIyMkQnLCd0b2VhJzonXFxcXHUyOTI4JywndG9wJzonXFxcXHUyMkE0JywndG9wYm90JzonXFxcXHUyMzM2JywndG9wY2lyJzonXFxcXHUyQUYxJywndG9wZic6J1xcXFx1RDgzNVxcXFx1REQ2NScsJ1RvcGYnOidcXFxcdUQ4MzVcXFxcdURENEInLCd0b3Bmb3JrJzonXFxcXHUyQURBJywndG9zYSc6J1xcXFx1MjkyOScsJ3RwcmltZSc6J1xcXFx1MjAzNCcsJ3RyYWRlJzonXFxcXHUyMTIyJywnVFJBREUnOidcXFxcdTIxMjInLCd0cmlhbmdsZSc6J1xcXFx1MjVCNScsJ3RyaWFuZ2xlZG93bic6J1xcXFx1MjVCRicsJ3RyaWFuZ2xlbGVmdCc6J1xcXFx1MjVDMycsJ3RyaWFuZ2xlbGVmdGVxJzonXFxcXHUyMkI0JywndHJpYW5nbGVxJzonXFxcXHUyMjVDJywndHJpYW5nbGVyaWdodCc6J1xcXFx1MjVCOScsJ3RyaWFuZ2xlcmlnaHRlcSc6J1xcXFx1MjJCNScsJ3RyaWRvdCc6J1xcXFx1MjVFQycsJ3RyaWUnOidcXFxcdTIyNUMnLCd0cmltaW51cyc6J1xcXFx1MkEzQScsJ1RyaXBsZURvdCc6J1xcXFx1MjBEQicsJ3RyaXBsdXMnOidcXFxcdTJBMzknLCd0cmlzYic6J1xcXFx1MjlDRCcsJ3RyaXRpbWUnOidcXFxcdTJBM0InLCd0cnBleml1bSc6J1xcXFx1MjNFMicsJ3RzY3InOidcXFxcdUQ4MzVcXFxcdURDQzknLCdUc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FGJywndHNjeSc6J1xcXFx1MDQ0NicsJ1RTY3knOidcXFxcdTA0MjYnLCd0c2hjeSc6J1xcXFx1MDQ1QicsJ1RTSGN5JzonXFxcXHUwNDBCJywndHN0cm9rJzonXFxcXHUwMTY3JywnVHN0cm9rJzonXFxcXHUwMTY2JywndHdpeHQnOidcXFxcdTIyNkMnLCd0d29oZWFkbGVmdGFycm93JzonXFxcXHUyMTlFJywndHdvaGVhZHJpZ2h0YXJyb3cnOidcXFxcdTIxQTAnLCd1YWN1dGUnOidcXFxceEZBJywnVWFjdXRlJzonXFxcXHhEQScsJ3VhcnInOidcXFxcdTIxOTEnLCd1QXJyJzonXFxcXHUyMUQxJywnVWFycic6J1xcXFx1MjE5RicsJ1VhcnJvY2lyJzonXFxcXHUyOTQ5JywndWJyY3knOidcXFxcdTA0NUUnLCdVYnJjeSc6J1xcXFx1MDQwRScsJ3VicmV2ZSc6J1xcXFx1MDE2RCcsJ1VicmV2ZSc6J1xcXFx1MDE2QycsJ3VjaXJjJzonXFxcXHhGQicsJ1VjaXJjJzonXFxcXHhEQicsJ3VjeSc6J1xcXFx1MDQ0MycsJ1VjeSc6J1xcXFx1MDQyMycsJ3VkYXJyJzonXFxcXHUyMUM1JywndWRibGFjJzonXFxcXHUwMTcxJywnVWRibGFjJzonXFxcXHUwMTcwJywndWRoYXInOidcXFxcdTI5NkUnLCd1ZmlzaHQnOidcXFxcdTI5N0UnLCd1ZnInOidcXFxcdUQ4MzVcXFxcdUREMzInLCdVZnInOidcXFxcdUQ4MzVcXFxcdUREMTgnLCd1Z3JhdmUnOidcXFxceEY5JywnVWdyYXZlJzonXFxcXHhEOScsJ3VIYXInOidcXFxcdTI5NjMnLCd1aGFybCc6J1xcXFx1MjFCRicsJ3VoYXJyJzonXFxcXHUyMUJFJywndWhibGsnOidcXFxcdTI1ODAnLCd1bGNvcm4nOidcXFxcdTIzMUMnLCd1bGNvcm5lcic6J1xcXFx1MjMxQycsJ3VsY3JvcCc6J1xcXFx1MjMwRicsJ3VsdHJpJzonXFxcXHUyNUY4JywndW1hY3InOidcXFxcdTAxNkInLCdVbWFjcic6J1xcXFx1MDE2QScsJ3VtbCc6J1xcXFx4QTgnLCdVbmRlckJhcic6J18nLCdVbmRlckJyYWNlJzonXFxcXHUyM0RGJywnVW5kZXJCcmFja2V0JzonXFxcXHUyM0I1JywnVW5kZXJQYXJlbnRoZXNpcyc6J1xcXFx1MjNERCcsJ1VuaW9uJzonXFxcXHUyMkMzJywnVW5pb25QbHVzJzonXFxcXHUyMjhFJywndW9nb24nOidcXFxcdTAxNzMnLCdVb2dvbic6J1xcXFx1MDE3MicsJ3VvcGYnOidcXFxcdUQ4MzVcXFxcdURENjYnLCdVb3BmJzonXFxcXHVEODM1XFxcXHVERDRDJywndXBhcnJvdyc6J1xcXFx1MjE5MScsJ1VwYXJyb3cnOidcXFxcdTIxRDEnLCdVcEFycm93JzonXFxcXHUyMTkxJywnVXBBcnJvd0Jhcic6J1xcXFx1MjkxMicsJ1VwQXJyb3dEb3duQXJyb3cnOidcXFxcdTIxQzUnLCd1cGRvd25hcnJvdyc6J1xcXFx1MjE5NScsJ1VwZG93bmFycm93JzonXFxcXHUyMUQ1JywnVXBEb3duQXJyb3cnOidcXFxcdTIxOTUnLCdVcEVxdWlsaWJyaXVtJzonXFxcXHUyOTZFJywndXBoYXJwb29ubGVmdCc6J1xcXFx1MjFCRicsJ3VwaGFycG9vbnJpZ2h0JzonXFxcXHUyMUJFJywndXBsdXMnOidcXFxcdTIyOEUnLCdVcHBlckxlZnRBcnJvdyc6J1xcXFx1MjE5NicsJ1VwcGVyUmlnaHRBcnJvdyc6J1xcXFx1MjE5NycsJ3Vwc2knOidcXFxcdTAzQzUnLCdVcHNpJzonXFxcXHUwM0QyJywndXBzaWgnOidcXFxcdTAzRDInLCd1cHNpbG9uJzonXFxcXHUwM0M1JywnVXBzaWxvbic6J1xcXFx1MDNBNScsJ1VwVGVlJzonXFxcXHUyMkE1JywnVXBUZWVBcnJvdyc6J1xcXFx1MjFBNScsJ3VwdXBhcnJvd3MnOidcXFxcdTIxQzgnLCd1cmNvcm4nOidcXFxcdTIzMUQnLCd1cmNvcm5lcic6J1xcXFx1MjMxRCcsJ3VyY3JvcCc6J1xcXFx1MjMwRScsJ3VyaW5nJzonXFxcXHUwMTZGJywnVXJpbmcnOidcXFxcdTAxNkUnLCd1cnRyaSc6J1xcXFx1MjVGOScsJ3VzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0EnLCdVc2NyJzonXFxcXHVEODM1XFxcXHVEQ0IwJywndXRkb3QnOidcXFxcdTIyRjAnLCd1dGlsZGUnOidcXFxcdTAxNjknLCdVdGlsZGUnOidcXFxcdTAxNjgnLCd1dHJpJzonXFxcXHUyNUI1JywndXRyaWYnOidcXFxcdTI1QjQnLCd1dWFycic6J1xcXFx1MjFDOCcsJ3V1bWwnOidcXFxceEZDJywnVXVtbCc6J1xcXFx4REMnLCd1d2FuZ2xlJzonXFxcXHUyOUE3JywndmFuZ3J0JzonXFxcXHUyOTlDJywndmFyZXBzaWxvbic6J1xcXFx1MDNGNScsJ3ZhcmthcHBhJzonXFxcXHUwM0YwJywndmFybm90aGluZyc6J1xcXFx1MjIwNScsJ3ZhcnBoaSc6J1xcXFx1MDNENScsJ3ZhcnBpJzonXFxcXHUwM0Q2JywndmFycHJvcHRvJzonXFxcXHUyMjFEJywndmFycic6J1xcXFx1MjE5NScsJ3ZBcnInOidcXFxcdTIxRDUnLCd2YXJyaG8nOidcXFxcdTAzRjEnLCd2YXJzaWdtYSc6J1xcXFx1MDNDMicsJ3ZhcnN1YnNldG5lcSc6J1xcXFx1MjI4QVxcXFx1RkUwMCcsJ3ZhcnN1YnNldG5lcXEnOidcXFxcdTJBQ0JcXFxcdUZFMDAnLCd2YXJzdXBzZXRuZXEnOidcXFxcdTIyOEJcXFxcdUZFMDAnLCd2YXJzdXBzZXRuZXFxJzonXFxcXHUyQUNDXFxcXHVGRTAwJywndmFydGhldGEnOidcXFxcdTAzRDEnLCd2YXJ0cmlhbmdsZWxlZnQnOidcXFxcdTIyQjInLCd2YXJ0cmlhbmdsZXJpZ2h0JzonXFxcXHUyMkIzJywndkJhcic6J1xcXFx1MkFFOCcsJ1ZiYXInOidcXFxcdTJBRUInLCd2QmFydic6J1xcXFx1MkFFOScsJ3ZjeSc6J1xcXFx1MDQzMicsJ1ZjeSc6J1xcXFx1MDQxMicsJ3ZkYXNoJzonXFxcXHUyMkEyJywndkRhc2gnOidcXFxcdTIyQTgnLCdWZGFzaCc6J1xcXFx1MjJBOScsJ1ZEYXNoJzonXFxcXHUyMkFCJywnVmRhc2hsJzonXFxcXHUyQUU2JywndmVlJzonXFxcXHUyMjI4JywnVmVlJzonXFxcXHUyMkMxJywndmVlYmFyJzonXFxcXHUyMkJCJywndmVlZXEnOidcXFxcdTIyNUEnLCd2ZWxsaXAnOidcXFxcdTIyRUUnLCd2ZXJiYXInOid8JywnVmVyYmFyJzonXFxcXHUyMDE2JywndmVydCc6J3wnLCdWZXJ0JzonXFxcXHUyMDE2JywnVmVydGljYWxCYXInOidcXFxcdTIyMjMnLCdWZXJ0aWNhbExpbmUnOid8JywnVmVydGljYWxTZXBhcmF0b3InOidcXFxcdTI3NTgnLCdWZXJ0aWNhbFRpbGRlJzonXFxcXHUyMjQwJywnVmVyeVRoaW5TcGFjZSc6J1xcXFx1MjAwQScsJ3Zmcic6J1xcXFx1RDgzNVxcXFx1REQzMycsJ1Zmcic6J1xcXFx1RDgzNVxcXFx1REQxOScsJ3ZsdHJpJzonXFxcXHUyMkIyJywndm5zdWInOidcXFxcdTIyODJcXFxcdTIwRDInLCd2bnN1cCc6J1xcXFx1MjI4M1xcXFx1MjBEMicsJ3ZvcGYnOidcXFxcdUQ4MzVcXFxcdURENjcnLCdWb3BmJzonXFxcXHVEODM1XFxcXHVERDREJywndnByb3AnOidcXFxcdTIyMUQnLCd2cnRyaSc6J1xcXFx1MjJCMycsJ3ZzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0InLCdWc2NyJzonXFxcXHVEODM1XFxcXHVEQ0IxJywndnN1Ym5lJzonXFxcXHUyMjhBXFxcXHVGRTAwJywndnN1Ym5FJzonXFxcXHUyQUNCXFxcXHVGRTAwJywndnN1cG5lJzonXFxcXHUyMjhCXFxcXHVGRTAwJywndnN1cG5FJzonXFxcXHUyQUNDXFxcXHVGRTAwJywnVnZkYXNoJzonXFxcXHUyMkFBJywndnppZ3phZyc6J1xcXFx1Mjk5QScsJ3djaXJjJzonXFxcXHUwMTc1JywnV2NpcmMnOidcXFxcdTAxNzQnLCd3ZWRiYXInOidcXFxcdTJBNUYnLCd3ZWRnZSc6J1xcXFx1MjIyNycsJ1dlZGdlJzonXFxcXHUyMkMwJywnd2VkZ2VxJzonXFxcXHUyMjU5Jywnd2VpZXJwJzonXFxcXHUyMTE4Jywnd2ZyJzonXFxcXHVEODM1XFxcXHVERDM0JywnV2ZyJzonXFxcXHVEODM1XFxcXHVERDFBJywnd29wZic6J1xcXFx1RDgzNVxcXFx1REQ2OCcsJ1dvcGYnOidcXFxcdUQ4MzVcXFxcdURENEUnLCd3cCc6J1xcXFx1MjExOCcsJ3dyJzonXFxcXHUyMjQwJywnd3JlYXRoJzonXFxcXHUyMjQwJywnd3Njcic6J1xcXFx1RDgzNVxcXFx1RENDQycsJ1dzY3InOidcXFxcdUQ4MzVcXFxcdURDQjInLCd4Y2FwJzonXFxcXHUyMkMyJywneGNpcmMnOidcXFxcdTI1RUYnLCd4Y3VwJzonXFxcXHUyMkMzJywneGR0cmknOidcXFxcdTI1QkQnLCd4ZnInOidcXFxcdUQ4MzVcXFxcdUREMzUnLCdYZnInOidcXFxcdUQ4MzVcXFxcdUREMUInLCd4aGFycic6J1xcXFx1MjdGNycsJ3hoQXJyJzonXFxcXHUyN0ZBJywneGknOidcXFxcdTAzQkUnLCdYaSc6J1xcXFx1MDM5RScsJ3hsYXJyJzonXFxcXHUyN0Y1JywneGxBcnInOidcXFxcdTI3RjgnLCd4bWFwJzonXFxcXHUyN0ZDJywneG5pcyc6J1xcXFx1MjJGQicsJ3hvZG90JzonXFxcXHUyQTAwJywneG9wZic6J1xcXFx1RDgzNVxcXFx1REQ2OScsJ1hvcGYnOidcXFxcdUQ4MzVcXFxcdURENEYnLCd4b3BsdXMnOidcXFxcdTJBMDEnLCd4b3RpbWUnOidcXFxcdTJBMDInLCd4cmFycic6J1xcXFx1MjdGNicsJ3hyQXJyJzonXFxcXHUyN0Y5JywneHNjcic6J1xcXFx1RDgzNVxcXFx1RENDRCcsJ1hzY3InOidcXFxcdUQ4MzVcXFxcdURDQjMnLCd4c3FjdXAnOidcXFxcdTJBMDYnLCd4dXBsdXMnOidcXFxcdTJBMDQnLCd4dXRyaSc6J1xcXFx1MjVCMycsJ3h2ZWUnOidcXFxcdTIyQzEnLCd4d2VkZ2UnOidcXFxcdTIyQzAnLCd5YWN1dGUnOidcXFxceEZEJywnWWFjdXRlJzonXFxcXHhERCcsJ3lhY3knOidcXFxcdTA0NEYnLCdZQWN5JzonXFxcXHUwNDJGJywneWNpcmMnOidcXFxcdTAxNzcnLCdZY2lyYyc6J1xcXFx1MDE3NicsJ3ljeSc6J1xcXFx1MDQ0QicsJ1ljeSc6J1xcXFx1MDQyQicsJ3llbic6J1xcXFx4QTUnLCd5ZnInOidcXFxcdUQ4MzVcXFxcdUREMzYnLCdZZnInOidcXFxcdUQ4MzVcXFxcdUREMUMnLCd5aWN5JzonXFxcXHUwNDU3JywnWUljeSc6J1xcXFx1MDQwNycsJ3lvcGYnOidcXFxcdUQ4MzVcXFxcdURENkEnLCdZb3BmJzonXFxcXHVEODM1XFxcXHVERDUwJywneXNjcic6J1xcXFx1RDgzNVxcXFx1RENDRScsJ1lzY3InOidcXFxcdUQ4MzVcXFxcdURDQjQnLCd5dWN5JzonXFxcXHUwNDRFJywnWVVjeSc6J1xcXFx1MDQyRScsJ3l1bWwnOidcXFxceEZGJywnWXVtbCc6J1xcXFx1MDE3OCcsJ3phY3V0ZSc6J1xcXFx1MDE3QScsJ1phY3V0ZSc6J1xcXFx1MDE3OScsJ3pjYXJvbic6J1xcXFx1MDE3RScsJ1pjYXJvbic6J1xcXFx1MDE3RCcsJ3pjeSc6J1xcXFx1MDQzNycsJ1pjeSc6J1xcXFx1MDQxNycsJ3pkb3QnOidcXFxcdTAxN0MnLCdaZG90JzonXFxcXHUwMTdCJywnemVldHJmJzonXFxcXHUyMTI4JywnWmVyb1dpZHRoU3BhY2UnOidcXFxcdTIwMEInLCd6ZXRhJzonXFxcXHUwM0I2JywnWmV0YSc6J1xcXFx1MDM5NicsJ3pmcic6J1xcXFx1RDgzNVxcXFx1REQzNycsJ1pmcic6J1xcXFx1MjEyOCcsJ3poY3knOidcXFxcdTA0MzYnLCdaSGN5JzonXFxcXHUwNDE2JywnemlncmFycic6J1xcXFx1MjFERCcsJ3pvcGYnOidcXFxcdUQ4MzVcXFxcdURENkInLCdab3BmJzonXFxcXHUyMTI0JywnenNjcic6J1xcXFx1RDgzNVxcXFx1RENDRicsJ1pzY3InOidcXFxcdUQ4MzVcXFxcdURDQjUnLCd6d2onOidcXFxcdTIwMEQnLCd6d25qJzonXFxcXHUyMDBDJ307XFxuXFx0dmFyIGRlY29kZU1hcExlZ2FjeSA9IHsnYWFjdXRlJzonXFxcXHhFMScsJ0FhY3V0ZSc6J1xcXFx4QzEnLCdhY2lyYyc6J1xcXFx4RTInLCdBY2lyYyc6J1xcXFx4QzInLCdhY3V0ZSc6J1xcXFx4QjQnLCdhZWxpZyc6J1xcXFx4RTYnLCdBRWxpZyc6J1xcXFx4QzYnLCdhZ3JhdmUnOidcXFxceEUwJywnQWdyYXZlJzonXFxcXHhDMCcsJ2FtcCc6JyYnLCdBTVAnOicmJywnYXJpbmcnOidcXFxceEU1JywnQXJpbmcnOidcXFxceEM1JywnYXRpbGRlJzonXFxcXHhFMycsJ0F0aWxkZSc6J1xcXFx4QzMnLCdhdW1sJzonXFxcXHhFNCcsJ0F1bWwnOidcXFxceEM0JywnYnJ2YmFyJzonXFxcXHhBNicsJ2NjZWRpbCc6J1xcXFx4RTcnLCdDY2VkaWwnOidcXFxceEM3JywnY2VkaWwnOidcXFxceEI4JywnY2VudCc6J1xcXFx4QTInLCdjb3B5JzonXFxcXHhBOScsJ0NPUFknOidcXFxceEE5JywnY3VycmVuJzonXFxcXHhBNCcsJ2RlZyc6J1xcXFx4QjAnLCdkaXZpZGUnOidcXFxceEY3JywnZWFjdXRlJzonXFxcXHhFOScsJ0VhY3V0ZSc6J1xcXFx4QzknLCdlY2lyYyc6J1xcXFx4RUEnLCdFY2lyYyc6J1xcXFx4Q0EnLCdlZ3JhdmUnOidcXFxceEU4JywnRWdyYXZlJzonXFxcXHhDOCcsJ2V0aCc6J1xcXFx4RjAnLCdFVEgnOidcXFxceEQwJywnZXVtbCc6J1xcXFx4RUInLCdFdW1sJzonXFxcXHhDQicsJ2ZyYWMxMic6J1xcXFx4QkQnLCdmcmFjMTQnOidcXFxceEJDJywnZnJhYzM0JzonXFxcXHhCRScsJ2d0JzonPicsJ0dUJzonPicsJ2lhY3V0ZSc6J1xcXFx4RUQnLCdJYWN1dGUnOidcXFxceENEJywnaWNpcmMnOidcXFxceEVFJywnSWNpcmMnOidcXFxceENFJywnaWV4Y2wnOidcXFxceEExJywnaWdyYXZlJzonXFxcXHhFQycsJ0lncmF2ZSc6J1xcXFx4Q0MnLCdpcXVlc3QnOidcXFxceEJGJywnaXVtbCc6J1xcXFx4RUYnLCdJdW1sJzonXFxcXHhDRicsJ2xhcXVvJzonXFxcXHhBQicsJ2x0JzonPCcsJ0xUJzonPCcsJ21hY3InOidcXFxceEFGJywnbWljcm8nOidcXFxceEI1JywnbWlkZG90JzonXFxcXHhCNycsJ25ic3AnOidcXFxceEEwJywnbm90JzonXFxcXHhBQycsJ250aWxkZSc6J1xcXFx4RjEnLCdOdGlsZGUnOidcXFxceEQxJywnb2FjdXRlJzonXFxcXHhGMycsJ09hY3V0ZSc6J1xcXFx4RDMnLCdvY2lyYyc6J1xcXFx4RjQnLCdPY2lyYyc6J1xcXFx4RDQnLCdvZ3JhdmUnOidcXFxceEYyJywnT2dyYXZlJzonXFxcXHhEMicsJ29yZGYnOidcXFxceEFBJywnb3JkbSc6J1xcXFx4QkEnLCdvc2xhc2gnOidcXFxceEY4JywnT3NsYXNoJzonXFxcXHhEOCcsJ290aWxkZSc6J1xcXFx4RjUnLCdPdGlsZGUnOidcXFxceEQ1Jywnb3VtbCc6J1xcXFx4RjYnLCdPdW1sJzonXFxcXHhENicsJ3BhcmEnOidcXFxceEI2JywncGx1c21uJzonXFxcXHhCMScsJ3BvdW5kJzonXFxcXHhBMycsJ3F1b3QnOidcXFwiJywnUVVPVCc6J1xcXCInLCdyYXF1byc6J1xcXFx4QkInLCdyZWcnOidcXFxceEFFJywnUkVHJzonXFxcXHhBRScsJ3NlY3QnOidcXFxceEE3Jywnc2h5JzonXFxcXHhBRCcsJ3N1cDEnOidcXFxceEI5Jywnc3VwMic6J1xcXFx4QjInLCdzdXAzJzonXFxcXHhCMycsJ3N6bGlnJzonXFxcXHhERicsJ3Rob3JuJzonXFxcXHhGRScsJ1RIT1JOJzonXFxcXHhERScsJ3RpbWVzJzonXFxcXHhENycsJ3VhY3V0ZSc6J1xcXFx4RkEnLCdVYWN1dGUnOidcXFxceERBJywndWNpcmMnOidcXFxceEZCJywnVWNpcmMnOidcXFxceERCJywndWdyYXZlJzonXFxcXHhGOScsJ1VncmF2ZSc6J1xcXFx4RDknLCd1bWwnOidcXFxceEE4JywndXVtbCc6J1xcXFx4RkMnLCdVdW1sJzonXFxcXHhEQycsJ3lhY3V0ZSc6J1xcXFx4RkQnLCdZYWN1dGUnOidcXFxceEREJywneWVuJzonXFxcXHhBNScsJ3l1bWwnOidcXFxceEZGJ307XFxuXFx0dmFyIGRlY29kZU1hcE51bWVyaWMgPSB7JzAnOidcXFxcdUZGRkQnLCcxMjgnOidcXFxcdTIwQUMnLCcxMzAnOidcXFxcdTIwMUEnLCcxMzEnOidcXFxcdTAxOTInLCcxMzInOidcXFxcdTIwMUUnLCcxMzMnOidcXFxcdTIwMjYnLCcxMzQnOidcXFxcdTIwMjAnLCcxMzUnOidcXFxcdTIwMjEnLCcxMzYnOidcXFxcdTAyQzYnLCcxMzcnOidcXFxcdTIwMzAnLCcxMzgnOidcXFxcdTAxNjAnLCcxMzknOidcXFxcdTIwMzknLCcxNDAnOidcXFxcdTAxNTInLCcxNDInOidcXFxcdTAxN0QnLCcxNDUnOidcXFxcdTIwMTgnLCcxNDYnOidcXFxcdTIwMTknLCcxNDcnOidcXFxcdTIwMUMnLCcxNDgnOidcXFxcdTIwMUQnLCcxNDknOidcXFxcdTIwMjInLCcxNTAnOidcXFxcdTIwMTMnLCcxNTEnOidcXFxcdTIwMTQnLCcxNTInOidcXFxcdTAyREMnLCcxNTMnOidcXFxcdTIxMjInLCcxNTQnOidcXFxcdTAxNjEnLCcxNTUnOidcXFxcdTIwM0EnLCcxNTYnOidcXFxcdTAxNTMnLCcxNTgnOidcXFxcdTAxN0UnLCcxNTknOidcXFxcdTAxNzgnfTtcXG5cXHR2YXIgaW52YWxpZFJlZmVyZW5jZUNvZGVQb2ludHMgPSBbMSwyLDMsNCw1LDYsNyw4LDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDEyNywxMjgsMTI5LDEzMCwxMzEsMTMyLDEzMywxMzQsMTM1LDEzNiwxMzcsMTM4LDEzOSwxNDAsMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDYsMTQ3LDE0OCwxNDksMTUwLDE1MSwxNTIsMTUzLDE1NCwxNTUsMTU2LDE1NywxNTgsMTU5LDY0OTc2LDY0OTc3LDY0OTc4LDY0OTc5LDY0OTgwLDY0OTgxLDY0OTgyLDY0OTgzLDY0OTg0LDY0OTg1LDY0OTg2LDY0OTg3LDY0OTg4LDY0OTg5LDY0OTkwLDY0OTkxLDY0OTkyLDY0OTkzLDY0OTk0LDY0OTk1LDY0OTk2LDY0OTk3LDY0OTk4LDY0OTk5LDY1MDAwLDY1MDAxLDY1MDAyLDY1MDAzLDY1MDA0LDY1MDA1LDY1MDA2LDY1MDA3LDY1NTM0LDY1NTM1LDEzMTA3MCwxMzEwNzEsMTk2NjA2LDE5NjYwNywyNjIxNDIsMjYyMTQzLDMyNzY3OCwzMjc2NzksMzkzMjE0LDM5MzIxNSw0NTg3NTAsNDU4NzUxLDUyNDI4Niw1MjQyODcsNTg5ODIyLDU4OTgyMyw2NTUzNTgsNjU1MzU5LDcyMDg5NCw3MjA4OTUsNzg2NDMwLDc4NjQzMSw4NTE5NjYsODUxOTY3LDkxNzUwMiw5MTc1MDMsOTgzMDM4LDk4MzAzOSwxMDQ4NTc0LDEwNDg1NzUsMTExNDExMCwxMTE0MTExXTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcXG5cXG5cXHR2YXIgb2JqZWN0ID0ge307XFxuXFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xcblxcdHZhciBoYXMgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5TmFtZSkge1xcblxcdFxcdHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHlOYW1lKTtcXG5cXHR9O1xcblxcblxcdHZhciBjb250YWlucyA9IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xcblxcdFxcdHZhciBpbmRleCA9IC0xO1xcblxcdFxcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG5cXHRcXHRcXHRpZiAoYXJyYXlbaW5kZXhdID09IHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fTtcXG5cXG5cXHR2YXIgbWVyZ2UgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xcblxcdFxcdGlmICghb3B0aW9ucykge1xcblxcdFxcdFxcdHJldHVybiBkZWZhdWx0cztcXG5cXHRcXHR9XFxuXFx0XFx0dmFyIHJlc3VsdCA9IHt9O1xcblxcdFxcdHZhciBrZXk7XFxuXFx0XFx0Zm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcXG5cXHRcXHRcXHQvLyBBIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2sgaXMgbm90IG5lZWRlZCBoZXJlLCBzaW5jZSBvbmx5IHJlY29nbml6ZWRcXG5cXHRcXHRcXHQvLyBvcHRpb24gbmFtZXMgYXJlIHVzZWQgYW55d2F5LiBBbnkgb3RoZXJzIGFyZSBpZ25vcmVkLlxcblxcdFxcdFxcdHJlc3VsdFtrZXldID0gaGFzKG9wdGlvbnMsIGtleSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0c1trZXldO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdH07XFxuXFxuXFx0Ly8gTW9kaWZpZWQgdmVyc2lvbiBvZiBgdWNzMmVuY29kZWA7IHNlZSBodHRwczovL210aHMuYmUvcHVueWNvZGUuXFxuXFx0dmFyIGNvZGVQb2ludFRvU3ltYm9sID0gZnVuY3Rpb24oY29kZVBvaW50LCBzdHJpY3QpIHtcXG5cXHRcXHR2YXIgb3V0cHV0ID0gJyc7XFxuXFx0XFx0aWYgKChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XFxuXFx0XFx0XFx0Ly8gU2VlIGlzc3VlICM0OlxcblxcdFxcdFxcdC8vIOKAnE90aGVyd2lzZSwgaWYgdGhlIG51bWJlciBpcyBpbiB0aGUgcmFuZ2UgMHhEODAwIHRvIDB4REZGRiBvciBpc1xcblxcdFxcdFxcdC8vIGdyZWF0ZXIgdGhhbiAweDEwRkZGRiwgdGhlbiB0aGlzIGlzIGEgcGFyc2UgZXJyb3IuIFJldHVybiBhIFUrRkZGRFxcblxcdFxcdFxcdC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUi7igJ1cXG5cXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSBvdXRzaWRlIHRoZSBwZXJtaXNzaWJsZSBVbmljb2RlIHJhbmdlJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiAnXFxcXHVGRkZEJztcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKGhhcyhkZWNvZGVNYXBOdW1lcmljLCBjb2RlUG9pbnQpKSB7XFxuXFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2Rpc2FsbG93ZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZGVjb2RlTWFwTnVtZXJpY1tjb2RlUG9pbnRdO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoc3RyaWN0ICYmIGNvbnRhaW5zKGludmFsaWRSZWZlcmVuY2VDb2RlUG9pbnRzLCBjb2RlUG9pbnQpKSB7XFxuXFx0XFx0XFx0cGFyc2VFcnJvcignZGlzYWxsb3dlZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XFxuXFx0XFx0fVxcblxcdFxcdGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcXG5cXHRcXHRcXHRjb2RlUG9pbnQgLT0gMHgxMDAwMDtcXG5cXHRcXHRcXHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XFxuXFx0XFx0XFx0Y29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XFxuXFx0XFx0fVxcblxcdFxcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcXG5cXHRcXHRyZXR1cm4gb3V0cHV0O1xcblxcdH07XFxuXFxuXFx0dmFyIGhleEVzY2FwZSA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xcblxcdFxcdHJldHVybiAnJiN4JyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICc7JztcXG5cXHR9O1xcblxcblxcdHZhciBkZWNFc2NhcGUgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcXG5cXHRcXHRyZXR1cm4gJyYjJyArIGNvZGVQb2ludCArICc7JztcXG5cXHR9O1xcblxcblxcdHZhciBwYXJzZUVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xcblxcdFxcdHRocm93IEVycm9yKCdQYXJzZSBlcnJvcjogJyArIG1lc3NhZ2UpO1xcblxcdH07XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0dmFyIGVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xcblxcdFxcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBlbmNvZGUub3B0aW9ucyk7XFxuXFx0XFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xcblxcdFxcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkUmF3Q29kZVBvaW50LnRlc3Qoc3RyaW5nKSkge1xcblxcdFxcdFxcdHBhcnNlRXJyb3IoJ2ZvcmJpZGRlbiBjb2RlIHBvaW50Jyk7XFxuXFx0XFx0fVxcblxcdFxcdHZhciBlbmNvZGVFdmVyeXRoaW5nID0gb3B0aW9ucy5lbmNvZGVFdmVyeXRoaW5nO1xcblxcdFxcdHZhciB1c2VOYW1lZFJlZmVyZW5jZXMgPSBvcHRpb25zLnVzZU5hbWVkUmVmZXJlbmNlcztcXG5cXHRcXHR2YXIgYWxsb3dVbnNhZmVTeW1ib2xzID0gb3B0aW9ucy5hbGxvd1Vuc2FmZVN5bWJvbHM7XFxuXFx0XFx0dmFyIGVzY2FwZUNvZGVQb2ludCA9IG9wdGlvbnMuZGVjaW1hbCA/IGRlY0VzY2FwZSA6IGhleEVzY2FwZTtcXG5cXG5cXHRcXHR2YXIgZXNjYXBlQm1wU3ltYm9sID0gZnVuY3Rpb24oc3ltYm9sKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChzeW1ib2wuY2hhckNvZGVBdCgwKSk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAoZW5jb2RlRXZlcnl0aGluZykge1xcblxcdFxcdFxcdC8vIEVuY29kZSBBU0NJSSBzeW1ib2xzLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4QXNjaWlXaGl0ZWxpc3QsIGZ1bmN0aW9uKHN5bWJvbCkge1xcblxcdFxcdFxcdFxcdC8vIFVzZSBuYW1lZCByZWZlcmVuY2VzIGlmIHJlcXVlc3RlZCAmIHBvc3NpYmxlLlxcblxcdFxcdFxcdFxcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMgJiYgaGFzKGVuY29kZU1hcCwgc3ltYm9sKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3ltYm9sXSArICc7JztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVzY2FwZUJtcFN5bWJvbChzeW1ib2wpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdC8vIFNob3J0ZW4gYSBmZXcgZXNjYXBlcyB0aGF0IHJlcHJlc2VudCB0d28gc3ltYm9scywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lXFxuXFx0XFx0XFx0Ly8gaXMgd2l0aGluIHRoZSBBU0NJSSByYW5nZS5cXG5cXHRcXHRcXHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XFxuXFx0XFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nXFxuXFx0XFx0XFx0XFx0XFx0LnJlcGxhY2UoLyZndDtcXFxcdTIwRDIvZywgJyZudmd0OycpXFxuXFx0XFx0XFx0XFx0XFx0LnJlcGxhY2UoLyZsdDtcXFxcdTIwRDIvZywgJyZudmx0OycpXFxuXFx0XFx0XFx0XFx0XFx0LnJlcGxhY2UoLyYjeDY2OyYjeDZBOy9nLCAnJmZqbGlnOycpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMuXFxuXFx0XFx0XFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xcblxcdFxcdFxcdFxcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scyB0aGF0IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgbmFtZWQgcmVmZXJlbmNlLlxcblxcdFxcdFxcdFxcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RW5jb2RlTm9uQXNjaWksIGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdFxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlbmNvZGVNYXAsIHN0cmluZylgIGhlcmUuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBOb3RlOiBhbnkgcmVtYWluaW5nIG5vbi1BU0NJSSBzeW1ib2xzIGFyZSBoYW5kbGVkIG91dHNpZGUgb2YgdGhlIGBpZmAuXFxuXFx0XFx0fSBlbHNlIGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcXG5cXHRcXHRcXHQvLyBBcHBseSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cXG5cXHRcXHRcXHQvLyBFbmNvZGUgYDw+XFxcIicmYCB1c2luZyBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cXG5cXHRcXHRcXHRpZiAoIWFsbG93VW5zYWZlU3ltYm9scykge1xcblxcdFxcdFxcdFxcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBmdW5jdGlvbihzdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7IC8vIG5vIG5lZWQgdG8gY2hlY2sgYGhhcygpYCBoZXJlXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIFNob3J0ZW4gZXNjYXBlcyB0aGF0IHJlcHJlc2VudCB0d28gc3ltYm9scywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lIGlzXFxuXFx0XFx0XFx0Ly8gYDw+XFxcIicmYC5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmdcXG5cXHRcXHRcXHRcXHQucmVwbGFjZSgvJmd0O1xcXFx1MjBEMi9nLCAnJm52Z3Q7JylcXG5cXHRcXHRcXHRcXHQucmVwbGFjZSgvJmx0O1xcXFx1MjBEMi9nLCAnJm52bHQ7Jyk7XFxuXFx0XFx0XFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBuYW1lZCByZWZlcmVuY2UuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0XFx0XFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVuY29kZU1hcCwgc3RyaW5nKWAgaGVyZS5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSBlbHNlIGlmICghYWxsb3dVbnNhZmVTeW1ib2xzKSB7XFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGA8PlxcXCInJmAgdXNpbmcgaGV4YWRlY2ltYWwgZXNjYXBlcywgbm93IHRoYXQgdGhleeKAmXJlIG5vdCBoYW5kbGVkXFxuXFx0XFx0XFx0Ly8gdXNpbmcgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGVzY2FwZUJtcFN5bWJvbCk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBzdHJpbmdcXG5cXHRcXHRcXHQvLyBFbmNvZGUgYXN0cmFsIHN5bWJvbHMuXFxuXFx0XFx0XFx0LnJlcGxhY2UocmVnZXhBc3RyYWxTeW1ib2xzLCBmdW5jdGlvbigkMCkge1xcblxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxcblxcdFxcdFxcdFxcdHZhciBoaWdoID0gJDAuY2hhckNvZGVBdCgwKTtcXG5cXHRcXHRcXHRcXHR2YXIgbG93ID0gJDAuY2hhckNvZGVBdCgxKTtcXG5cXHRcXHRcXHRcXHR2YXIgY29kZVBvaW50ID0gKGhpZ2ggLSAweEQ4MDApICogMHg0MDAgKyBsb3cgLSAweERDMDAgKyAweDEwMDAwO1xcblxcdFxcdFxcdFxcdHJldHVybiBlc2NhcGVDb2RlUG9pbnQoY29kZVBvaW50KTtcXG5cXHRcXHRcXHR9KVxcblxcdFxcdFxcdC8vIEVuY29kZSBhbnkgcmVtYWluaW5nIEJNUCBzeW1ib2xzIHRoYXQgYXJlIG5vdCBwcmludGFibGUgQVNDSUkgc3ltYm9sc1xcblxcdFxcdFxcdC8vIHVzaW5nIGEgaGV4YWRlY2ltYWwgZXNjYXBlLlxcblxcdFxcdFxcdC5yZXBsYWNlKHJlZ2V4Qm1wV2hpdGVsaXN0LCBlc2NhcGVCbXBTeW1ib2wpO1xcblxcdH07XFxuXFx0Ly8gRXhwb3NlIGRlZmF1bHQgb3B0aW9ucyAoc28gdGhleSBjYW4gYmUgb3ZlcnJpZGRlbiBnbG9iYWxseSkuXFxuXFx0ZW5jb2RlLm9wdGlvbnMgPSB7XFxuXFx0XFx0J2FsbG93VW5zYWZlU3ltYm9scyc6IGZhbHNlLFxcblxcdFxcdCdlbmNvZGVFdmVyeXRoaW5nJzogZmFsc2UsXFxuXFx0XFx0J3N0cmljdCc6IGZhbHNlLFxcblxcdFxcdCd1c2VOYW1lZFJlZmVyZW5jZXMnOiBmYWxzZSxcXG5cXHRcXHQnZGVjaW1hbCcgOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0dmFyIGRlY29kZSA9IGZ1bmN0aW9uKGh0bWwsIG9wdGlvbnMpIHtcXG5cXHRcXHRvcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgZGVjb2RlLm9wdGlvbnMpO1xcblxcdFxcdHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcXG5cXHRcXHRpZiAoc3RyaWN0ICYmIHJlZ2V4SW52YWxpZEVudGl0eS50ZXN0KGh0bWwpKSB7XFxuXFx0XFx0XFx0cGFyc2VFcnJvcignbWFsZm9ybWVkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGh0bWwucmVwbGFjZShyZWdleERlY29kZSwgZnVuY3Rpb24oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3KSB7XFxuXFx0XFx0XFx0dmFyIGNvZGVQb2ludDtcXG5cXHRcXHRcXHR2YXIgc2VtaWNvbG9uO1xcblxcdFxcdFxcdHZhciBkZWNEaWdpdHM7XFxuXFx0XFx0XFx0dmFyIGhleERpZ2l0cztcXG5cXHRcXHRcXHR2YXIgcmVmZXJlbmNlO1xcblxcdFxcdFxcdHZhciBuZXh0O1xcblxcdFxcdFxcdGlmICgkMSkge1xcblxcdFxcdFxcdFxcdC8vIERlY29kZSBkZWNpbWFsIGVzY2FwZXMsIGUuZy4gYCYjMTE5NTU4O2AuXFxuXFx0XFx0XFx0XFx0ZGVjRGlnaXRzID0gJDE7XFxuXFx0XFx0XFx0XFx0c2VtaWNvbG9uID0gJDI7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmljdCAmJiAhc2VtaWNvbG9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y29kZVBvaW50ID0gcGFyc2VJbnQoZGVjRGlnaXRzLCAxMCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvZGVQb2ludFRvU3ltYm9sKGNvZGVQb2ludCwgc3RyaWN0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCQzKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRGVjb2RlIGhleGFkZWNpbWFsIGVzY2FwZXMsIGUuZy4gYCYjeDFEMzA2O2AuXFxuXFx0XFx0XFx0XFx0aGV4RGlnaXRzID0gJDM7XFxuXFx0XFx0XFx0XFx0c2VtaWNvbG9uID0gJDQ7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmljdCAmJiAhc2VtaWNvbG9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y29kZVBvaW50ID0gcGFyc2VJbnQoaGV4RGlnaXRzLCAxNik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvZGVQb2ludFRvU3ltYm9sKGNvZGVQb2ludCwgc3RyaWN0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCQ1KSB7XFxuXFx0XFx0XFx0XFx0Ly8gRGVjb2RlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzIHdpdGggdHJhaWxpbmcgYDtgLCBlLmcuIGAmY29weTtgLlxcblxcdFxcdFxcdFxcdHJlZmVyZW5jZSA9ICQ1O1xcblxcdFxcdFxcdFxcdGlmIChoYXMoZGVjb2RlTWFwLCByZWZlcmVuY2UpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGRlY29kZU1hcFtyZWZlcmVuY2VdO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gQW1iaWd1b3VzIGFtcGVyc2FuZC4gaHR0cHM6Ly9tdGhzLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0J25hbWVkIGNoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJ1xcblxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIElmIHdl4oCZcmUgc3RpbGwgaGVyZSwgaXTigJlzIGEgbGVnYWN5IHJlZmVyZW5jZSBmb3Igc3VyZS4gTm8gbmVlZCBmb3IgYW5cXG5cXHRcXHRcXHQvLyBleHRyYSBgaWZgIGNoZWNrLlxcblxcdFxcdFxcdC8vIERlY29kZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyB3aXRob3V0IHRyYWlsaW5nIGA7YCwgZS5nLiBgJmFtcGBcXG5cXHRcXHRcXHQvLyBUaGlzIGlzIG9ubHkgYSBwYXJzZSBlcnJvciBpZiBpdCBnZXRzIGNvbnZlcnRlZCB0byBgJmAsIG9yIGlmIGl0IGlzXFxuXFx0XFx0XFx0Ly8gZm9sbG93ZWQgYnkgYD1gIGluIGFuIGF0dHJpYnV0ZSBjb250ZXh0LlxcblxcdFxcdFxcdHJlZmVyZW5jZSA9ICQ2O1xcblxcdFxcdFxcdG5leHQgPSAkNztcXG5cXHRcXHRcXHRpZiAobmV4dCAmJiBvcHRpb25zLmlzQXR0cmlidXRlVmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0ICYmIG5leHQgPT0gJz0nKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcignYCZgIGRpZCBub3Qgc3RhcnQgYSBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiAkMDtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKFxcblxcdFxcdFxcdFxcdFxcdFxcdCduYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZGVjb2RlTWFwTGVnYWN5LCByZWZlcmVuY2UpYC5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGVjb2RlTWFwTGVnYWN5W3JlZmVyZW5jZV0gKyAobmV4dCB8fCAnJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH07XFxuXFx0Ly8gRXhwb3NlIGRlZmF1bHQgb3B0aW9ucyAoc28gdGhleSBjYW4gYmUgb3ZlcnJpZGRlbiBnbG9iYWxseSkuXFxuXFx0ZGVjb2RlLm9wdGlvbnMgPSB7XFxuXFx0XFx0J2lzQXR0cmlidXRlVmFsdWUnOiBmYWxzZSxcXG5cXHRcXHQnc3RyaWN0JzogZmFsc2VcXG5cXHR9O1xcblxcblxcdHZhciBlc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcXG5cXHRcXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGZ1bmN0aW9uKCQwKSB7XFxuXFx0XFx0XFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVzY2FwZU1hcCwgJDApYCBoZXJlLlxcblxcdFxcdFxcdHJldHVybiBlc2NhcGVNYXBbJDBdO1xcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0dmFyIGhlID0ge1xcblxcdFxcdCd2ZXJzaW9uJzogJzEuMS4xJyxcXG5cXHRcXHQnZW5jb2RlJzogZW5jb2RlLFxcblxcdFxcdCdkZWNvZGUnOiBkZWNvZGUsXFxuXFx0XFx0J2VzY2FwZSc6IGVzY2FwZSxcXG5cXHRcXHQndW5lc2NhcGUnOiBkZWNvZGVcXG5cXHR9O1xcblxcblxcdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xcblxcdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcXG5cXHRpZiAoXFxuXFx0XFx0ZmFsc2VcXG5cXHQpIHtcXG5cXHRcXHRkZWZpbmUoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGhlO1xcblxcdFxcdH0pO1xcblxcdH1cXHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcXG5cXHRcXHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXFxuXFx0XFx0XFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gaGU7XFxuXFx0XFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cXG5cXHRcXHRcXHRmb3IgKHZhciBrZXkgaW4gaGUpIHtcXG5cXHRcXHRcXHRcXHRoYXMoaGUsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBoZVtrZXldKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcXG5cXHRcXHRyb290LmhlID0gaGU7XFxuXFx0fVxcblxcbn0odGhpcykpO1xcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xcbiAgdmFyIGUsIG1cXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXFxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXFxuICB2YXIgbkJpdHMgPSAtN1xcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXFxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxcblxcbiAgaSArPSBkXFxuXFxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgcyA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IGVMZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxcbiAgZSA+Pj0gKC1uQml0cylcXG4gIG5CaXRzICs9IG1MZW5cXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XFxuXFxuICBpZiAoZSA9PT0gMCkge1xcbiAgICBlID0gMSAtIGVCaWFzXFxuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcXG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXFxuICB9IGVsc2Uge1xcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXFxuICAgIGUgPSBlIC0gZUJpYXNcXG4gIH1cXG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXFxufVxcblxcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcXG4gIHZhciBlLCBtLCBjXFxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXFxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxcblxcbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcXG5cXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XFxuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxcbiAgICBlID0gZU1heFxcbiAgfSBlbHNlIHtcXG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXFxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcXG4gICAgICBlLS1cXG4gICAgICBjICo9IDJcXG4gICAgfVxcbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICB2YWx1ZSArPSBydCAvIGNcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcXG4gICAgfVxcbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcXG4gICAgICBlKytcXG4gICAgICBjIC89IDJcXG4gICAgfVxcblxcbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcXG4gICAgICBtID0gMFxcbiAgICAgIGUgPSBlTWF4XFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcXG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcXG4gICAgICBlID0gZSArIGVCaWFzXFxuICAgIH0gZWxzZSB7XFxuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXFxuICAgICAgZSA9IDBcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cXG5cXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cXG4gIGVMZW4gKz0gbUxlblxcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxcblxcbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XFxufVxcblxcbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcXG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXFxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xcbiAgICAgIGNvbnN0cnVjdG9yOiB7XFxuICAgICAgICB2YWx1ZTogY3RvcixcXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG59IGVsc2Uge1xcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XFxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXFxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XFxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcXG4gIH1cXG59XFxuXFxufSx7fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qIVxcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcXG4gKlxcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxcbiAqIEBsaWNlbnNlICBNSVRcXG4gKi9cXG5cXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXFxuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcXG59XFxuXFxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcXG59XFxuXFxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXFxufVxcblxcbn0se31dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xcbn07XFxuXFxufSx7fV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcXG52YXIgXzA3NzcgPSBwYXJzZUludCgnMDc3NycsIDgpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gbWtkaXJQLm1rZGlycCA9IG1rZGlyUC5ta2RpclAgPSBta2RpclA7XFxuXFxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgZiA9IG9wdHM7XFxuICAgICAgICBvcHRzID0ge307XFxuICAgIH1cXG4gICAgZWxzZSBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XFxuICAgIH1cXG4gICAgXFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcXG4gICAgXFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIG1vZGUgPSBfMDc3NyAmICh+cHJvY2Vzcy51bWFzaygpKTtcXG4gICAgfVxcbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xcbiAgICBcXG4gICAgdmFyIGNiID0gZiB8fCBmdW5jdGlvbiAoKSB7fTtcXG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcXG4gICAgXFxuICAgIHhmcy5ta2RpcihwLCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcXG4gICAgICAgIGlmICghZXIpIHtcXG4gICAgICAgICAgICBtYWRlID0gbWFkZSB8fCBwO1xcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBtYWRlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHN3aXRjaCAoZXIuY29kZSkge1xcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6XFxuICAgICAgICAgICAgICAgIG1rZGlyUChwYXRoLmRpcm5hbWUocCksIG9wdHMsIGZ1bmN0aW9uIChlciwgbWFkZSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyKSBjYihlciwgbWFkZSk7XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIG1rZGlyUChwLCBvcHRzLCBjYiwgbWFkZSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICB4ZnMuc3RhdChwLCBmdW5jdGlvbiAoZXIyLCBzdGF0KSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdCBmYWlscywgdGhlbiB0aGF0J3Mgc3VwZXIgd2VpcmQuXFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcjIgfHwgIXN0YXQuaXNEaXJlY3RvcnkoKSkgY2IoZXIsIG1hZGUpXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGNiKG51bGwsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG5cXG5ta2RpclAuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKHAsIG9wdHMsIG1hZGUpIHtcXG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xcbiAgICB9XFxuICAgIFxcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcXG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XFxuICAgIFxcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XFxuICAgIH1cXG4gICAgaWYgKCFtYWRlKSBtYWRlID0gbnVsbDtcXG5cXG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcXG5cXG4gICAgdHJ5IHtcXG4gICAgICAgIHhmcy5ta2RpclN5bmMocCwgbW9kZSk7XFxuICAgICAgICBtYWRlID0gbWFkZSB8fCBwO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnIwKSB7XFxuICAgICAgICBzd2l0Y2ggKGVycjAuY29kZSkge1xcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCcgOlxcbiAgICAgICAgICAgICAgICBtYWRlID0gc3luYyhwYXRoLmRpcm5hbWUocCksIG9wdHMsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICBzeW5jKHAsIG9wdHMsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICB2YXIgc3RhdDtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXQgPSB4ZnMuc3RhdFN5bmMocCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycjEpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHRocm93IGVycjA7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBtYWRlO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiZnNcXFwiOjQwLFxcXCJwYXRoXFxcIjo0MH1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBIZWxwZXJzLlxcbiAqL1xcblxcbnZhciBzID0gMTAwMDtcXG52YXIgbSA9IHMgKiA2MDtcXG52YXIgaCA9IG0gKiA2MDtcXG52YXIgZCA9IGggKiAyNDtcXG52YXIgeSA9IGQgKiAzNjUuMjU7XFxuXFxuLyoqXFxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cXG4gKlxcbiAqIE9wdGlvbnM6XFxuICpcXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XFxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcXG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XFxuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xcbiAgfVxcbiAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge051bWJlcn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcXG4gIHN0ciA9IFN0cmluZyhzdHIpO1xcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG1hdGNoID0gL14oKD86XFxcXGQrKT9cXFxcLj9cXFxcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcXG4gICAgc3RyXFxuICApO1xcbiAgaWYgKCFtYXRjaCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcXG4gIHN3aXRjaCAodHlwZSkge1xcbiAgICBjYXNlICd5ZWFycyc6XFxuICAgIGNhc2UgJ3llYXInOlxcbiAgICBjYXNlICd5cnMnOlxcbiAgICBjYXNlICd5cic6XFxuICAgIGNhc2UgJ3knOlxcbiAgICAgIHJldHVybiBuICogeTtcXG4gICAgY2FzZSAnZGF5cyc6XFxuICAgIGNhc2UgJ2RheSc6XFxuICAgIGNhc2UgJ2QnOlxcbiAgICAgIHJldHVybiBuICogZDtcXG4gICAgY2FzZSAnaG91cnMnOlxcbiAgICBjYXNlICdob3VyJzpcXG4gICAgY2FzZSAnaHJzJzpcXG4gICAgY2FzZSAnaHInOlxcbiAgICBjYXNlICdoJzpcXG4gICAgICByZXR1cm4gbiAqIGg7XFxuICAgIGNhc2UgJ21pbnV0ZXMnOlxcbiAgICBjYXNlICdtaW51dGUnOlxcbiAgICBjYXNlICdtaW5zJzpcXG4gICAgY2FzZSAnbWluJzpcXG4gICAgY2FzZSAnbSc6XFxuICAgICAgcmV0dXJuIG4gKiBtO1xcbiAgICBjYXNlICdzZWNvbmRzJzpcXG4gICAgY2FzZSAnc2Vjb25kJzpcXG4gICAgY2FzZSAnc2Vjcyc6XFxuICAgIGNhc2UgJ3NlYyc6XFxuICAgIGNhc2UgJ3MnOlxcbiAgICAgIHJldHVybiBuICogcztcXG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcXG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxcbiAgICBjYXNlICdtc2Vjcyc6XFxuICAgIGNhc2UgJ21zZWMnOlxcbiAgICBjYXNlICdtcyc6XFxuICAgICAgcmV0dXJuIG47XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXFxuICogQHJldHVybiB7U3RyaW5nfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XFxuICBpZiAobXMgPj0gZCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xcbiAgfVxcbiAgaWYgKG1zID49IGgpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcXG4gIH1cXG4gIGlmIChtcyA+PSBtKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XFxuICB9XFxuICBpZiAobXMgPj0gcykge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xcbiAgfVxcbiAgcmV0dXJuIG1zICsgJ21zJztcXG59XFxuXFxuLyoqXFxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtTdHJpbmd9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxcbiAgICBtcyArICcgbXMnO1xcbn1cXG5cXG4vKipcXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cXG4gKi9cXG5cXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcXG4gIGlmIChtcyA8IG4pIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcXG4gIH1cXG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XFxufVxcblxcbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcXG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xcbn0gZWxzZSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XFxufVxcblxcbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XFxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJjYWxsYmFja1xcXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuICB9XFxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHZhciBhcmdzLCBpO1xcbiAgc3dpdGNoIChsZW4pIHtcXG4gIGNhc2UgMDpcXG4gIGNhc2UgMTpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xcbiAgY2FzZSAyOlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcXG4gICAgfSk7XFxuICBjYXNlIDM6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xcbiAgICB9KTtcXG4gIGNhc2UgNDpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcXG4gICAgfSk7XFxuICBkZWZhdWx0OlxcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xcbiAgICBpID0gMDtcXG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcXG4gICAgfVxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XFxuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XFxuICAgIH0pO1xcbiAgfVxcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcXG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXFxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cXG5cXG52YXIgY2FjaGVkU2V0VGltZW91dDtcXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xcblxcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuKGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xcbiAgICB9XFxufSAoKSlcXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xcbiAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XFxuICAgICAgICB9IGNhdGNoKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxufVxcbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXFxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XFxuICAgICAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG5cXG59XFxudmFyIHF1ZXVlID0gW107XFxudmFyIGRyYWluaW5nID0gZmFsc2U7XFxudmFyIGN1cnJlbnRRdWV1ZTtcXG52YXIgcXVldWVJbmRleCA9IC0xO1xcblxcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcXG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgIH1cXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xcbiAgICB9XFxufVxcblxcbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XFxuICAgIGlmIChkcmFpbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xcbiAgICBkcmFpbmluZyA9IHRydWU7XFxuXFxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIHdoaWxlKGxlbikge1xcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XFxuICAgICAgICBxdWV1ZSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcXG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XFxufVxcblxcbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XFxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XFxuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xcbiAgICB9XFxufTtcXG5cXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXFxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XFxuICAgIHRoaXMuZnVuID0gZnVuO1xcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XFxufVxcbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XFxufTtcXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XFxucHJvY2Vzcy5lbnYgPSB7fTtcXG5wcm9jZXNzLmFyZ3YgPSBbXTtcXG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcXG5wcm9jZXNzLnZlcnNpb25zID0ge307XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuXFxucHJvY2Vzcy5vbiA9IG5vb3A7XFxucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5vbmNlID0gbm9vcDtcXG5wcm9jZXNzLm9mZiA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XFxuXFxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxcblxcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcblxcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XFxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG59O1xcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XFxuXFxufSx7fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcXFwiOjU4fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXFxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3NcXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXFxuLy8gV3JpdGFibGUuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcXG4gIHZhciBrZXlzID0gW107XFxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgIGtleXMucHVzaChrZXkpO1xcbiAgfXJldHVybiBrZXlzO1xcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xcblxcbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XFxuXFxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XFxuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XFxuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcXG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcXG59XFxuXFxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcXG5cXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XFxuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XFxuXFxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XFxuXFxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcXG59XFxuXFxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxcbmZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcXG4gIC8vIHRoZW4gd2UncmUgb2suXFxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcXG5cXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxcbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xcbn1cXG5cXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcXG4gIHNlbGYuZW5kKCk7XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcXG4gIH0sXFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XFxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xcbiAgfVxcbn0pO1xcblxcbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xcbiAgdGhpcy5wdXNoKG51bGwpO1xcbiAgdGhpcy5lbmQoKTtcXG5cXG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXJyKTtcXG59O1xcblxcbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGYoeHNbaV0sIGkpO1xcbiAgfVxcbn1cXG59LHtcXFwiLi9fc3RyZWFtX3JlYWRhYmxlXFxcIjo2MCxcXFwiLi9fc3RyZWFtX3dyaXRhYmxlXFxcIjo2MixcXFwiY29yZS11dGlsLWlzXFxcIjo0MixcXFwiaW5oZXJpdHNcXFwiOjUwLFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6NTV9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXFxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXFxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcXG5cXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xcblxcbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XFxuXFxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcXG59XFxuXFxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2IobnVsbCwgY2h1bmspO1xcbn07XFxufSx7XFxcIi4vX3N0cmVhbV90cmFuc2Zvcm1cXFwiOjYxLFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQyLFxcXCJpbmhlcml0c1xcXCI6NTB9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIER1cGxleDtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG5cXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcXG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XFxufTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLy8gVE9ETyhibWV1cmVyKTogQ2hhbmdlIHRoaXMgYmFjayB0byBjb25zdCBvbmNlIGhvbGUgY2hlY2tzIGFyZVxcbi8vIHByb3Blcmx5IG9wdGltaXplZCBhd2F5IGVhcmx5IGluIElnbml0aW9uK1R1cmJvRmFuLlxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XFxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcXG59XFxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcXG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xcbn1cXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xcbn0gZWxzZSB7XFxuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xcbn1cXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XFxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcXG52YXIgU3RyaW5nRGVjb2RlcjtcXG5cXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xcblxcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XFxuXFxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcXG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXFxuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxcbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXFxuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XFxuXFxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcXG5cXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFxcXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXFxcIlxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcXG5cXG4gIC8vIGNhc3QgdG8gaW50cy5cXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcXG5cXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXFxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxcbiAgLy8gYXJyYXkuc2hpZnQoKVxcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xcbiAgdGhpcy5sZW5ndGggPSAwO1xcbiAgdGhpcy5waXBlcyA9IG51bGw7XFxuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcXG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XFxuXFxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFxcXCJsYXRlclxcXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXFxuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxcbiAgdGhpcy5zeW5jID0gdHJ1ZTtcXG5cXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XFxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XFxuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcXG5cXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcXG5cXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xcblxcbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XFxuXFxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XFxuXFxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XFxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcXG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xcblxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xcblxcbiAgLy8gbGVnYWN5XFxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcXG5cXG4gIGlmIChvcHRpb25zKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcXG4gIH1cXG5cXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xcbn1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xcbiAgfSxcXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxcbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XFxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xcbiAgfVxcbn0pO1xcblxcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcXG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xcbiAgdGhpcy5wdXNoKG51bGwpO1xcbiAgY2IoZXJyKTtcXG59O1xcblxcbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxcbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgc2tpcENodW5rQ2hlY2s7XFxuXFxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XFxuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XFxuICAgICAgICBlbmNvZGluZyA9ICcnO1xcbiAgICAgIH1cXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcXG59O1xcblxcbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXFxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XFxufTtcXG5cXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XFxuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBlcjtcXG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcXG4gICAgaWYgKGVyKSB7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcXG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XFxuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XFxuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcXG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcXG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XFxuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcXG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcXG4gICAgc3RyZWFtLnJlYWQoMCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxcbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XFxuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XFxuXFxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xcbiAgfVxcbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcXG59XFxuXFxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xcbiAgdmFyIGVyO1xcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcXG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XFxuICB9XFxuICByZXR1cm4gZXI7XFxufVxcblxcbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXFxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXFxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XFxufVxcblxcblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xcbn07XFxuXFxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXFxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXFxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XFxuICBpZiAobiA+PSBNQVhfSFdNKSB7XFxuICAgIG4gPSBNQVhfSFdNO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXFxuICAgIC8vIHRpbnkgYW1vdW50c1xcbiAgICBuLS07XFxuICAgIG4gfD0gbiA+Pj4gMTtcXG4gICAgbiB8PSBuID4+PiAyO1xcbiAgICBuIHw9IG4gPj4+IDQ7XFxuICAgIG4gfD0gbiA+Pj4gODtcXG4gICAgbiB8PSBuID4+PiAxNjtcXG4gICAgbisrO1xcbiAgfVxcbiAgcmV0dXJuIG47XFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XFxuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XFxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XFxuICBpZiAobiAhPT0gbikge1xcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xcbiAgfVxcbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXFxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcXG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XFxuICAvLyBEb24ndCBoYXZlIGVub3VnaFxcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICByZXR1cm4gMDtcXG4gIH1cXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XFxufVxcblxcbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXFxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgZGVidWcoJ3JlYWQnLCBuKTtcXG4gIG4gPSBwYXJzZUludChuLCAxMCk7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgdmFyIG5PcmlnID0gbjtcXG5cXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxcbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcXG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XFxuXFxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXFxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXFxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXFxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cXG4gIC8vXFxuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcXG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXFxuICAvL1xcbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXFxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXFxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxcbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XFxuICAvLyAncmVhZGFibGUnIGV0Yy5cXG4gIC8vXFxuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXFxuXFxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXFxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xcblxcbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIGRvUmVhZCA9IHRydWU7XFxuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XFxuICB9XFxuXFxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxcbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcXG4gICAgZG9SZWFkID0gZmFsc2U7XFxuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcXG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XFxuICAgIGRlYnVnKCdkbyByZWFkJyk7XFxuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcXG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XFxuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xcbiAgfVxcblxcbiAgdmFyIHJldDtcXG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcXG5cXG4gIGlmIChyZXQgPT09IG51bGwpIHtcXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgbiA9IDA7XFxuICB9IGVsc2Uge1xcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcXG4gIH1cXG5cXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcXG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XFxuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG5cXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxcbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xcbiAgfVxcblxcbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcXG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XFxuICAgIH1cXG4gIH1cXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcXG5cXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxcbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XFxufVxcblxcbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XFxuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcXG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xcbiAgZmxvdyhzdHJlYW0pO1xcbn1cXG5cXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXFxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxcbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XFxuICAgIHByb2Nlc3NOZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcXG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XFxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcXG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XFxuICAgIHN0cmVhbS5yZWFkKDApO1xcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXFxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcXG4gIH1cXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XFxufVxcblxcbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxcbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcXFwibGVuZ3RoXFxcIiBpcyBzb21ld2hhdFxcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XFxufTtcXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xcbiAgdmFyIHNyYyA9IHRoaXM7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcblxcbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XFxuICAgIGNhc2UgMDpcXG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgMTpcXG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XFxuICAgICAgYnJlYWs7XFxuICAgIGRlZmF1bHQ6XFxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcXG4gICAgICBicmVhaztcXG4gIH1cXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcXG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XFxuXFxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xcblxcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcXG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcXG5cXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XFxuICAgIGRlYnVnKCdvbnVucGlwZScpO1xcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XFxuICAgICAgICBjbGVhbnVwKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvbmVuZCgpIHtcXG4gICAgZGVidWcoJ29uZW5kJyk7XFxuICAgIGRlc3QuZW5kKCk7XFxuICB9XFxuXFxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXFxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXFxuICAvLyB0b28gc2xvdy5cXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XFxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xcblxcbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xcblxcbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXFxuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxcbiAgICAvLyBmbG93aW5nIGFnYWluLlxcbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXFxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xcbiAgfVxcblxcbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXFxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxcbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxcbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XFxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcXG4gICAgZGVidWcoJ29uZGF0YScpO1xcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XFxuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcXG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcXG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXFxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXFxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcXG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XFxuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgc3JjLnBhdXNlKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxcbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxcbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcXG4gICAgdW5waXBlKCk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XFxuICB9XFxuXFxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXFxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxcbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xcbiAgICB1bnBpcGUoKTtcXG4gIH1cXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG4gICAgdW5waXBlKCk7XFxuICB9XFxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcXG5cXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcXG4gICAgZGVidWcoJ3VucGlwZScpO1xcbiAgICBzcmMudW5waXBlKGRlc3QpO1xcbiAgfVxcblxcbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XFxuXFxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXFxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XFxuICAgIHNyYy5yZXN1bWUoKTtcXG4gIH1cXG5cXG4gIHJldHVybiBkZXN0O1xcbn07XFxuXFxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XFxuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XFxuICAgICAgZmxvdyhzcmMpO1xcbiAgICB9XFxuICB9O1xcbn1cXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcXG5cXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcXG5cXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XFxuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxcbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xcblxcbiAgICAvLyBnb3QgYSBtYXRjaC5cXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcXG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxcblxcbiAgaWYgKCFkZXN0KSB7XFxuICAgIC8vIHJlbW92ZSBhbGwuXFxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcXG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XFxuICAgIH1yZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXFxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xcblxcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcXG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xcblxcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXFxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xcblxcbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcXG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XFxuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XFxuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmVzO1xcbn07XFxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xcblxcbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xcbiAgc2VsZi5yZWFkKDApO1xcbn1cXG5cXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXFxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxcblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRlYnVnKCdyZXN1bWUnKTtcXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XFxuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xcbiAgICBwcm9jZXNzTmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XFxuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XFxuICAgIHN0cmVhbS5yZWFkKDApO1xcbiAgfVxcblxcbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XFxuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcXG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcXG4gIGZsb3coc3RyZWFtKTtcXG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcXG59XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncGF1c2UnKTtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XFxuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XFxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxcbn1cXG5cXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxcbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICB2YXIgcGF1c2VkID0gZmFsc2U7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XFxuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLnB1c2gobnVsbCk7XFxuICB9KTtcXG5cXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xcblxcbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xcblxcbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcXG4gICAgaWYgKCFyZXQpIHtcXG4gICAgICBwYXVzZWQgPSB0cnVlO1xcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxcbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcXG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XFxuICAgICAgICB9O1xcbiAgICAgIH0oaSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XFxuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGtQcm94eUV2ZW50c1tuXSkpO1xcbiAgfVxcblxcbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXFxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcXG4gICAgaWYgKHBhdXNlZCkge1xcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBzZWxmO1xcbn07XFxuXFxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxcblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xcblxcbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0Llxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xcbiAgLy8gbm90aGluZyBidWZmZXJlZFxcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XFxuXFxuICB2YXIgcmV0O1xcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XFxuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XFxuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcXG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XFxuICB2YXIgcmV0O1xcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcXG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XFxuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XFxuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXFxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xcbiAgfVxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxcbi8vIGNodW5rcy5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XFxuICB2YXIgYyA9IDE7XFxuICB2YXIgcmV0ID0gcC5kYXRhO1xcbiAgbiAtPSByZXQubGVuZ3RoO1xcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcXG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcXG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcXG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcXG4gICAgbiAtPSBuYjtcXG4gICAgaWYgKG4gPT09IDApIHtcXG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcXG4gICAgICAgICsrYztcXG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XFxuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgICArK2M7XFxuICB9XFxuICBsaXN0Lmxlbmd0aCAtPSBjO1xcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XFxuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XFxuICB2YXIgYyA9IDE7XFxuICBwLmRhdGEuY29weShyZXQpO1xcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcXG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcXG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcXG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xcbiAgICBuIC09IG5iO1xcbiAgICBpZiAobiA9PT0gMCkge1xcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xcbiAgICAgICAgKytjO1xcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcXG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgICsrYztcXG4gIH1cXG4gIGxpc3QubGVuZ3RoIC09IGM7XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG5cXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1xcXCJlbmRSZWFkYWJsZSgpXFxcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xcblxcbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XFxuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcXG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxcbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XFxuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZih4c1tpXSwgaSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XFxuICB9XFxuICByZXR1cm4gLTE7XFxufVxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vX3N0cmVhbV9kdXBsZXhcXFwiOjU4LFxcXCIuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdFxcXCI6NjMsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XFxcIjo2NCxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVxcXCI6NjUsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiY29yZS11dGlsLWlzXFxcIjo0MixcXFwiZXZlbnRzXFxcIjo0NyxcXFwiaW5oZXJpdHNcXFwiOjUwLFxcXCJpc2FycmF5XFxcIjo1MixcXFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcXFwiOjU1LFxcXCJzYWZlLWJ1ZmZlclxcXCI6NzAsXFxcInN0cmluZ19kZWNvZGVyL1xcXCI6NzIsXFxcInV0aWxcXFwiOjM4fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFxcXCJmaWx0ZXJcXFwiLFxcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXFxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcXG4vL1xcbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXFxuLy9cXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XFxuLy9cXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXFxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXFxuLy9cXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxcbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXFxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXFxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3RcXG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXFxuLy9cXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXFxuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XFxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxcbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXFxuLy9cXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXFxuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcXG5cXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcXG5cXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcXG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcXG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xcbiAgfTtcXG5cXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XFxuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcXG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xcblxcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcXG5cXG4gIGlmICghY2IpIHtcXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xcbiAgfVxcblxcbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XFxuICB0cy53cml0ZWNiID0gbnVsbDtcXG5cXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XFxuXFxuICBjYihlcik7XFxuXFxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBycy5yZWFkaW5nID0gZmFsc2U7XFxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcXG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xcblxcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XFxuXFxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcXG5cXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xcblxcbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuXFxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xcblxcbiAgaWYgKG9wdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xcbiAgfVxcblxcbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxcbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XFxuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xcbiAgfSk7XFxufVxcblxcblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcXG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xcbn07XFxuXFxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXFxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxcbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXFxuLy9cXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcXG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxcbi8vXFxuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3NcXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XFxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XFxufTtcXG5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcXG4gIHRzLndyaXRlY2IgPSBjYjtcXG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcXG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XFxuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xcbiAgfVxcbn07XFxuXFxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxcbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcXG5cXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxcbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XFxuICB9XFxufTtcXG5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcXG4gIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xcbiAgICBjYihlcnIyKTtcXG4gICAgX3RoaXMuZW1pdCgnY2xvc2UnKTtcXG4gIH0pO1xcbn07XFxuXFxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XFxuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuXFxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xcblxcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XFxuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xcblxcbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcXG5cXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xcblxcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xcbn1cXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6NTgsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDIsXFxcImluaGVyaXRzXFxcIjo1MH1dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xcblxcbi8qIDxyZXBsYWNlbWVudD4gKi9cXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB0aGlzLmNodW5rID0gY2h1bms7XFxuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XFxuICB0aGlzLmNhbGxiYWNrID0gY2I7XFxuICB0aGlzLm5leHQgPSBudWxsO1xcbn1cXG5cXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3RcXG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgdGhpcy5uZXh0ID0gbnVsbDtcXG4gIHRoaXMuZW50cnkgPSBudWxsO1xcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XFxuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XFxuICB9O1xcbn1cXG4vKiA8L3JlcGxhY2VtZW50PiAqL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHByb2Nlc3NOZXh0VGljaztcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBEdXBsZXg7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGludGVybmFsVXRpbCA9IHtcXG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XFxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcXG59XFxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcXG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xcbn1cXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xcblxcbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XFxuXFxuZnVuY3Rpb24gbm9wKCkge31cXG5cXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXFxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXFxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcXG5cXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xcblxcbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XFxuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XFxuXFxuICAvLyBjYXN0IHRvIGludHMuXFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XFxuXFxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XFxuXFxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxcbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcXG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXFxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XFxuXFxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XFxuXFxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cXG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XFxuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XFxuXFxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXFxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXFxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXFxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcXG5cXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXFxuICAvLyBzb2NrZXQgb3IgZmlsZS5cXG4gIHRoaXMubGVuZ3RoID0gMDtcXG5cXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXFxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcXG4gIHRoaXMuY29ya2VkID0gMDtcXG5cXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcXG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFxcXCJsYXRlclxcXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXFxuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cXG4gIHRoaXMuc3luYyA9IHRydWU7XFxuXFxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXFxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xcbiAgfTtcXG5cXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcXG5cXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xcblxcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG5cXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXFxuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcXG5cXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXFxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XFxuXFxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxcbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcXG5cXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXFxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcXG5cXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XFxufVxcblxcbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcXG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XFxuICB2YXIgb3V0ID0gW107XFxuICB3aGlsZSAoY3VycmVudCkge1xcbiAgICBvdXQucHVzaChjdXJyZW50KTtcXG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcXG4gIH1cXG4gIHJldHVybiBvdXQ7XFxufTtcXG5cXG4oZnVuY3Rpb24gKCkge1xcbiAgdHJ5IHtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcXG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcXG4gICAgfSk7XFxuICB9IGNhdGNoIChfKSB7fVxcbn0pKCk7XFxuXFxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxcbnZhciByZWFsSGFzSW5zdGFuY2U7XFxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcXG5cXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XFxuICAgIH1cXG4gIH0pO1xcbn0gZWxzZSB7XFxuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XFxuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxcbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXFxuXFxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxcbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xcblxcbiAgLy8gbGVnYWN5LlxcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XFxuXFxuICBpZiAob3B0aW9ucykge1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcXG4gIH1cXG5cXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xcbn1cXG5cXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXFxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xcbn07XFxuXFxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XFxuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xcbn1cXG5cXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXFxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcXG4gIHZhciBlciA9IGZhbHNlO1xcblxcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XFxuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XFxuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xcbiAgfVxcbiAgaWYgKGVyKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XFxuICAgIHZhbGlkID0gZmFsc2U7XFxuICB9XFxuICByZXR1cm4gdmFsaWQ7XFxufVxcblxcbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcbiAgdmFyIHJldCA9IGZhbHNlO1xcbiAgdmFyIGlzQnVmID0gX2lzVWludDhBcnJheShjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGU7XFxuXFxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcXG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgY2IgPSBlbmNvZGluZztcXG4gICAgZW5jb2RpbmcgPSBudWxsO1xcbiAgfVxcblxcbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XFxuXFxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcXG5cXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIHN0YXRlLmNvcmtlZCsrO1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBpZiAoc3RhdGUuY29ya2VkKSB7XFxuICAgIHN0YXRlLmNvcmtlZC0tO1xcblxcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XFxuICB9XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XFxuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XFxuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcXG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xcbiAgfVxcbiAgcmV0dXJuIGNodW5rO1xcbn1cXG5cXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXFxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgaWYgKCFpc0J1Zikge1xcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xcbiAgICAgIGlzQnVmID0gdHJ1ZTtcXG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XFxuICAgIH1cXG4gIH1cXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG5cXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XFxuXFxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcXG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxcbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XFxuXFxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcXG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xcbiAgICAgIGNodW5rOiBjaHVuayxcXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXFxuICAgICAgaXNCdWY6IGlzQnVmLFxcbiAgICAgIGNhbGxiYWNrOiBjYixcXG4gICAgICBuZXh0OiBudWxsXFxuICAgIH07XFxuICAgIGlmIChsYXN0KSB7XFxuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICB9XFxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XFxuICB9IGVsc2Uge1xcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XFxuICBzdGF0ZS53cml0ZWNiID0gY2I7XFxuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcXG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XFxuICAtLXN0YXRlLnBlbmRpbmdjYjtcXG5cXG4gIGlmIChzeW5jKSB7XFxuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcXG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XFxuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXFxuICAgIC8vIGFmdGVyIGVycm9yXFxuICAgIHByb2Nlc3NOZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICB9IGVsc2Uge1xcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcXG4gICAgLy8gaXQgaXMgYXN5bmNcXG4gICAgY2IoZXIpO1xcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XFxuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XFxuICBzdGF0ZS53cml0ZWxlbiA9IDA7XFxufVxcblxcbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcXG5cXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XFxuXFxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcXG5cXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzeW5jKSB7XFxuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XFxuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXFxuICAgIH0gZWxzZSB7XFxuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XFxuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XFxuICBzdGF0ZS5wZW5kaW5nY2ItLTtcXG4gIGNiKCk7XFxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcXG59XFxuXFxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcXG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXFxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcXG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XFxuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xcbiAgfVxcbn1cXG5cXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xcblxcbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcXG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcXG5cXG4gICAgdmFyIGNvdW50ID0gMDtcXG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xcbiAgICB3aGlsZSAoZW50cnkpIHtcXG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XFxuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcXG4gICAgICBjb3VudCArPSAxO1xcbiAgICB9XFxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcXG5cXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xcblxcbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcXG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXFxuICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcXG5cXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxcbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXFxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxcbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG4gIH1cXG5cXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xcbn1cXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgY2IgPSBjaHVuaztcXG4gICAgY2h1bmsgPSBudWxsO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGVuY29kaW5nO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9XFxuXFxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xcblxcbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcXG4gICAgc3RhdGUuY29ya2VkID0gMTtcXG4gICAgdGhpcy51bmNvcmsoKTtcXG4gIH1cXG5cXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcXG59O1xcblxcbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcXG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XFxufVxcbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XFxuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgc3RhdGUucGVuZGluZ2NiLS07XFxuICAgIGlmIChlcnIpIHtcXG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xcbiAgICB9XFxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcXG4gIH0pO1xcbn1cXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcXG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xcbiAgICAgIHByb2Nlc3NOZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcXG4gIGlmIChuZWVkKSB7XFxuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBuZWVkO1xcbn1cXG5cXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcXG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xcbiAgaWYgKGNiKSB7XFxuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XFxuICB9XFxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XFxuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcXG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xcbiAgd2hpbGUgKGVudHJ5KSB7XFxuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcXG4gICAgY2IoZXJyKTtcXG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgfVxcbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XFxuICB9IGVsc2Uge1xcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xcbiAgfVxcbn1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xcbiAgfSxcXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxcbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XFxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xcbiAgfVxcbn0pO1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcXG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xcbiAgdGhpcy5lbmQoKTtcXG4gIGNiKGVycik7XFxufTtcXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo1OCxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcXFwiOjY0LFxcXCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtXFxcIjo2NSxcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQyLFxcXCJpbmhlcml0c1xcXCI6NTAsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo1NSxcXFwic2FmZS1idWZmZXJcXFwiOjcwLFxcXCJ1dGlsLWRlcHJlY2F0ZVxcXCI6NzN9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcXG5cXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcXG4gICAgdGhpcy50YWlsID0gbnVsbDtcXG4gICAgdGhpcy5sZW5ndGggPSAwO1xcbiAgfVxcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcXG4gICAgKyt0aGlzLmxlbmd0aDtcXG4gIH07XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XFxuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XFxuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xcbiAgICArK3RoaXMubGVuZ3RoO1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xcbiAgICAtLXRoaXMubGVuZ3RoO1xcbiAgICByZXR1cm4gcmV0O1xcbiAgfTtcXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XFxuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XFxuICAgIHRoaXMubGVuZ3RoID0gMDtcXG4gIH07XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcXG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xcbiAgICB9cmV0dXJuIHJldDtcXG4gIH07XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcXG4gICAgdmFyIGkgPSAwO1xcbiAgICB3aGlsZSAocCkge1xcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcXG4gICAgICBwID0gcC5uZXh0O1xcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9O1xcblxcbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XFxufSgpO1xcbn0se1xcXCJzYWZlLWJ1ZmZlclxcXCI6NzB9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xcbiAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XFxuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xcblxcbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XFxuICAgIGlmIChjYikge1xcbiAgICAgIGNiKGVycik7XFxuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XFxuICAgICAgcHJvY2Vzc05leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXFxuXFxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XFxuICB9XFxuXFxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XFxuICB9XFxuXFxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIGlmICghY2IgJiYgZXJyKSB7XFxuICAgICAgcHJvY2Vzc05leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcXG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcXG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGNiKSB7XFxuICAgICAgY2IoZXJyKTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgZGVzdHJveTogZGVzdHJveSxcXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XFxufTtcXG59LHtcXFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcXFwiOjU1fV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcblxcbn0se1xcXCJldmVudHNcXFwiOjQ3fV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXFxuXFxufSx7XFxcIi4vcmVhZGFibGVcXFwiOjY3fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcXG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XFxuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIjo1OCxcXFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xcXCI6NTksXFxcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcXFwiOjYwLFxcXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xcXCI6NjEsXFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiOjYyfV0sNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxcblxcbn0se1xcXCIuL3JlYWRhYmxlXFxcIjo2N31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xcXCI6NjJ9XSw3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xcbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXFxuXFxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcXG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcXG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxcbiAgfVxcbn1cXG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxcbn0gZWxzZSB7XFxuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxcbn1cXG5cXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXFxuXFxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxcbiAgfVxcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcXG4gICAgfSBlbHNlIHtcXG4gICAgICBidWYuZmlsbChmaWxsKVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBidWYuZmlsbCgwKVxcbiAgfVxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gQnVmZmVyKHNpemUpXFxufVxcblxcblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcXG59XFxuXFxufSx7XFxcImJ1ZmZlclxcXCI6NDF9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XFxuXFxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuXFxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XFxuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XFxuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XFxuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcXG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcXG5cXG5cXG5cXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cXG5cXG5mdW5jdGlvbiBTdHJlYW0oKSB7XFxuICBFRS5jYWxsKHRoaXMpO1xcbn1cXG5cXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XFxuICB2YXIgc291cmNlID0gdGhpcztcXG5cXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XFxuICAgICAgICBzb3VyY2UucGF1c2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XFxuXFxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcXG4gICAgICBzb3VyY2UucmVzdW1lKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXFxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcXG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgfVxcblxcbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XFxuICBmdW5jdGlvbiBvbmVuZCgpIHtcXG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XFxuICAgIGRpZE9uRW5kID0gdHJ1ZTtcXG5cXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG5cXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XFxuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xcbiAgICBkaWRPbkVuZCA9IHRydWU7XFxuXFxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcXG4gIH1cXG5cXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcXG4gICAgY2xlYW51cCgpO1xcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXFxuICAgIH1cXG4gIH1cXG5cXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcXG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XFxuXFxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XFxuXFxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG59LHtcXFwiZXZlbnRzXFxcIjo0NyxcXFwiaW5oZXJpdHNcXFwiOjUwLFxcXCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzXFxcIjo1NyxcXFwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXFxcIjo2NixcXFwicmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzXFxcIjo2NyxcXFwicmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1xcXCI6NjgsXFxcInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qc1xcXCI6Njl9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG5cXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XFxuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcXG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xcbiAgdmFyIHJldHJpZWQ7XFxuICB3aGlsZSAodHJ1ZSkge1xcbiAgICBzd2l0Y2ggKGVuYykge1xcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICAgIHJldHVybiAndXRmOCc7XFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gZW5jO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcXG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXFxuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XFxuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XFxuICByZXR1cm4gbmVuYyB8fCBlbmM7XFxufVxcblxcbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2ZcXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcXG4vLyBjaGFyYWN0ZXJzLlxcbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XFxuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcXG4gIHZhciBuYjtcXG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xcbiAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XFxuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcXG4gICAgICBuYiA9IDQ7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XFxuICAgICAgbmIgPSA0O1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XFxuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XFxuICAgICAgbmIgPSAzO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcXG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcXG4gICAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLmxhc3ROZWVkID0gMDtcXG4gIHRoaXMubGFzdFRvdGFsID0gMDtcXG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xcbn1cXG5cXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcXG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XFxuICB2YXIgcjtcXG4gIHZhciBpO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcXG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcXG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcXG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XFxuICB9IGVsc2Uge1xcbiAgICBpID0gMDtcXG4gIH1cXG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcXG4gIHJldHVybiByIHx8ICcnO1xcbn07XFxuXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcXG5cXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcXG5cXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XFxuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XFxuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XFxuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcXG4gIH1cXG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XFxuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XFxufTtcXG5cXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXFxuLy8gY29udGludWF0aW9uIGJ5dGUuXFxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XFxuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcXG4gIHJldHVybiAtMTtcXG59XFxuXFxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxcbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXFxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcXG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XFxuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XFxuICBpZiAobmIgPj0gMCkge1xcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xcbiAgICByZXR1cm4gbmI7XFxuICB9XFxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XFxuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcXG4gIGlmIChuYiA+PSAwKSB7XFxuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XFxuICAgIHJldHVybiBuYjtcXG4gIH1cXG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcXG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkge1xcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcXG4gICAgfVxcbiAgICByZXR1cm4gbmI7XFxuICB9XFxuICByZXR1cm4gMDtcXG59XFxuXFxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXFxuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3RcXG4vLyBvbmUsIHdlIFxcXCJyZXBsYWNlXFxcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXFxuLy8gVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVycyAoJ1xcXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXFxuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXFxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxcbi8vIGxvb3AuXFxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcXG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcXG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XFxuICAgIHJldHVybiAnXFxcXHVmZmZkJy5yZXBlYXQocCk7XFxuICB9XFxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcXG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xcbiAgICAgIHJldHVybiAnXFxcXHVmZmZkJy5yZXBlYXQocCArIDEpO1xcbiAgICB9XFxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcXG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xcbiAgICAgICAgcmV0dXJuICdcXFxcdWZmZmQnLnJlcGVhdChwICsgMik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XFxuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcXG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XFxuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XFxuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XFxuICB9XFxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcXG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcXG59XFxuXFxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXFxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXFxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XFxuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XFxuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcXG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XFxuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xcbn1cXG5cXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGZvciBlYWNoIGJ1ZmZlcmVkIGJ5dGUgb2YgYSAocGFydGlhbClcXG4vLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC5cXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcXFx1ZmZmZCcucmVwZWF0KHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XFxuICByZXR1cm4gcjtcXG59XFxuXFxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xcbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXFxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XFxuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XFxuICAgIGlmIChyKSB7XFxuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcXG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcXG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XFxuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHI7XFxuICB9XFxuICB0aGlzLmxhc3ROZWVkID0gMTtcXG4gIHRoaXMubGFzdFRvdGFsID0gMjtcXG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcXG59XFxuXFxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2VcXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XFxuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XFxuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XFxuICB9XFxuICByZXR1cm4gcjtcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcXG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XFxuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XFxuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XFxuICB0aGlzLmxhc3RUb3RhbCA9IDM7XFxuICBpZiAobiA9PT0gMSkge1xcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gIH1cXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xcbiAgcmV0dXJuIHI7XFxufVxcblxcbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcXG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XFxufVxcblxcbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcXG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xcbn1cXG59LHtcXFwic2FmZS1idWZmZXJcXFwiOjcwfV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG5cXG4vKipcXG4gKiBNb2R1bGUgZXhwb3J0cy5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcXG5cXG4vKipcXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxcbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXFxuICpcXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cXG4gKlxcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxcbiAqXFxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXFxuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcXFwiZGVwcmVjYXRlZFxcXCIgdmVyc2lvbiBvZiBgZm5gXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcXG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xcbiAgICByZXR1cm4gZm47XFxuICB9XFxuXFxuICB2YXIgd2FybmVkID0gZmFsc2U7XFxuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xcbiAgICBpZiAoIXdhcm5lZCkge1xcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XFxuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcXG4gICAgICB9XFxuICAgICAgd2FybmVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBkZXByZWNhdGVkO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcXG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXFxuICB0cnkge1xcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcXG4gIH0gY2F0Y2ggKF8pIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XFxuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcXG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XFxufVxcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5hcmd1bWVudHNbNF1bNTBdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxcbn0se1xcXCJkdXBcXFwiOjUwfV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XFxuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXFxuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XFxufVxcbn0se31dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcXG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcXG4gIGlmICghaXNTdHJpbmcoZikpIHtcXG4gICAgdmFyIG9iamVjdHMgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcXG4gICAgfVxcbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XFxuICB9XFxuXFxuICB2YXIgaSA9IDE7XFxuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcXG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcXG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcXG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XFxuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XFxuICAgIHN3aXRjaCAoeCkge1xcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJyVqJzpcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xcbiAgICAgICAgfSBjYXRjaCAoXykge1xcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xcbiAgICAgICAgfVxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4geDtcXG4gICAgfVxcbiAgfSk7XFxuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xcbiAgICAgIHN0ciArPSAnICcgKyB4O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gc3RyO1xcbn07XFxuXFxuXFxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0Llxcbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXFxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XFxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxcbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuICB9XFxuXFxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XFxuICAgIHJldHVybiBmbjtcXG4gIH1cXG5cXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XFxuICAgIGlmICghd2FybmVkKSB7XFxuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XFxuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcXG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xcbiAgICAgIH1cXG4gICAgICB3YXJuZWQgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XFxufTtcXG5cXG5cXG52YXIgZGVidWdzID0ge307XFxudmFyIGRlYnVnRW52aXJvbjtcXG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XFxuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcXG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXFxcXFxiJyArIHNldCArICdcXFxcXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcXG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XFxuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xcbn07XFxuXFxuXFxuLyoqXFxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxcbiAqL1xcbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xcbiAgLy8gZGVmYXVsdCBvcHRpb25zXFxuICB2YXIgY3R4ID0ge1xcbiAgICBzZWVuOiBbXSxcXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcXG4gIH07XFxuICAvLyBsZWdhY3kuLi5cXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XFxuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XFxuICAgIC8vIGxlZ2FjeS4uLlxcbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XFxuICB9IGVsc2UgaWYgKG9wdHMpIHtcXG4gICAgLy8gZ290IGFuIFxcXCJvcHRpb25zXFxcIiBvYmplY3RcXG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XFxuICB9XFxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcXG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XFxuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XFxufVxcbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XFxuXFxuXFxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXFxuaW5zcGVjdC5jb2xvcnMgPSB7XFxuICAnYm9sZCcgOiBbMSwgMjJdLFxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcXG4gICdncmV5JyA6IFs5MCwgMzldLFxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXFxuICAnY3lhbicgOiBbMzYsIDM5XSxcXG4gICdncmVlbicgOiBbMzIsIDM5XSxcXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cXG59O1xcblxcbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxcbmluc3BlY3Quc3R5bGVzID0ge1xcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXFxuICAnbnVtYmVyJzogJ3llbGxvdycsXFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcXG4gICdudWxsJzogJ2JvbGQnLFxcbiAgJ3N0cmluZyc6ICdncmVlbicsXFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcXG4gIC8vIFxcXCJuYW1lXFxcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xcbiAgJ3JlZ2V4cCc6ICdyZWQnXFxufTtcXG5cXG5cXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XFxuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xcblxcbiAgaWYgKHN0eWxlKSB7XFxuICAgIHJldHVybiAnXFxcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xcbiAgICAgICAgICAgJ1xcXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHN0cjtcXG4gIH1cXG59XFxuXFxuXFxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcXG4gIHJldHVybiBzdHI7XFxufVxcblxcblxcbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XFxuICB2YXIgaGFzaCA9IHt9O1xcblxcbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gaGFzaDtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XFxuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXFxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcXG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxcbiAgICAgIHZhbHVlICYmXFxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxcbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcXG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcXG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XFxuICBpZiAocHJpbWl0aXZlKSB7XFxuICAgIHJldHVybiBwcmltaXRpdmU7XFxuICB9XFxuXFxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcXG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xcblxcbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XFxuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXFxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxcbiAgaWYgKGlzRXJyb3IodmFsdWUpXFxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XFxuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXFxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xcbiAgICB9XFxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xcbiAgICB9XFxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XFxuXFxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XFxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgYXJyYXkgPSB0cnVlO1xcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcXG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XFxuICB9XFxuXFxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XFxuICB9XFxuXFxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcXG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XFxuICB9XFxuXFxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XFxuXFxuICB2YXIgb3V0cHV0O1xcbiAgaWYgKGFycmF5KSB7XFxuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xcbiAgfSBlbHNlIHtcXG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGN0eC5zZWVuLnBvcCgpO1xcblxcbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcXG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xcbiAgICB2YXIgc2ltcGxlID0gJ1xcXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXFxcInxcXFwiJC9nLCAnJylcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcXFwiXFxcXFxcXFwnXFxcIilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFxcXFwiL2csICdcXFwiJykgKyAnXFxcXCcnO1xcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XFxuICB9XFxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXFxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFxcXCJvYmplY3RcXFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cXG4gIGlmIChpc051bGwodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xcbiAgdmFyIG91dHB1dCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcXG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XFxuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3V0cHV0LnB1c2goJycpO1xcbiAgICB9XFxuICB9XFxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XFxuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxcXGQrJC8pKSB7XFxuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcXG4gICAgICAgICAga2V5LCB0cnVlKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIG91dHB1dDtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcXG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcXG4gIGlmIChkZXNjLmdldCkge1xcbiAgICBpZiAoZGVzYy5zZXQpIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBpZiAoZGVzYy5zZXQpIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XFxuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XFxuICB9XFxuICBpZiAoIXN0cikge1xcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcXG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcXG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxcXG4nKSA+IC0xKSB7XFxuICAgICAgICBpZiAoYXJyYXkpIHtcXG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xcbiAgICAgICAgICB9KS5qb2luKCdcXFxcbicpLnN1YnN0cigyKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN0ciA9ICdcXFxcbicgKyBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xcbiAgICAgICAgICB9KS5qb2luKCdcXFxcbicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxcXGQrJC8pKSB7XFxuICAgICAgcmV0dXJuIHN0cjtcXG4gICAgfVxcbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xcbiAgICBpZiAobmFtZS5tYXRjaCgvXlxcXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcXFwiJC8pKSB7XFxuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XFxuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcXFwiXFxcXFxcXFwnXFxcIilcXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXFxcXCIvZywgJ1xcXCInKVxcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXFxcInxcXFwiJCkvZywgXFxcIidcXFwiKTtcXG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XFxufVxcblxcblxcbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XFxuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XFxuICAgIG51bUxpbmVzRXN0Kys7XFxuICAgIGlmIChjdXIuaW5kZXhPZignXFxcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXFxcdTAwMWJcXFxcW1xcXFxkXFxcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcXG4gIH0sIDApO1xcblxcbiAgaWYgKGxlbmd0aCA+IDYwKSB7XFxuICAgIHJldHVybiBicmFjZXNbMF0gK1xcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcXFxuICcpICtcXG4gICAgICAgICAgICcgJyArXFxuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcXFxuICAnKSArXFxuICAgICAgICAgICAnICcgK1xcbiAgICAgICAgICAgYnJhY2VzWzFdO1xcbiAgfVxcblxcbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcXG59XFxuXFxuXFxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXFxuZnVuY3Rpb24gaXNBcnJheShhcikge1xcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xcbn1cXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xcblxcbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XFxufVxcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xcblxcbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xcblxcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XFxufVxcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcXG5cXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcXG59XFxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xcblxcbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xcbn1cXG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XFxuXFxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XFxufVxcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xcbn1cXG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XFxuXFxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XFxuXFxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcXG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xcbn1cXG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcXG5cXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcXG4gIHJldHVybiBpc09iamVjdChlKSAmJlxcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xcbn1cXG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xcblxcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcXG59XFxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcXG5cXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcXG59XFxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xcblxcbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcXG5cXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBwYWQobikge1xcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XFxufVxcblxcblxcbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xcblxcbi8vIDI2IEZlYiAxNjoxOTozNFxcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcXG4gIHZhciBkID0gbmV3IERhdGUoKTtcXG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcXG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XFxufVxcblxcblxcbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XFxufTtcXG5cXG5cXG4vKipcXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXFxuICpcXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXFxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cXG4gKlxcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcXG4gKiAgICAgcHJvdG90eXBlLlxcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxcbiAqL1xcbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcblxcbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XFxuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcXG5cXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcXG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XFxuICB3aGlsZSAoaS0tKSB7XFxuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcXG4gIH1cXG4gIHJldHVybiBvcmlnaW47XFxufTtcXG5cXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9zdXBwb3J0L2lzQnVmZmVyXFxcIjo3NSxcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJpbmhlcml0c1xcXCI6NzR9XX0se30sWzFdKTtcXG5cIiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xuXHRmdW5jdGlvbiBsb2coZXJyb3IpIHtcblx0XHQodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0JiYgKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKFwiW1NjcmlwdCBMb2FkZXJdXCIsIGVycm9yKTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBJRSA9PCA4XG5cdGZ1bmN0aW9uIGlzSUUoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBhdHRhY2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzSUUoKSkge1xuXHRcdFx0ZXhlY1NjcmlwdChzcmMpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2coXCJFdmFsRXJyb3I6IE5vIGV2YWwgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRsb2coZXJyb3IpO1xuXHR9XG59XG4iLCJyZXF1aXJlKFwiISEvVXNlcnMvYnV0Y2hxdWVlbmluZHJhZ3MvdHVyaW5nL21vZDIvR2FtZVRpbWUvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9idXRjaHF1ZWVuaW5kcmFncy90dXJpbmcvbW9kMi9HYW1lVGltZS9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvYnV0Y2hxdWVlbmluZHJhZ3MvdHVyaW5nL21vZDIvR2FtZVRpbWUvbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzXCIpKSJdLCJzb3VyY2VSb290IjoiIn0=